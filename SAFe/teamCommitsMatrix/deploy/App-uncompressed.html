<!DOCTYPE html>
<html>
<head>
    <title>ART Commit Matrix</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('IntelVelocity', {
	extend: 'Ext.data.Model',
	fields: [
		{name: 'Name', type: 'string'},
		{name: 'PlannedVelocity', type: 'string'},
		{name: 'RealVelocity', type:'string'}
	]
});

Ext.define('IntelTeamCommits', {
	extend: 'Ext.data.Model',
	fields: [
		{name: 'Name', type: 'string'},
		{name: 'ObjectID', type: 'string'},
		{name: 'FormattedID', type:'string'},
		{name: 'Commitment', type: 'string'},
		{name: 'Objective', type:'string'},
		{name: 'Product', type:'string'},
		{name: 'PlannedEnd', type:'string'}
	]
});

Ext.define('IntelRisk', {
	extend: 'Ext.data.Model',
	fields: [
		{name: 'RiskID', type:'string'},
		{name: 'ObjectID', type:'number'},
		{name: 'FormattedID',  type: 'string'},
		{name: 'FeatureName', type:'string'},
		{name: 'Description', type: 'string'},
		{name: 'Impact', type: 'string'},			
		{name: 'Status', type: 'string'},
		{name: 'Contact', type: 'string'},
		{name: 'Checkpoint', type: 'string'},
		{name: 'Edited', type: 'boolean'}
	]
});

Ext.define('IntelDepTeam', {
	extend: 'Ext.data.Model',
	fields: [
		{name: 'TID',  type: 'string'},  //teamDep ID
		{name: 'PID',  type: 'string'},  //pred team id
		{name: 'Sup', type: 'string'}, 
		{name: 'USID', type: 'string'}, //pred formatted id
		{name: 'USName', type: 'string'},
		{name: 'A', type: 'boolean'} //yes/no
	]
});

Ext.define('IntelPredDep', { //predecessor dependencies
	extend: 'Ext.data.Model',
	fields: [
		{name: 'ObjectID', type: 'number'},
		{name: 'DependencyID', type:'string'},
		{name: 'FormattedID',  type: 'string'}, 
		{name: 'UserStoryName',  type: 'string'},
		{name: 'Description', type: 'string'},
		{name: 'Checkpoint', type: 'string'},
		{name: 'Status', type:'string'}, //only set by chief engineers. not viewable in this app
		{name: 'Predecessors', type: 'auto'}, //TID: Pred: ProjectID, supported, UserStoryID, Assigned
		{name: 'Edited', type: 'boolean'}
	]
});		
	
Ext.define('IntelSuccDep', { //predecessor dependency
	extend: 'Ext.data.Model',
	fields: [
		{name: 'ObjectID', type: 'number'},
		{name: 'DependencyID', type:'string'}, //same id as the pred id that references it
		{name: 'SuccUserStoryName', type: 'string' },
		{name: 'SuccFormattedID',  type: 'string'}, 
		{name: 'SuccProjectID', type: 'string'}, //of predecessor team
		{name: 'UserStoryName', type: 'string'}, //can be null!!!!!!!!!!!!
		{name: 'FormattedID',  type: 'string'},  //CAN BE NULL!!!!!!!!!!!!
		{name: 'ReleaseStartDate',  type: 'string'}, 
		{name: 'ReleaseDate',  type: 'string'}, 
		{name: 'Description', type: 'string'}, 
		{name: 'Checkpoint', type: 'string'},
		{name: 'Supported', type: 'string'}, //Yes, No
		{name: 'Assigned', type: 'boolean'}, //yes/no
		{name: 'Edited', type: 'boolean'}
	]
});	

Ext.define('IntelRiskWithProject', {
	extend: 'Ext.data.Model',
	fields: [
		{name: 'ProjectName', type:'string'},
		{name: 'ProjectOID', type:'string'},
		{name: 'RiskID', type:'string'},
		{name: 'ObjectID', type:'number'},
		{name: 'FormattedID',  type: 'string'},
		{name: 'FeatureName', type:'string'},
		{name: 'Description', type: 'string'},
		{name: 'Impact', type: 'string'},			
		{name: 'Status', type: 'string'},
		{name: 'Contact', type: 'string'},
		{name: 'Checkpoint', type: 'string'},
		{name: 'Edited', type: 'boolean'}
	]
});

Ext.define('IntelPredDepWithProject', { //predecessor dependencies
	extend: 'Ext.data.Model',
	fields: [
		{name: 'ProjectName', type:'string'},
		{name: 'ProjectOID', type:'string'},
		{name: 'ObjectID', type: 'number'},
		{name: 'DependencyID', type:'string'},
		{name: 'FormattedID',  type: 'string'}, 
		{name: 'UserStoryName',  type: 'string'},
		{name: 'Description', type: 'string'},
		{name: 'Checkpoint', type: 'string'},
		{name: 'Status', type:'string'}, //only set by chief engineers. not viewable in this app
		{name: 'Predecessors', type: 'auto'}, //TID: Pred: ProjectID, supported, UserStoryID, Assigned
		{name: 'Edited', type: 'boolean'}
	]
});		
                /** this is used if you want to listen to events in the parent window (e.g. useful for rally apps that resize with browser screen
		vertically or things that need to know browser scroll position) 
	You also can artificially fire the events and have the listeners run
*/
Ext.define('WindowListener', {

	__initWindowEventListener: function(eventName){
		var me=this;
		if(!me._windowListeners) me._windowListeners = {};
		me._windowListeners[eventName] = [];
		
		window.parent['on' + eventName] = function(event){ 
			var listeners = me._windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i)
				listeners[i](event);
		};
	},
	
	_addWindowEventListener: function(eventName, fn){
		var me=this;
		if(!me._windowListeners || !me._windowListeners[eventName]) 
			me.__initWindowEventListener(eventName);
		me._windowListeners[eventName].push(fn);
	},
	
	_fireParentWindowEvent: function(eventName){ //eg: resize or scroll
		var me=this;
		if(!me._windowListeners || !me._windowListeners[eventName]) return;
		var listeners = me._windowListeners[eventName];
		for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
	}
});
                /** resizes the iframe to be a little bigger than the inner contents, so theres no ugly double vertical scroll bar **/

Ext.define('IframeResize', {
	requires: ['WindowListener'],
	
	/** resizes the iframe to be the height of all the items in it, with 20 px padding in between + 50 px; */
	__applyIframeResize: function(){ 
		var w = window, p = w.parent, pd = w.parent.document, l = w.location,
			iframe = pd.querySelector('iframe[src="' + l.pathname + l.search + '"]'),
			ip1 = iframe.parentNode,
			ip2 = iframe.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode, //this is apparently the one that matters
			height = 0, next = this.down();
		while(next){
			height += next.getHeight() + next.getEl().getMargin('tb')*1 + next.getEl().getPadding('tb')*1;
			next = next.next();
		}
		height += 150;
		ip1.style.height = height + 'px';
		ip2.style.height = height + 'px';
		iframe.style.height = height + 'px';
	},
	
	_initIframeResize: function(){
		var me=this;
		if(me._addWindowEventListener){
			me._addWindowEventListener('resize', function(){ me.__applyIframeResize(); });
		}
	}
});
                /**  
	THIS IS ONLY USEFUL AS A RALLYAPP MIXIN 
	gives a window-centered alert or confirm dialog box that isn't ugly. 
*/
Ext.define('PrettyAlert', { 
	requires:['WindowListener'],
	
	_alert: function(title, str){
		Ext.MessageBox.alert(title || '', str || '').setY(this.__msgBoxY);
		setTimeout(function(){ //give some time to give the 'ok' or 'yes' button focus
			var x = Ext.MessageBox.down('button');
			while(x.isHidden()) x = x.nextSibling();
			x.focus();
		}, 20);
	},
	
	_confirm: function(title, str, fn){
		Ext.MessageBox.confirm(title || '', str || '', fn || function(){}).setY(this.__msgBoxY);
		setTimeout(function(){
			var x = Ext.MessageBox.down('button');
			while(x.isHidden()) x = x.nextSibling();
			x.focus();
		}, 20);
	},
	

	__applyMessageBoxConfig: function(){ 
		var w = window, p = w.parent, pd = w.parent.document, l = w.location,
			iframe = pd.querySelector('iframe[src="' + l.pathname + l.search + '"]');
		
		var ph = p.getWindowHeight(), 
			ps = p.getScrollY(), 
			ofy = ps + iframe.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
			iyOffset = Math.floor(ph/2 - ofy + ps - 50);
		this.__msgBoxY = iyOffset<0 ? 0 : iyOffset;
	},
	
	/** CALL THIS IN LAUNCH FUNCTION! **/
	_initPrettyAlert: function(){
		var me=this;
		if(me._addWindowEventListener){
			me._addWindowEventListener('resize', function(){ me.__applyMessageBoxConfig(); });
			me._addWindowEventListener('scroll', function(){ me.__applyMessageBoxConfig(); });
		}
	}
});
                Ext.define('IntelWorkweek', {
	
	/** calculates intel workweek, returns integer */
	_getWorkweek: function(date){ 
		var oneDay = 1000 * 60 * 60 * 24,
			yearStart = new Date(date.getFullYear(), 0, 1),
			dayIndex = yearStart.getDay(),
			ww01Start = yearStart - dayIndex*oneDay,
			timeDiff = date - ww01Start,
			dayDiff = timeDiff / oneDay,
			ww = Math.floor(dayDiff/7) + 1,
			leap = (date.getFullYear() % 4 === 0),
			weekCount = ((leap && dayIndex >= 5) || (!leap && dayIndex === 6 )) ? 53 : 52; //weeks in this year
		return weekCount < ww ? 1 : ww;
	},
	
	/** returns the number of intel workweeks in the year the date is in */
	_getWeekCount: function(date){ 
		var leap = (date.getFullYear() % 4 === 0),
			day = new Date(date.getFullYear(), 0, 1).getDay();
		return ((leap && day >= 5) || (!leap && day === 6 )) ? 53 : 52;
	},
	
	/**  gets list of workweeks between startDate and endDate (startDate and endDate dont have to be Date objects)  */
	_getWorkweeks: function(startDate, endDate){ 
		var i,
			sd_week = this._getWorkweek(startDate),
			ed_week = this._getWorkweek(endDate),
			week_count = this._getWeekCount(startDate);
			
		var weeks = [];
		if(ed_week < sd_week){
			for(i=sd_week; i<=week_count; ++i) weeks.push('ww' + i);
			for(i = 1; i<=ed_week;++i) weeks.push('ww' + i);
		}
		else for(i = sd_week; i<=ed_week;++i) weeks.push('ww' + i);
		return weeks;
	}
});
                /** Mixin functions related to queries, you need to require Q as a dependency in your rally app
	Q can be found here: https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js
	most functions return promises that resolve to stores
*/

Ext.define('ReleaseQuery', {
		
	/** gets releases for this project that have release date >= now. returns promise that resolves to the releaseStore */
	_loadReleasesInTheFuture: function(projectRecord){
		var deferred = Q.defer();
		Ext.create('Rally.data.wsapi.Store',{
			model: 'Release',
			limit:Infinity,
			autoLoad:true,
			fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
			context:{
				workspace: this.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'Project.ObjectID',
					value: projectRecord.data.ObjectID
				},{
					property:'ReleaseDate',
					operator:'>=',
					value: new Date().toISOString()
				}
			],
			listeners: {
				load: {
					fn: function(releaseStore, releaseRecords){
						console.log('releases loaded:', releaseRecords);
						deferred.resolve(releaseStore);
					},
					single:true
				}
			}
		});
		return deferred.promise;
	},
	
	/** loads this release for each scrum under this train. returns promise with the release Store 
		the scrums that the releases belong to will have at least 1 team member, and the train's release is not included
		in the results.
	**/
	_loadReleasesWithName: function(releaseName, trainName){ 
		var deferred = Q.defer();
		Ext.create('Rally.data.wsapi.Store',{
			model: 'Release',
			limit:Infinity,
			autoLoad:true,
			fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
			context:{
				workspace: this.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'Name', //match the release
					value: releaseName
				},{
					property:'Project.Name', //is a child of the train
					operator:'contains',
					value:trainName
				},{
					property:'Project.Children.Name', //has teamMembers 
					operator:'=',
					value:''
				},{
					property:'Project.Name', //but not the train release itsself
					operator:'!contains',
					value:' ART'
				}
			],
			listeners: {
				load: {
					fn: function(store, records){
						console.log('releasesWithName loaded:', records);
						deferred.resolve(store);
					},
					single:true
				}
			}
		});
		return deferred.promise;
	},
	
	/** gets the most likely release to scope to base on the following order:
		1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
						to use preferences for this one)
		2) if we are in a release
		3) the closest release planning date to the current date
	*/
	_getScopedRelease: function(releaseRecords, projectOID, appPrefs){
		var me=this,
			d = new Date(),
			rs = releaseRecords,
			prefOID = appPrefs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
		return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
			_.find(rs, function(r){
				return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
			}) ||
			_.reduce(rs, function(best, r){
				if(best===null) return r;
				else {
					var d1 = new Date(best.data.ReleaseStartDate), d2 = new Date(r.data.ReleaseStartDate), now = new Date();
					return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
				}
			}, null);
	}
});
                /**
	the regular proxy calls record.commit() and later on, datarefresh event is called. since these both cause a rerender, 
	we make the record edits SILENT, so only the datarefresh actually rerender the page
*/

Ext.define('Intel.data.proxy.SessionStorage', {
	extend: 'Ext.data.proxy.SessionStorage',
	alias: 'proxy.fastsessionproxy',

	constructor: function(cfg) {
		var me = this;
		me.callParent(arguments);
	},
	
	create: function(operation, callback, scope) {
		var me = this,
			records = operation.records,
			length = records.length,
			ids = me.getIds(),
			id, record, i;

		operation.setStarted();
		if(me.isHierarchical === undefined) {
				
				
			me.isHierarchical = !!records[0].isNode;
			if(me.isHierarchical) {
				me.getStorageObject().setItem(me.getTreeKey(), true);
			}
		}
		for (i = 0; i < length; i++) {
			record = records[i];

			if (record.phantom) {
				record.phantom = false;
				id = me.getNextId();
			} else {
				id = record.getId();
			}
			
			record.beginEdit();
			me.setRecord(record, id);
			record.endEdit(true); //SILENT!!!
			record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!
			
			ids.push(id);
		}
		me.setIds(ids);

		operation.setCompleted();
		operation.setSuccessful();

		if (typeof callback == 'function') {
			callback.call(scope || me, operation);
		}
	},
	
	update: function(operation, callback, scope) {
		var records = operation.records,
			length = records.length,
			ids = this.getIds(),
			record, id, i;
			
		operation.setStarted();
		for (i = 0; i < length; i++) {
			record = records[i];
			this.setRecord(record);
		
			record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!

			id = record.getId();
			if (id !== undefined && Ext.Array.indexOf(ids, id) == -1) ids.push(id);
		}
		this.setIds(ids);

		operation.setCompleted();
		operation.setSuccessful();
		if (typeof callback == 'function') callback.call(scope || this, operation);
	}
});
                Ext.define('Intel.data.FastStore', {  //doesn't redundantly call fireEvent... me.sync() calls that downstream 
	extend: 'Ext.data.Store',
	alias: 'store.faststore',

	constructor: function(cfg) {
		var me = this;
		me.callParent(arguments);
	},
	
	afterEdit: function(record, modifiedFieldNames) {
		var me = this, i, shouldSync;
		if (me.autoSync && !me.autoSyncSuspended) {
			for (i = modifiedFieldNames.length; i--;) {
				if (record.fields.get(modifiedFieldNames[i]).persist) {
					me.sync();  //all rendering changes made here
					break;
				}
			}
		}
		me.onUpdate(record, Ext.data.Model.EDIT, modifiedFieldNames);
		//me.fireEvent('update', me, record, Ext.data.Model.EDIT, modifiedFieldNames); //redundant with me.sync()
	}
});
                /**
	Cell editing has redundant calls to store.afterEdit, which in turn renders the page multiple times per edit. 
	fastcellediting solves this by wrapping all the calls in beginEdit and endEdit, so store.afterEdit is called only once
*/
Ext.define('Intel.grid.plugin.CellEditing', {
	alias: 'plugin.fastcellediting',
	extend: 'Ext.grid.plugin.CellEditing',
	
	constructor: function() {
		this.callParent(arguments);
	},
	triggerEvent:'cellclick',
	onEditComplete : function(ed, value, startValue) {
		var me = this,
			activeColumn = me.getActiveColumn(),
			context = me.context,
			record;
		if (activeColumn) {
			record = context.record;

			me.setActiveEditor(null);
			me.setActiveColumn(null);
			me.setActiveRecord(null);

			context.value = value;
			if (!me.validateEdit()) {
					me.editing = false;
					return;
			}
			record.beginEdit(); //only call store.AfterEdit at the very End 
			if (!record.isEqual(value, startValue)) 
					record.set(activeColumn.dataIndex, value); //dont call store.AfterEdit

			context.view.focusRow(context.rowIdx, 100);
			me.fireEvent('edit', me, context); //dont call store.AfterEdit if record.set() is called in here
			me.editing = false;
			record.endEdit(); //now call store.AfterEdit!
		}
	}
});
                Ext.define('Intel.view.ScrollTable', {  //keeps the scrollbar steady. Cant believe Extjs cant do this
	extend: 'Ext.view.Table',
	alias: 'widget.scrolltableview',
	
	constructor: function(cfg) {
		var me = this;
		me.callParent(arguments);
	},
	
	refresh: function() {
		var me = this,
			targetEl,
			targetParent,
			oldDisplay,
			nextSibling,
			dom,
			records,
			el = me.getEl(), //edit
			scroll = el && el.getScrollTop();//edit
			
		if (!me.rendered || me.isDestroyed) return;

		if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) {
			targetEl = me.getTargetEl();
			records = me.getViewRange();
			dom = targetEl.dom;
			if (!me.preserveScrollOnRefresh) {
				targetParent = dom.parentNode;
				oldDisplay = dom.style.display;
				dom.style.display = 'none';
				nextSibling = dom.nextSibling;
				targetParent.removeChild(dom);
			}
			if (me.refreshCounter) me.clearViewEl();
			else {
				me.fixedNodes = targetEl.dom.childNodes.length;
				me.refreshCounter = 1;
			}
			me.tpl.append(targetEl, me.collectData(records, me.all.startIndex));

			if (records.length < 1) {
				if (!this.store.loading && (!me.deferEmptyText || me.hasFirstRefresh)) {
					Ext.core.DomHelper.insertHtml('beforeEnd', targetEl.dom, me.emptyText);
				}
				me.all.clear();
			} else {
				me.collectNodes(targetEl.dom);
				me.updateIndexes(0);
			}
			if (me.hasFirstRefresh) {
				if (me.refreshSelmodelOnRefresh !== false) {
					me.selModel.refresh();
				} else {
					me.selModel.pruneIf();
				}
			}
			me.hasFirstRefresh = true;

			if (!me.preserveScrollOnRefresh) {
				targetParent.insertBefore(dom, nextSibling);
				dom.style.display = oldDisplay;
			}

			Ext.suspendLayouts();
			this.refreshSize();
			me.fireEvent('refresh', me);
			Ext.resumeLayouts(true);
			
			if (!me.viewReady) {
				me.viewReady = true;
				me.fireEvent('viewready', me);
			}
		}
		
		if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
	},
	
	onRemove : function(ds, records, indexes) {
		var me = this,
			fireItemRemove = me.hasListeners.itemremove,
			i,
			record,
			index,
			el = me.getEl(),//edit
			scroll = el && el.getScrollTop();//edit

		if (me.all.getCount()) {
			if (me.dataSource.getCount() === 0) {
				if (fireItemRemove) {
					for (i = indexes.length - 1; i >= 0; --i) {
						me.fireEvent('itemremove', records[i], indexes[i]);
					}
				}
				//me.refresh();
			} else {
				for (i = indexes.length - 1; i >= 0; --i) {
					record = records[i];
					index = indexes[i];
					me.doRemove(record, index);
					if (fireItemRemove) {
						me.fireEvent('itemremove', record, index);
					}
				}
				me.updateIndexes(indexes[0]);
			}
			this.refreshSize();
			if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
		}
	},
	
	onUpdate : function(ds, record){
		var me = this,
			index,
			node,
			el = me.getEl(),//edit
			scroll = el && el.getScrollTop();//edit

		if (me.viewReady) {
			index = me.dataSource.indexOf(record);
			if (index > -1) {
				node = me.bufferRender([record], index)[0];
				if (me.getNode(record)) {
					me.all.replaceElement(index, node, true);
					me.updateIndexes(index, index);
					me.selModel.onUpdate(record);
					if (me.hasListeners.itemupdate) {
						me.fireEvent('itemupdate', record, index, node);
					}
					return node;
				}
			}
			if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
		}
	},
	
	onAdd : function(store, records, index) {
		var me = this,
			nodes,
			el = me.getEl(),
			scroll = el && el.getScrollTop();

		if (me.rendered) {
			if (me.all.getCount() === 0) {
				me.refresh();
				nodes = me.all.slice();
			} else {
				nodes = me.doAdd(records, index);
				if (me.refreshSelmodelOnRefresh !== false) {
					me.selModel.refresh();
				}
				me.updateIndexes(index);
				//me.refreshSize(); //already being refreshed by store.sync()
			}

			if (me.hasListeners.itemadd) {
				me.fireEvent('itemadd', records, index, nodes);
			}
			if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
		}
	},

	scrollRowIntoView: function(row) {
		if(row===0){										//this is just added because its a LOT faster and the main use case
			this.getEl().setScrollTop(0);
			return;
		}
		row = this.getNode(row, true);
		if (row) {
			Ext.fly(row).scrollIntoView(this.el, false);
		}
	}
});
                /********************* PRODUCTION *****************/
//console = { log: function(){} };
	
/********************* END PRODUCTION *****************/

Ext.define('CommitMatrix', {
  extend: 'Rally.app.App',
	mixins:[
		'ReleaseQuery',
		'IntelWorkweek'
	],
	layout:'absolute',
	autoScroll:false,
		
	/****************************************************** SHOW ERROR/TEXT MESSAGE ********************************************************/
	_showError: function(text){
		if(this.errMessage) this.remove(this.errMessage);
		this.errMessage = this.add({xtype:'text', text:text});
	},
	/****************************************************** DATA STORE/MODEL METHODS ********************************************************/

	_loadModels: function(cb){
		var me = this;
		Rally.data.ModelFactory.getModel({ //load project
			type:'Project',
			success: function(model){ 
				me.Project = model; 
				Rally.data.ModelFactory.getModel({ //load project
					type:'PortfolioItem/Milestone',
					success: function(model){ 
						me.Milestone = model; 
						cb(); 
					}
				});
			}
		});
	},
	
	_loadProject: function(project, cb){ 
		var me = this;
		me.Project.load(project.ObjectID, {
			fetch: ['ObjectID', 'Children', 'Parent', 'Name'],
			context: {
				workspace: me.getContext().getWorkspace()._ref,
				project: null
			},
			callback: function(record, operation){
				if(operation.wasSuccessful()) cb(record);
				else me._showError('failed to retreive project: ' + project.ObjectID);
			}
		});
	},
	
	_loadMilestone: function(milestone, cb){ 
		var me = this;
		me.Milestone.load(milestone.ObjectID, {
			fetch: ['ObjectID', 'Parent', 'Name'],
			context: {
				workspace: me.getContext().getWorkspace()._ref,
				project: null
			},
			callback: function(record, operation){
				if(operation.wasSuccessful()) cb(record);
				else me._showError('failed to retreive milestone: ' + milestone.ObjectID);
			}
		});
	},
	
	_loadMatrixFeatures: function(cb){ 
		var me = this;
		me.MatrixProductHash = {};
		Ext.create('Rally.data.wsapi.Store',{
			model: 'PortfolioItem/Feature',
			autoLoad:true,
			limit:Infinity,
			fetch: ['Name', 'ObjectID', 'Project', 'Parent', 'FormattedID', 
				'UserStories', 'c_TeamCommits', 'DragAndDropRank', 'PlannedEndDate'],
			context:{
				workspace: me.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'Release.Name',
					value: me.ReleaseRecord.data.Name
				}
			],
			listeners: {
				load: {
					fn: function(featureStore, featureRecords){
						console.log('features loaded:', featureRecords);
						me.MatrixFeatureStore = featureStore;
						var finished = -1;
						var done = function(){ if(++finished == featureRecords.length) { cb(); } };
						done();
						featureRecords.forEach(function(fr){
							var frData = fr.data;
							if(frData.Parent){
								me._loadMilestone(frData.Parent, function(milestoneRecord){
									var p = milestoneRecord.data.Parent;
									me.MatrixProductHash[frData.ObjectID] = ((p && p.Name ) ? p.Name : '');
									done();
								});
							}
							else {
								me.MatrixProductHash[frData.ObjectID] = '';
								done();
							}
							
						});
					},
					single:true
				}
			}
		});
	},
	
	_loadMatrixUserStoryBreakdown: function(cb){
		var me = this;
		me.MatrixUserStoryBreakdown = {};
		me.MatrixProjectMap = {};
		var fRecords = me.MatrixFeatureStore.getRecords();
		var finished = -1;
		var done = function(){ 
			if(++finished == fRecords.length){ 
				console.log('Stories loaded:', me.MatrixUserStoryBreakdown);
				cb(); 
			}
		};
		done();
		fRecords.forEach(function(fRecord){
			Ext.create('Rally.data.wsapi.Store',{
				model:'HierarchicalRequirement',
				fetch: ['ObjectID', 'Project', 'Name', 'Feature', 'FormattedID', 'PlanEstimate'],
				limit:Infinity,
				autoLoad:true,
				context:{
					workspace: me.getContext().getWorkspace()._ref,
					project: null
				},
				filters: [
					{
						property:'Release.Name',
						value:me.ReleaseRecord.data.Name
					},{
						property:'Feature.ObjectID',
						value:fRecord.data.ObjectID
					}
				],
				listeners: {
					load: {
						fn: function(storyStore, storyRecords){
							storyRecords.forEach(function(sr){
								var PName = sr.data.Project.Name;
								var FName = fRecord.data.Name;
								if(!me.MatrixUserStoryBreakdown[PName]) 
									me.MatrixUserStoryBreakdown[PName] = {};
								if(!me.MatrixUserStoryBreakdown[PName][FName]) 
									me.MatrixUserStoryBreakdown[PName][FName] = [];
								me.MatrixUserStoryBreakdown[PName][FName].push(sr);	
								me.MatrixProjectMap[PName] = sr.data.Project.ObjectID;					
							});
							done();
						},
						single:true
					}
				}
			});
		});
	},	
	
	/****************************************************** PROJECTS ************************************/
		
	_getProjectsInScope:function(){
		var projects = "__PROJECT_OIDS_IN_SCOPE__";
		projects = projects.match(/^\d+/)? projects.split(','): [this.context.getProject().ObjectID];
		projectsInScope = {};
		_.each(projects,function(projectID){
			projectsInScope[projectID] = true;
		});
		return projectsInScope;
	},
	
	_addDefaultProjects:function(cb){
		var processedProjects = {}, me=this,
			cached = me._cachedDefaults,
			inScope = me._getProjectsInScope(),
			msub = me.MatrixUserStoryBreakdown,
			feats = me.MatrixFeatureStore.getRange(),
			mpm = me.MatrixProjectMap,
			curProjRef = '/project/' + me.getContext().getProject().ObjectID;

		function addDefaults(projects){
			_.each(projects, function(p){ 
				if(!msub[p.data.Name]){
					msub[p.data.Name] = {}; 
					_.each(feats, function(f){ 
						msub[p.data.Name][f.data.Name] = [];
						mpm[p.data.Name] = p.data.ObjectID;
					});
				}
			});
		}
		if(cached) { addDefaults(cached); if(cb) cb(); }
		
		Ext.create('Rally.data.wsapi.Store', {
			model: "Project",
			fetch: ['Name', 'Parent', 'ObjectID', 'TeamMembers'],
			limit:Infinity,
			context: {
				workspace: '/workspace/' + this.getContext().getWorkspace().ObjectID,
				project:null
			}
		})
		.load({
			callback: function(projects){
				//filter here
				projects = _.filter(projects, function(project){ 
					return inScope[project.data.ObjectID] && project.data.TeamMembers.Count > 0; 
				});
				addDefaults(projects); //add some default projects
				me._cachedDefaults = projects;
				console.log('default projects', projects);
				if(cb) cb();
			}
		});
	},
		
	/*************************************************** DEFINE MODELS ******************************************************/
	_defineModels: function(){								
		Ext.define('IntelFeature', {
			extend: 'Ext.data.Model',
			fields: [
				{name: 'Rank', type:'string'},
				{name: 'FormattedID', type:'string'},
				{name: 'ObjectID', type:'string'},
				{name: 'FeatureName',  type: 'string'},
				{name: 'ProductName', type:'string'},
				{name: 'PlannedEndDate', type:'string'}
			]
		});
	},
	
	/*************************************************** Reload Stores ******************************************************/
	_isReloadRefresh: false,
	
	_reloadMatrixStores: function(){
		var me = this;
		me._loadMatrixFeatures(function(){
			me.featureTCAECache = {};
			if(me.CustomMatrixStore){
				var scroll = me.MatrixGrid.view.getEl().getScrollTop();
				me._isReloadRefresh = true;
				me.CustomMatrixStore.load({ //we use load here because the logic is handled in the renderers
					callback: function(){
						me.MatrixGrid.view.getEl().setScrollTop(scroll);
						setTimeout(function(){ me._isReloadRefresh = false; }, 10);
					}
				});
			}
		});
	},
	
	/*************************************************** RANDOM HELPERS ******************************************************/	
	_projectInWhichTrain: function(projectRecord, cb){ // returns train the projectRecord is in, otherwise null.
		var me = this;
		if(!projectRecord) cb();
		var split = projectRecord.data.Name.split(' ART');
		if(split.length>1) cb(projectRecord);
		else { 
			var parent = projectRecord.data.Parent;
			if(!parent) cb();
			else {
				me._loadProject(parent, function(parentRecord){
					me._projectInWhichTrain(parentRecord, cb);
				});
			}
		}
	},

	
	/************************************************** Event Handler/ window size/scroll config *********************************************/
	
	_alert: function(title, str){
		var me = this;
		Ext.MessageBox.alert(title, str).setY(me._msgBoxY);
		setTimeout(function(){ 
			var x = Ext.MessageBox.down('button');
			while(x.isHidden()) x = x.nextSibling();
			x.focus();
		}, 10);
	},
	
	_getIframe: function(){
		var w = window, p = w.parent, pd = w.parent.document, l = w.location;
		return pd.querySelector('iframe[src="' + l.pathname + l.search + '"]');
	},
	
	_applyMessageBoxConfig: function(){
		var me = this, w = window, p = w.parent, iframe = me._getIframe(),
			ph = p.getWindowHeight(), 
			ps = p.getScrollY(), 
			ofy = ps + iframe.getBoundingClientRect().top, //offset of top of the iframe
			iyOffset = Math.floor(ph/2 - ofy + ps - 50);		
		me._msgBoxY = iyOffset<0 ? 0 : iyOffset;
	},
	
	_changeGridHeight: function(){
		var me = this, w = window, p = w.parent, iframe = me._getIframe(),
			ph = p.getWindowHeight(), 
			ps = p.getScrollY(), 
			ofy = ps + iframe.getBoundingClientRect().top, //offset of top of the iframe
			height = Math.max(ph - ofy - 150, 200); //height of the app yo		
		me._gridHeight = height;
		if(me.MatrixGrid) me.MatrixGrid.setHeight(height);
	},
	
	_getDistanceFromBottomOfScreen: function(innerY){
		var me = this, w = window, p = w.parent, iframe = me._getIframe(),
			ph = p.getWindowHeight(), 
			ps = p.getScrollY(), 
			ofy = ps + iframe.getBoundingClientRect().top, //offset of top of the iframe
			actualY = ofy + innerY;
		return ph - actualY;
	},
	
	_changeGridWidth: function(){
		var me = this, mg = me.MatrixGrid;
		if(mg) mg.setWidth(Math.min(
			_.reduce(mg.config.columnCfgs, function(item, sum){ return sum + item.width; }, 20), 
			me.getWidth()-40
		));
	},
	
	_applyEventListeners: function(){
		var me=this, p = window.parent;
		
		function screenChanged(){
			me._applyMessageBoxConfig();
			me._changeGridHeight();
			me._changeGridWidth();
		}
		screenChanged();
		p.onresize = screenChanged;
		p.onscroll = screenChanged;
	},
	
	/******************************************************* LAUNCH/UPDATE APP********************************************************/
	_loadAllData: function(cb){
		var me = this;
		me._loadMatrixFeatures(function(){	
			me._loadMatrixUserStoryBreakdown(function(){
				me._addDefaultProjects(function(){ if(cb) cb(); });
			});
		});
	},
	
	launch: function(){
		var me = this;
		me._showError('Loading Data...');
		if(!me.getContext().getPermissions().isProjectEditor(me.getContext().getProject())) { //permission check
			me.removeAll();
			me._showError('You do not have permissions to edit this project');
			return;
		}
		Ext.tip.QuickTipManager.init();
		Ext.apply(Ext.tip.QuickTipManager.getQuickTip(), {showDelay: 1000 });
		me._defineModels();
		me._applyEventListeners();
		setInterval(function(){ me._reloadMatrixStores();}, 10000); 
		me._loadModels(function(){
			var scopeProject = me.getContext().getProject();
			me._loadProject(scopeProject, function(scopeProjectRecord){
				me._projectInWhichTrain(scopeProjectRecord, function(trainRecord){
					if(trainRecord){
						me.TrainRecord = trainRecord; 
						console.log('train loaded:', trainRecord);
						me._loadReleasesInTheFuture(me.TrainRecord).then(function(releaseStore){
							me.ReleaseStore = releaseStore;
							var currentRelease = me._getScopedRelease(me.ReleaseStore.getRange(), me.TrainRecord.data.ObjectID, me.AppPrefs);
							if(currentRelease){
								me.ReleaseRecord = currentRelease;
								console.log('release loaded', currentRelease);
								me._loadAllData(function(){
									me.removeAll();
									me._loadMatrixGrid();
								});
							} else {
								me.removeAll();
								me._showError('This ART has no releases');
							}
						});
					} else{
						me.removeAll();
						me._showError('Please scope to an ART');
					}
				});
			});
		});
	},
	
	/******************************************************* RENDER ********************************************************/
	_clearToolTip: function(){
		var me = this;
		if(me.tooltip){
			me.tooltip.panel.hide();
			me.tooltip.triangle.hide();
			me.tooltip.panel.destroy();
			me.tooltip.triangle.destroy();
			delete me.tooltip;
		}
	},
	
	_loadMatrixGrid: function(){
		var me = this, mode='Details'; //Flag and Details
		
		me.featureTCAECache = {};
		
		function getTeamCommit(featureRecord, ProjectName){	
			var tcs = featureRecord.data.c_TeamCommits;
			var featureID = featureRecord.data.ObjectID;
			var projectID = me.MatrixProjectMap[ProjectName];
			var this_tc;
			try{ 
				var parsed_tcs;
				if(me.featureTCAECache[featureID]) 
					parsed_tcs = me.featureTCAECache[featureID];
				else {
					parsed_tcs = JSON.parse(atob(tcs)) || {};
					me.featureTCAECache[featureID] = parsed_tcs;
				}
				this_tc = parsed_tcs[projectID] || {}; 
			} 
			catch(e){ me.featureTCAECache[featureID] = this_tc = {}; }
			return this_tc;
		}
		
		function setExpected(featureRecord, ProjectName, value){
			var tcs = featureRecord.get('c_TeamCommits');
			var featureID = featureRecord.data.ObjectID;
			var projectID = me.MatrixProjectMap[ProjectName];
			try{ 
				if(me.featureTCAECache[featureID]) 
					tcs = me.featureTCAECache[featureID];
				else {
					tcs = JSON.parse(atob(tcs)) || {};
					me.featureTCAECache[featureID] = tcs;
				}
			} 
			catch(e){ me.featureTCAECache[featureID] = tcs = {}; }
			if(!tcs[projectID]) 
				tcs[projectID] = {};
			tcs[projectID].Expected = value;		
			var str = btoa(JSON.stringify(tcs, null, '\t'));
			if(str.length >= 32768){
				me._alert('ERROR', 'TeamCommits field for ' + featureRecord.get('FormattedID') + ' ran out of space! Cannot save');
				if(cb) cb();
			}
			featureRecord.set('c_TeamCommits', str);
			featureRecord.save();
		}

		var customMatrixRecords = _.map(me.MatrixFeatureStore.getRecords(), function(featureRecord){
			var ed = featureRecord.get('PlannedEndDate');
			return {
				Rank: featureRecord.get('DragAndDropRank'),
				FormattedID: featureRecord.get('FormattedID'),
				ObjectID: featureRecord.get('ObjectID'),
				FeatureName: featureRecord.get('Name'),
				ProductName: me.MatrixProductHash[featureRecord.get('ObjectID')],
				PlannedEndDate: (ed ? 'WW' + me._getWorkweek(new Date(ed)) : '-')
			};
		});		

		me.CustomMatrixStore = Ext.create('Ext.data.Store', {
			data: customMatrixRecords,
			model: 'IntelFeature',
			autoSync:true,
			limit:Infinity,
			proxy: {
				type:'sessionstorage',
				id: 'Session-proxy-' + Math.random()
			}
		});

		var defColumnCfgs = [
			{
				text:'Rank', 
				dataIndex:'Rank',
				width:50,
				editor:false,
				sortable:true,
				resizable:false,
				draggable:false,
				menuDisabled:true,
				locked:true,
				renderer: function(oid, meta, f1){
					var rank = 1;
					var f1OID = f1.data.ObjectID;
					f1 = me.MatrixFeatureStore.findRecord('ObjectID', f1OID);
					var f1DADR = f1.data.DragAndDropRank;
					me.MatrixFeatureStore.getRecords().forEach(function(f2){
						if((f2.get('ObjectID') != f1OID) && (f1DADR > f2.get('DragAndDropRank')))
							++rank;
					});
					return rank;
				}
			},{
				text:'F#', 
				dataIndex:'FormattedID',
				width:50,
				editor:false,
				resizable:false,
				draggable:false,
				menuDisabled:true,
				sortable:true,
				locked:true,
				renderer:function(FID){
					var feature = me.MatrixFeatureStore.findRecord('FormattedID', FID);
					if(feature.get('Project')) {
						var pid = feature.get('Project')._ref.split('/project/')[1];
						return '<a href="https://rally1.rallydev.com/#/' + pid + 'd/detail/portfolioitem/feature/' + 
								feature.get('ObjectID') + '" target="_blank">' + FID + '</a>';
					}
					else return name;
				}
			},{
				text:'Feature', 
				dataIndex:'FeatureName',
				width:250,
				editor:false,
				resizable:false,
				draggable:false,
				menuDisabled:true,
				locked:true,
				sortable:true,
				renderer: function(value, metaData) {
					metaData.tdAttr = 'data-qtip="' + value + '"';
					return value;
				}
			},{
				text:'Product', 
				dataIndex:'ProductName',
				width:60,
				editor:false,
				resizable:false,
				draggable:false,
				menuDisabled:true,
				locked:true,
				sortable:true
			},{
				text:'Planned End',
				dataIndex:'PlannedEndDate',
				width:60,
				editor:false,
				resizable:false,
				draggable:false,
				menuDisabled:true,
				locked:true,
				sortable:true
			}
		];
		var columnCfgs = [].concat(defColumnCfgs);
		Object.keys(me.MatrixUserStoryBreakdown).sort().forEach(function(ProjectName){
			columnCfgs.push({
				text: ProjectName,
				dataIndex:'ObjectID',
				width:50,
				editor:'textfield',
				draggable:false,
				menuDisabled:true,
				align:'center',
				tdCls: 'intel-editor-cell',
				sortable:false,
				resizable:false,
				tooltip:ProjectName,
				tooltipType:'title',
				renderer: function(oid, metaData, matrixRecord, row, col){
					var featureRecord = me.MatrixFeatureStore.findRecord('ObjectID', matrixRecord.get('ObjectID'));
					var array = me.MatrixUserStoryBreakdown[ProjectName][featureRecord.data.Name] || [];
					var count = array.length;
					var tcae = getTeamCommit(featureRecord, ProjectName);
					var Expected = tcae.Expected || false;
					var Commitment = tcae.Commitment || 'Undecided'; 
					if(Commitment === 'Undecided') metaData.tdCls += ' intel-team-commits-WHITE';
					if(Commitment === 'N/A') metaData.tdCls += ' intel-team-commits-GREY';
					if(Commitment === 'Committed') metaData.tdCls += ' intel-team-commits-GREEN';
					if(Commitment === 'Not Committed') metaData.tdCls += ' intel-team-commits-RED';
					if(Expected) metaData.tdCls += '-YELLOW';
					return count;
				}
			});
		});
		
		me.MatrixReleasePicker = me.add({
			xtype:'combobox',
			x:0, y:0,
			store: Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(me.ReleaseStore.getRecords(), function(r){ return {Name: r.get('Name') }; })
			}),
			displayField: 'Name',
			fieldLabel: 'Release:',
			editable:false,
			value:me.ReleaseRecord.get('Name'),
			listeners: {
				select: function(combo, records){
					if(me.ReleaseRecord.get('Name') === records[0].get('Name')) return;
					me.ReleaseRecord = me.ReleaseStore.findRecord('Name', records[0].get('Name'));	
					me._clearToolTip();
					me.setLoading(true);					
					setTimeout(function(){
						me._loadAllData(function(){
							me.removeAll();
							me._loadMatrixGrid();
							me.setLoading(false);		
						});
					}, 0);
				}
			}
		});
		
		me.MatrixProductPicker = me.add({
			xtype:'combobox',
			x:0, y:30,
			fieldLabel:'Product Filter',
			store: Ext.create('Ext.data.Store', {
				fields:['ProductName'],
				data: _.map(_.reduce(Object.keys(me.MatrixProductHash), function(items, ObjectID){
					var projectName = me.MatrixProductHash[ObjectID];
					if(items.indexOf(projectName) == -1) items.push(projectName);
					return items;
				}, ['All Products']), function(name){ return {ProductName: name}; })
			}),
			displayField: 'ProductName',
			editable:false,
			value:'All Products',
			listeners: {
				select: function(combo, records){
					var value = records[0].get('ProductName');
					me.CustomMatrixStore.filters.getRange().forEach(function(filter){
						me.CustomMatrixStore.removeFilter(filter);
					});
					if(value !== 'All Products'){
						me.CustomMatrixStore.addFilter(new Ext.util.Filter({
							filterFn: function(matrixRecord){
								return matrixRecord.get('ProductName') === value;
							}
						}));
					}
					me._clearToolTip();
				}
			}
		});
		
		me.ModePicker = me.add({
			xtype:'combobox',
			x:0, y:60,
			fieldLabel:'Click Mode',
			store: Ext.create('Ext.data.Store', {
				fields:['Mode'],
				data: [
					{'Mode':'Flag'},
					{'Mode':'Details'}
				]
			}),
			displayField: 'Mode',
			editable:false,
			value:mode,
			listeners: {
				select: function(combo, records){
					var value = records[0].get('Mode');
					if(value === mode) return;
					else mode = value;
					me._clearToolTip();
				}
			}
		});
		
		me.MatrixLegend = me.add({
			xtype:'container',
			layout:'table',
			columns:5,
			width:600, x:300, y:0,
			border:true,
			frame:false,
			items: _.map(['Committed', 'Not Committed', 'N/A', 'Undefined', 'Expected'], function(name){
				var color;
				if(name === 'Undecided') color='white';
				if(name === 'N/A') color='rgba(224, 224, 224, 0.50)'; //grey
				if(name === 'Committed') color='rgba(0, 255, 0, 0.50)';//grenn
				if(name === 'Not Committed') color='rgba(255, 0, 0, 0.50)';//red
				if(name === 'Expected') color='rgba(251, 255, 0, 0.50)'; //yellow
				return {
					xtype: 'container',
					width:120,
					border:false,
					frame:false,
					html:'<div class="intel-legend-item">' + name + 
						': <div style="background-color:' + color + '" class="intel-legend-dot"></div></div>'
				};
			})
		});
		
		me.MatrixGrid = me.add({
			xtype: 'grid',
			x:0, y:100,
			width: Math.min(_.reduce(columnCfgs, function(item, sum){ return sum + item.width; }, 20), me.getWidth()-40),
			height:me._gridHeight,
			scroll:'both',
			resizable:false,
			columns: columnCfgs,
			plugins: [
				Ext.create('Ext.grid.plugin.CellEditing', {
					triggerEvent:'cellclick'
				})
			],
			viewConfig: {
				preserveScrollOnRefresh: true
			},
			listeners: {
				sortchange: function(){
					me._clearToolTip();
				},
				beforeedit: function(editor, e){
					var ProjectName = e.column.text,
						matrixRecord = e.record;
					if(mode === 'Flag'){
						var featureRecord = me.MatrixFeatureStore.findRecord('ObjectID', matrixRecord.get('ObjectID'));
						var tcae = getTeamCommit(featureRecord, ProjectName);
						setExpected(featureRecord, ProjectName, !tcae.Expected);
						matrixRecord.commit(); //just so it rerenders this record 
					}
					return false;
				}, 
				afterrender: function (grid) {
					var view = grid.view.normalView;	//lockedView and normalView		
					
					view.getEl().on('scroll', function(){ if(!me._isReloadRefresh) me._clearToolTip(); });
					
					// record the current cellIndex for tooltip stuff
					grid.mon(view, {
						uievent: function (type, view, cell, row, col, e) {
							if(mode === 'Details' && type === 'mousedown') {
								var matrixRecord = me.CustomMatrixStore.getAt(row);
								var ProjectName = view.getGridColumns()[col].text;
								var featureRecord = me.MatrixFeatureStore.findRecord('ObjectID', matrixRecord.get('ObjectID'));
								var tcae = getTeamCommit(featureRecord, ProjectName);
								var pos = cell.getBoundingClientRect();
								if(me.tooltip){
									me.tooltip.panel.hide();
									me.tooltip.triangle.hide();
									me.tooltip.panel.destroy();
									me.tooltip.triangle.destroy();
									if(me.tooltip.row == row && me.tooltip.col == col) {
										delete me.tooltip;
										return;
									}
								}
								
								//if(col <= 3) return; //this applied to non-locked grid
								var panelWidth = 400;
								var theHTML = 
											//'<p><b>Team: </b>' + ProjectName + 
											//'<p><b>Feature: </b>' + featureRecord.get('FormattedID') + 
											'<p><b>' + (tcae.Commitment == 'Committed' ? 'Objective: ' : 'Comment: ') + '</b>' + (tcae.Objective || '') +
											'<p><b>PlanEstimate: </b>' + 
											_.reduce(me.MatrixUserStoryBreakdown[ProjectName][featureRecord.data.Name] || [], function(sum, sr){
												return sum + (sr.get('PlanEstimate') || 0); }, 0) +
											'<p><b>UserStories: </b><div style="max-height:200px;overflow-y:auto;"><ol>';
								(me.MatrixUserStoryBreakdown[ProjectName][featureRecord.data.Name] || []).forEach(function(sr){
									theHTML += '<li><a href="https://rally1.rallydev.com/#/' + sr.data.Project.ObjectID + 
										'd/detail/userstory/' + sr.get('ObjectID') + '" target="_blank">' + sr.get('FormattedID') + '</a>: ' + 
										sr.get('Name').substring(0, 40) + (sr.get('Name').length>40 ? '...' : '') + '</li>';
								});
								theHTML += '</ol></div>';
								
								var dbs = me._getDistanceFromBottomOfScreen(pos.top);
								
								me.tooltip = {
									row:row,
									col:col,
									panel: Ext.widget('container', {
										floating:true,
										width: panelWidth,
										autoScroll:false,
										id:'MatrixTooltipPanel',
										cls: 'intel-tooltip',
										focusOnToFront:false,
										shadow:false,
										renderTo:Ext.getBody(),
										html:theHTML,
										listeners:{
											afterrender: function(panel){
												var upsideDown = (dbs < panel.getHeight() + 40);
												panel.setPosition(pos.left-panelWidth, (upsideDown ? pos.bottom - panel.getHeight() : pos.top));
											}
										}
									}),
									triangle: Ext.widget('container', {
										floating:true,
										width:0, height:0,
										focusOnToFront:false,
										shadow:false,
										renderTo:Ext.getBody(),
										listeners:{
											afterrender: function(panel){
												setTimeout(function(){
													var upsideDown = (dbs < Ext.get('MatrixTooltipPanel').getHeight() + 40);
													if(upsideDown) {
														panel.removeCls('intel-tooltip-triangle');
														panel.addCls('intel-tooltip-triangle-up');
														panel.setPosition(pos.left -10, pos.bottom -10);
													} else {
														panel.removeCls('intel-tooltip-triangle-up');
														panel.addCls('intel-tooltip-triangle');
														panel.setPosition(pos.left -10, pos.top);
													}
												}, 10);
											}
										}
									})	
								};
							}
						}
					});
				}
			},
			enableEditing:false,
			store: me.CustomMatrixStore
		});	
	}
});

            Rally.launchApp('CommitMatrix', {
                name:"ART Commit Matrix",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .x-grid-row .intel-editor-cell {
  cursor: pointer !important;
}
.x-grid-row .intel-editor-cell * {
  cursor: pointer !important;
}
.x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-RED,
.x-grid-row-over .x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREEN,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(224, 224, 224, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREY,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(224, 224, 224, 0.7) !important;
}
.x-grid-cell.intel-team-commits-WHITE-YELLOW {
  background-image: -webkit-gradient(linear, right top, left bottom, color-stop(0.5, rgba(251, 255, 0, 0.5)), color-stop(0.5, rgba(0, 0, 0, 0))) !important;
  background-image: -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
}
.x-grid-cell.intel-team-commits-RED-YELLOW {
  background-image: -webkit-gradient(linear, right top, left bottom, color-stop(0.5, rgba(251, 255, 0, 0.5)), color-stop(0.5, rgba(255, 0, 0, 0.5))) !important;
  background-image: -o-linear-gradient(right top, rgba(255, 0, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(255, 0, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(255, 0, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(255, 0, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: linear-gradient(to right top, rgba(255, 0, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
}
.x-grid-cell.intel-team-commits-GREEN-YELLOW {
  background-image: -webkit-gradient(linear, right top, left bottom, color-stop(0.5, rgba(251, 255, 0, 0.5)), color-stop(0.5, rgba(0, 255, 0, 0.5))) !important;
  background-image: -o-linear-gradient(right top, rgba(0, 255, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 255, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 255, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 255, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 255, 0, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
}
.x-grid-cell.intel-team-commits-GREY-YELLOW {
  background-image: -webkit-gradient(linear, right top, left bottom, color-stop(0.5, rgba(251, 255, 0, 0.5)), color-stop(0.5, rgba(224, 224, 224, 0.5))) !important;
  background-image: -o-linear-gradient(right top, rgba(224, 224, 224, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(224, 224, 224, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(224, 224, 224, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(224, 224, 224, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
  background-image: linear-gradient(to right top, rgba(224, 224, 224, 0.5) 75%, rgba(251, 255, 0, 0.5) 75%) !important;
}
.intel-legend-dot {
  width: 12px;
  height: 12px;
  border-radius: 6px;
  border: 1px solid black;
  display: inline-block;
  vertical-align: middle;
}
.intel-legend-item {
  font-size: 1em;
  text-align: center;
}
.intel-tooltip {
  padding: 10px;
  background-color: #C0D9FA;
  border-radius: 8px;
  z-index: 500;
}
.intel-tooltip-triangle {
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 10px solid #C0D9FA;
  height: 0px;
  width: 0px;
  z-index: 500;
}
.intel-tooltip-triangle-up {
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 10px solid #C0D9FA;
  height: 0px;
  width: 0px;
  z-index: 500;
}
/**************************************** GRID HEADERS STUFF *******************************/
.x-column-header-inner .x-column-header-text {
  white-space: normal !important;
  line-height: 15px;
}
.x-column-header-inner {
  text-align: center;
  height: 100 !important;
}

    </style>
</head>
<body>
</body>
</html>
