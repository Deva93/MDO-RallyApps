<!DOCTYPE html>
<html>
<head>
    <title>Random App Name70221</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /*!
 * CTemplate
 * Version 1.1
 * Copyright(c) 2011-2013 Skirtle's Den
 * License: http://skirtlesden.com/ux/ctemplate
 */
Ext.define('Skirtle.CTemplate', {
    extend: 'Ext.XTemplate',

    statics: {
        AUTO_ID: 0
    },

    // May need to be increased if components are included deeper in the data object
    copyDepth: 10,

    // Placeholder element template. Should be changed in tandem with getPlaceholderEl()
    cTpl: '<p id="ctemplate-{0}-{1}"></p>',

    // Flag
    isCTemplate: true,

    constructor: function() {
        var me = this;

        me.callParent(arguments);

        me.id = ++me.statics().AUTO_ID;

        me.reset();
    },

    /* Takes a recursive copy of the values provided, switching out components for placeholder values. The component ids
     * are recorded and injectComponents() uses the ids to find the placeholder elements in the DOM and switch in the
     * components.
     */
    copyValues: function(values, depth) {
        var me = this,
            id,
            copy = {},
            copyDepth = depth || me.copyDepth;

        if (copyDepth === 1) {
            return values;
        }

        if (Ext.isArray(values)) {
            return Ext.Array.map(values, function(value) {
                return me.copyValues(value, copyDepth - 1);
            });
        }

        if (!Ext.isObject(values)) {
            return values;
        }

        // This is the key sleight-of-hand that makes the whole thing work
        if (values.isComponent) {
            id = values.getId();
            me.ids.push(id);
            return Ext.String.format(me.cTpl, id, me.id);
        }

        Ext.Object.each(values, function(key, value) {
            // $comp is a special value for a renderTpl that references the current component
            copy[key] = key === '$comp' ? value : me.copyValues(value, copyDepth - 1);
        });

        return copy;
    },

    // Override
    doInsert: function() {
        var ret = this.callParent(arguments);

        // There's no guarantee this will succeed so we still need polling as well
        this.injectComponents();

        return ret;
    },

    /* We have to resort to polling for component injection as we don't have full control over when the generated HTML
     * will be added to the DOM
     */
    doPolling: function(interval) {
        var me = this;

        me.pollInterval = interval;

        if (me.pollId) {
            clearTimeout(me.pollId);
        }

        me.pollId = Ext.defer(me.injectComponents, interval, me);
    },

    getPlaceholderEl: function(id) {
        return Ext.get('ctemplate-' + id + '-' + this.id);
    },

    /* Attempts to substitute all placeholder elements with the real components. If a component is successfully injected
     * or it has been destroyed then it won't be attempted again. This method is repeatedly invoked by a polling
     * mechanism until no components remain, however relying on the polling is not advised. Instead it is preferable to
     * call this method directly as soon as the generated HTML is inserted into the DOM.
     */
    injectComponents: function() {
        var me = this,
            ids = me.ids,
            index = ids.length - 1,
            id,
            cmp,
            placeholderEl;

        // Iterate backwards because we remove some elements in the loop
        for ( ; index >= 0 ; --index) {
            id = ids[index];
            cmp = Ext.getCmp(id);
            placeholderEl = me.getPlaceholderEl(id);

            if (me.renderComponent(cmp, placeholderEl) || !cmp) {
                // Either we've successfully done the switch or the component has been destroyed
                Ext.Array.splice(ids, index, 1);

                if (placeholderEl) {
                    placeholderEl.remove();
                }
            }
        }

        if (ids.length) {
            // Some components have not been injected. Polling acts both to do deferred injection and as a form of GC
            me.doPolling(me.pollInterval * 1.5);
        }
    },

    // Override
    overwrite: function(el) {
        var dom,
            firstChild,
            ret;

        /* In IE setting the innerHTML will destroy the nodes for the previous content. If we try to reuse components it
         * will fail as their DOM nodes will have been torn apart. We can't defend against external updates to the DOM
         * but we can guard against the case where all updates come through this template.
         */
        if (Ext.isIE) {
            dom = Ext.getDom(el);
            while (dom.firstChild) {
                dom.removeChild(dom.firstChild);
            }
        }

        ret = this.callParent(arguments);

        // There's no guarantee this will succeed so we still need polling as well
        this.injectComponents();

        return ret;
    },

    renderComponent: function(cmp, placeholderEl) {
        if (cmp && placeholderEl) {
            var parent = placeholderEl.parent();

            if (cmp.rendered) {
                // Move a component that has been rendered previously
                cmp.getEl().replace(placeholderEl);
            }
            else {
                cmp.render(parent, placeholderEl);
            }

            if (Ext.isIE6) {
                // Some components (mostly form fields) reserve space but fail to show up without a repaint in IE6
                parent.repaint();
            }

            return true;
        }

        return false;
    },

    reset: function() {
        var me = this;

        // The ids of injected components that haven't yet been rendered
        me.ids = [];

        if (me.pollId) {
            clearTimeout(me.pollId);
            me.pollId = null;
        }
    }
}, function(ctemplate) {
    var apply = function() {
        var me = this,
            args = Ext.Array.slice(arguments);

        args[0] = me.copyValues(args[0]);

        // As we're returning an HTML string/array we can't actually complete the injection here
        me.doPolling(10);

        return me.callParent(args);
    };

    // The main override is different depending on whether we're using ExtJS 4.0 or 4.1+
    if (ctemplate.prototype.applyOut) {
        // 4.1+
        ctemplate.override({
            applyOut: apply
        });
    }
    else {
        // 4.0
        ctemplate.override({
            applyTemplate: apply
        });

        ctemplate.createAlias('apply', 'applyTemplate');
    }
});

/*!
 * Component Column
 * Version 1.1
 * Copyright(c) 2011-2013 Skirtle's Den
 * License: http://skirtlesden.com/ux/component-column
 */
Ext.define('Skirtle.grid.column.Component', {
    alias: 'widget.componentcolumn',
    extend: 'Ext.grid.column.Column',
    requires: ['Skirtle.CTemplate'],

    // Whether or not to automatically resize the components when the column resizes
    autoWidthComponents: true,

    // Whether or not to destroy components when they are removed from the DOM
    componentGC: true,

    // Override the superclass - this must always be true or odd things happen, especially in IE
    hasCustomRenderer: true,

    // The estimated size of the cell frame. This is updated once there is a cell where it can be measured
    lastFrameWidth: 12,

    /* Defer durations for updating the component width when a column resizes. Required when a component has an animated
     * resize that causes the scrollbar to appear/disappear. Otherwise the animated component can end up the wrong size.
     *
     * For ExtJS 4.0 both delays are required. For 4.1 just having the 10ms delay seems to be sufficient.
     */
    widthUpdateDelay: [10, 400],

    constructor: function(cfg) {
        var me = this;

        me.callParent(arguments);

        // Array of component ids for both component queries and GC
        me.compIds = [];

        // We need a dataIndex, even if it doesn't correspond to a real field
        me.dataIndex = me.dataIndex || Ext.id(null, 'cc-dataIndex-');

        me.tpl = me.createTemplate(me.tpl);
        me.renderer = me.createRenderer(me.renderer);

        me.registerColumnListeners();
    },

    addRefOwner: function(child) {
        var me = this,
            fn = me.refOwnerFn || (me.refOwnerFn = function() {
                return me;
            });

        if (me.extVersion < 40200) {
            // Component queries for ancestors use getBubbleTarget in 4.1 ...
            child.getBubbleTarget = fn;
        }
        else {
            // ... and getRefOwner in 4.2+
            child.getRefOwner = fn;
        }
    },

    applyTemplate: function(data, value) {
        if (Ext.isDefined(value)) {
            data[this.dataIndex] = value;
        }

        return this.tpl.apply(data);
    },

    /* In IE setting the innerHTML will destroy the nodes for the previous content. If we try to reuse components it
     * will fail as their DOM nodes will have been torn apart. To defend against this we must remove the components
     * from the DOM just before the grid view is refreshed.
     */
    beforeViewRefresh: function() {
        if (Ext.isIE) {
            var ids = this.compIds,
                index = 0,
                len = ids.length,
                item,
                el,
                parentEl;

            for ( ; index < len ; index++) {
                if ((item = Ext.getCmp(ids[index])) && (el = item.getEl()) && (el = el.dom) && (parentEl = el.parentNode)) {
                    parentEl.removeChild(el);
                }
            }
        }
    },

    calculateFrameWidth: function(component) {
        var el = component.getEl(),
            parentDiv = el && el.parent(),
            // By default the TD has no padding but it is quite common to add some via a tdCls
            parentTd = parentDiv && parentDiv.parent();

        if (parentTd) {
            // Cache the frame width so that it can be used as a 'best guess' in cases where we don't have the elements
            return this.lastFrameWidth = parentDiv.getFrameWidth('lr') + parentTd.getFrameWidth('lr');
        }
    },

    createRenderer: function(renderer) {
        var me = this;

        return function(value, p, record) {
            var data = Ext.apply({}, record.data, record.getAssociatedData());

            if (renderer) {
                // Scope must be this, not me
                value = renderer.apply(this, arguments);
            }

            // Process the value even with no renderer defined as the record may contain a component config
            value = me.processValue(value);

            return me.applyTemplate(data, value);
        };
    },

    createTemplate: function(tpl) {
        return tpl && tpl.isTemplate ? tpl : Ext.create('Skirtle.CTemplate', tpl || ['{', this.dataIndex ,'}']);
    },

    destroyChild: function(child) {
        child.destroy();
    },

    getRefItems: function(deep) {
        var items = this.callParent([deep]),
            ids = this.compIds,
            index = 0,
            len = ids.length,
            item;

        for ( ; index < len ; index++) {
			item = Ext.getCmp(ids[index]);
            if (item) {
                items.push(item);

                if (deep && item.getRefItems) {
                    items.push.apply(items, item.getRefItems(true));
                }
            }
        }

        return items;
    },

    onChildAfterRender: function(child) {
        this.resizeChild(child);
    },

    onChildBoxReady: function(child) {
        // Pass false to avoid triggering deferred resize, the afterrender listener will already cover those cases
        this.resizeChild(child, false);
    },

    onChildDestroy: function(child) {
        Ext.Array.remove(this.compIds, child.getId());
    },

    onChildResize: function() {
        this.redoScrollbars();
    },

    onColumnResize: function(column) {
        column.resizeAll();
    },

    onColumnShow: function(column) {
        column.resizeAll();
    },

    // This is called in IE 6/7 as the components can still be seen even when a column is hidden
    onColumnVisibilityChange: function(column) {
        var items = column.getRefItems(),
            index = 0,
            length = items.length,
            visible = !column.isHidden();

        // In practice this probably won't help but it shouldn't hurt either
        if(Ext.suspendLayouts) Ext.suspendLayouts();

        for ( ; index < length ; ++index) {
            items[index].setVisible(visible);
        }

       if(Ext.resumeLayouts) Ext.resumeLayouts(true);
    },

    onDestroy: function() {
        Ext.destroy(this.getRefItems());

        this.callParent();
    },

    // Override
    onRender: function() {
        this.registerViewListeners();
        this.callParent(arguments);
    },

    // View has changed, may be a full refresh or just a single row
    onViewChange: function() {
        var me = this,
            tpl = me.tpl;

        // Batch the resizing of child components until after they've all been injected
        me.suspendResizing();

        if (tpl.isCTemplate) {
            // No need to wait for the polling, the sooner we inject the less painful it is
            tpl.injectComponents();

            // If the template picked up other components in the data we can just ignore them, they're not for us
            tpl.reset();
        }

        // A view change could mean scrollbar problems. Note this won't actually do anything till we call resumeResizing
        me.redoScrollbars();

        me.resumeResizing();
        
        me.performGC();
    },

    // Component GC, try to stop components leaking
    performGC: function() {
        var compIds = this.compIds,
            index = compIds.length - 1,
            comp,
            el;

        for ( ; index >= 0 ; --index) {
            // Could just assume that the component id is the el id but that seems risky
            comp = Ext.getCmp(compIds[index]);
            el = comp && comp.getEl();

            if (!el || (this.componentGC && (!el.dom || Ext.getDom(Ext.id(el)) !== el.dom))) {
                // The component is no longer in the DOM
                if (comp && !comp.isDestroyed) {
                    comp.destroy();
                }
            }
        }
    },

    processValue: function(value) {
        var me = this,
            compIds = me.compIds,
            id, initialWidth, dom, parent;

        if (Ext.isObject(value) && !value.isComponent && value.xtype) {
            // Do not default to a panel, not only would it be an odd default but it makes future enhancements trickier
            value = Ext.widget(value.xtype, value);
        }

        if (value && value.isComponent) {
            id = value.getId();

            // When the view is refreshed the renderer could return a component that's already in the list
            if (!Ext.Array.contains(compIds, id)) {
                compIds.push(id);
            }

            me.addRefOwner(value);
            me.registerListeners(value);

            if (value.rendered) {
                /* This is only necessary in IE because it is just another manifestation of the innerHTML problems.
                 * The problem occurs when a record value is changed and the components in that same row are being
                 * reused. The view doesn't go through a full refresh, instead it performs a quick update on just the
                 * one row. Unfortunately this nukes the existing components so we need to remove them first.
                 */
                if (Ext.isIE) {
                    // TODO: Should this be promoted to CTemplate?
                    dom = value.el.dom;
                    parent = dom.parentNode;

                    if (parent) {
                        if (me.extVersion === 40101) {
                            // Workaround for the bugs in Element.syncContent - p tag matches CTemplate.cTpl
                            Ext.core.DomHelper.insertBefore(dom, {tag: 'p'});
                        }

                        // TODO: Removing the element like this could fall foul of Element GC
                        parent.removeChild(dom);
                    }
                }
            }
            else if (me.autoWidthComponents) {
                /* Set the width to a 'best guess' before the component is rendered to ensure that the component's
                 * layout is using a configured width and not natural width. This avoids problems with 4.1.1 where
                 * subsequent calls to setWidth are ignored because it believes the width is already correct but only
                 * the outermost element is actually sized correctly. We could use an arbitrary width but instead we
                 * make a reasonable guess at what the actual width will be to try to avoid extra resizing.
                 */
                initialWidth = me.getWidth() - me.lastFrameWidth;

                // Impose a minimum width of 4, we really don't want negatives values or NaN slipping through
                initialWidth = initialWidth > 4 ? initialWidth : 4;

                value.setWidth(initialWidth);
            }

            // Part of the same IE 6/7 hack as onColumnVisibilityChange
            if ((Ext.isIE6 || Ext.isIE7) && me.isHidden()) {
                value.hide();
            }
        }

        return value;
    },

    redoScrollbars: function() {
        var me = this,
            grid = me.up('tablepanel');

        if (grid) {
            // The presence of a resizeQueue signifies that we are currently suspended
            if (me.resizeQueue) {
                me.redoScrollbarsRequired = true;
                return;
            }

            // After components are injected the need for a grid scrollbar may need redetermining
            if (me.extVersion < 40100) {
                // 4.0
                grid.invalidateScroller();
                grid.determineScrollbars();
            }
            else {
                // 4.1+
                grid.doLayout();
            }
        }
    },

    registerColumnListeners: function() {
        var me = this;

        if (me.autoWidthComponents) {
            // Need to resize children when the column resizes
            me.on('resize', me.onColumnResize);

            // Need to resize children when the column is shown as they can't be resized correctly while it is hidden
            me.on('show', me.onColumnShow);
        }

        if (Ext.isIE6 || Ext.isIE7) {
            me.on({
                hide: me.onColumnVisibilityChange,
                show: me.onColumnVisibilityChange
            });
        }
    },

    registerListeners: function(component) {
        var me = this;

        // Remove the component from the child list when it is destroyed
        component.on('destroy', me.onChildDestroy, me);

        if (me.autoWidthComponents) {
            // Need to resize children after render as some components (e.g. comboboxes) get it wrong otherwise
            component.on('afterrender', me.onChildAfterRender, me, {single: true});

            // With 4.1 boxready gives more reliable results than afterrender as it occurs after the initial sizing
            if (me.extVersion >= 40100) {
                component.on('boxready', me.onChildBoxReady, me, {single: true});
            }
        }

        // Need to redo scrollbars when a child resizes
        component.on('resize', me.onChildResize, me);
    },

    registerViewListeners: function() {
        var me = this,
            view = me.up('tablepanel').getView();

        me.mon(view, 'beforerefresh', me.beforeViewRefresh, me);
        me.mon(view, 'refresh', me.onViewChange, me);
        me.mon(view, 'itemupdate', me.onViewChange, me);
        me.mon(view, 'itemadd', me.onViewChange, me);
        me.mon(view, 'itemremove', me.onViewChange, me);
    },

    resizeAll: function() {
        var me = this;

        me.suspendResizing();
        me.resizeQueue = me.getRefItems();
        me.resumeResizing();
    },

    resizeChild: function(component, defer) {
        var me = this,
            frameWidth,
            newWidth,
            oldWidth,
            resizeQueue;

        if (me.resizingSuspended) {
            resizeQueue = me.resizeQueue;

            if (!Ext.Array.contains(resizeQueue, component)) {
                resizeQueue.push(component);
            }

            return;
        }

        frameWidth = me.calculateFrameWidth(component);

        // TODO: Should we destroy the component here if it doesn't have a parent element? Already picked up anyway?
        if (Ext.isNumber(frameWidth)) {
            newWidth = me.getWidth() - frameWidth;
            oldWidth = component.getWidth();

            // Returns true if a resize actually happened
            if (me.setChildWidth(component, newWidth, oldWidth)) {
                // Avoid an infinite resizing loop, deferring will only happen once
                if (defer !== false) {
                    // Do the sizing again after a delay. This is because child panel collapse animations undo our sizing
                    Ext.each(me.widthUpdateDelay, function(delay) {
                        Ext.defer(me.resizeChild, delay, me, [component, false]);
                    });
                }
            }
        }
    },

    resumeResizing: function() {
        var me = this,
            index = 0,
            resizeQueue = me.resizeQueue,
            len = resizeQueue.length;

        if (!--me.resizingSuspended) {
            for ( ; index < len ; ++index) {
                me.resizeChild(resizeQueue[index]);
            }

            me.resizeQueue = null;

            if (me.redoScrollbarsRequired) {
                me.redoScrollbars();
            }
        }
    },

    setChildWidth: function(component, newWidth, oldWidth) {
        if (oldWidth === newWidth) {
            return false;
        }

        component.setWidth(newWidth);

        return true;
    },

    suspendResizing: function() {
        var me = this;

        me.resizingSuspended = (me.resizingSuspended || 0) + 1;

        if (!me.resizeQueue) {
            me.resizeQueue = [];
        }
    }
}, function(cls) {
    var proto = cls.prototype,
        version = Ext.getVersion();

    // ExtJS version detection
    proto.extVersion = (version.getMajor() * 100 + version.getMinor()) * 100 + version.getPatch();

    // 4.1.1 initially reported its version as 4.1.0
    if (Ext.Element.prototype.syncContent && version.toString() === '4.1.0') {
        proto.extVersion = 40101;
    }
});

Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
	height:2000,

	/****************************************************** DATA STORE METHODS ********************************************************/
	
	_loadTeamCommitsFeatures: function(cb){ 
		var me = this;
		Ext.create('Rally.data.wsapi.Store',{
			model: 'PortfolioItem/Feature',
			autoLoad:true,
			limit:Infinity,
			fetch: ['Name', 'FormattedID', 'c_TeamCommits'],
			context:{
				workspace: me.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'c_TeamCommits',
					operator:'!=',
					value:''
				}
			],
			listeners: {
				load: {
					fn: function(featureStore){
						me.TeamCommitsFeatureStore = featureStore;
						me.TeamCommitsFeatureStore.filterBy(function(item){
							return !!item.get('c_TeamCommits');
						});
						cb();
					},
					single:true
				}
			}
		});
	},
	
	_loadRisksFeatures: function(cb){ 
		var me = this;
		Ext.create('Rally.data.wsapi.Store',{
			model: 'PortfolioItem/Feature',
			autoLoad:true,
			limit:Infinity,
			fetch: ['Name', 'FormattedID', 'c_Risks'],
			context:{
				workspace: me.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'c_Risks',
					operator:'!=',
					value:''
				}
			],
			listeners: {
				load: {
					fn: function(featureStore){
						me.RisksFeatureStore = featureStore;
						me.RisksFeatureStore.filterBy(function(item){
							return !!item.get('c_Risks');
						});
						cb();
					},
					single:true
				}
			}
		});
	},
			
	_loadDependenciesUserStories: function(cb){ 
		var me = this;
		Ext.create('Rally.data.wsapi.Store',{
			model: 'HierarchicalRequirement',
			autoLoad:true,
			limit:Infinity,
			fetch: ['Name', 'FormattedID', 'c_Dependencies'],
			context:{
				workspace: me.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'c_Dependencies',
					operator:'!=',
					value:''
				}
			],
			listeners: {
				load: {
					fn: function(userStoryStore){
						me.DependenciesUserStoryStore = userStoryStore;
						me.DependenciesUserStoryStore.filterBy(function(item){
							return !!item.get('c_Dependencies');
						});
						cb();
					},
					single:true
				}
			}
		});
	},
	
	
	/******************************************************* DEFINE MEMORY MODELS ********************************************************/
	_defineModels: function(){
		Ext.define('RisksModel', {
			extend: 'Ext.data.Model',
			fields: [
				{name: 'FormattedID', type:'string'},
				{name: 'Name', type:'string'},
				{name: 'Risks',  type: 'string'}
			]
		});
		
		Ext.define('TeamCommitsModel', {
			extend: 'Ext.data.Model',
			fields: [
				{name: 'FormattedID', type:'string'},
				{name: 'Name', type:'string'},
				{name: 'TeamCommits',  type: 'string'}
			]
		});
	
		Ext.define('DependenciesModel', {
			extend: 'Ext.data.Model',
			fields: [
				{name: 'FormattedID', type:'string'},
				{name: 'Name', type:'string'},
				{name: 'Dependencies',  type: 'string'}
			]
		});
	},
	
	/******************************************************* LAUNCH ********************************************************/

    launch: function(){
		var me = this;
		me._defineModels();
		me._loadTeamCommitsFeatures(function(){ 
			setInterval(function(){ 
				me.TeamCommitsFeatureStore.load({
					callback: function(records, operation){
						if(me.TeamCommitsStore) me.TeamCommitsStore.load();
					}
				});
			}, 20000); 
			me._loadTeamCommitsGrid();
		});
		me._loadRisksFeatures(function(){
			setInterval(function(){ 
				me.RisksFeatureStore.load({
					callback: function(records, operation){
						if(me.RisksStore) me.RisksStore.load();
					}
				});
			}, 20000); 
			me._loadRisksGrid();
		});
		me._loadDependenciesUserStories(function(){
			setInterval(function(){ 
				me.DependenciesUserStoryStore.load({
					callback: function(records, operation){		
						if(me.DependenciesStore) me.DependenciesStore.load();
					}
				});
			}, 20000); 
			me._loadDependenciesGrid();
		});
	},

	/******************************************************* RENDER ********************************************************/
	_loadTeamCommitsGrid: function(){
		var me = this;	

		var teamCommitsRecords = _.map(me.TeamCommitsFeatureStore.getRecords(), function(featureRecord){
			return Ext.create('TeamCommitsModel', {
				FormattedID: featureRecord.get('FormattedID'),
				Name: featureRecord.get('Name'),
				TeamCommits: featureRecord.get('c_TeamCommits')
			});
		});
		
		me.TeamCommitsStore = Ext.create('Rally.data.custom.Store', {
			data: teamCommitsRecords,
			model: 'TeamCommitsModel',
			proxy: {
				type:'sessionstorage',
				keyField:'teamcommits' + Math.random()
			},
			listeners:{ 
				load: function(customStore, customRecords){
					console.log('syncing custom teamCommits with features');
					var i, unaccountedFor = customRecords.slice(0);
					me.TeamCommitsFeatureStore.getRecords().forEach(function(featureRecord){
						var c_TeamCommits = featureRecord.get('c_TeamCommits');
						var teamCommitsRecord = customStore.findRecord('FormattedID', featureRecord.get('FormattedID'));
						if(!teamCommitsRecord && c_TeamCommits){
							customStore.add(Ext.create('TeamCommitsModel',  {
								FormattedID: featureRecord.get('FormattedID'),
								Name: featureRecord.get('Name'),
								TeamCommits: c_TeamCommits
							}));
						} else if(teamCommitsRecord && !c_TeamCommits){
							customStore.remove(teamCommitsRecord);
							for(i = 0;i<unaccountedFor.length;++i){
								if(unaccountedFor[i].get('FormattedID') === teamCommitsRecord.get('FormattedID')){
									unaccountedFor.splice(i, 1);
									return;
								}
							}
						} else if(!teamCommitsRecord && !c_TeamCommits){
							return; //just got deleted
						} else {
							if(teamCommitsRecord.get('TeamCommits') !== c_TeamCommits) {
								teamCommitsRecord.set('TeamCommits', c_TeamCommits);
							}
							for(i = 0;i<unaccountedFor.length;++i){
								if(unaccountedFor[i].get('FormattedID') === teamCommitsRecord.get('FormattedID')){
									unaccountedFor.splice(i, 1);
									return;
								}
							}
						}
					});
					unaccountedFor.forEach(function(teamCommitsRecord){
						customStore.remove(teamCommitsRecord);
					});
				}
			}
		});
		
		me.TeamCommitsGrid = me.add({
			xtype: 'rallygrid',
			title:'Team Commits',
			width: 920,
			height:500,
			style:'margin-bottom:10px',
			scroll:'vertical',
			columnCfgs: [
				{
					text:'ID', 
					dataIndex:'FormattedID',
					width:50,
					editor:false
				},{
					text:'Feature', 
					dataIndex:'Name',
					width:150,
					editor:false
				},{
					dataIndex:'TeamCommits',
					width:50,
					text:'Length',
					editor:false,
					renderer: function(json){
						return json.length;
					}
				},{
					dataIndex:'TeamCommits',
					width:570,
					text:'Data',
					editor:false,
					renderer: function(json){
						return '<pre>' + json + '</pre>';
					}
				},{
					text:'',
					dataIndex:'FormattedID',
					width:80,
					xtype:'componentcolumn',
					renderer: function(fid){
						return {
							xtype:'button',
							width:70,
							text:'Delete',
							handler: function(){
								var featureRecord = me.TeamCommitsFeatureStore.findRecord('FormattedID', fid);
								if(featureRecord){
									console.log('deleting featureRecord teamCommits:', featureRecord);
									featureRecord.set('c_TeamCommits', '');
									featureRecord.save();
								}
								me.TeamCommitsStore.remove(me.TeamCommitsStore.findRecord('FormattedID', fid));
							}
						};
					}
				}
			],
			plugins: [
				Ext.create('Ext.grid.plugin.CellEditing', {
					triggerEvent:'cellclick'
				})
			],
			viewConfig:{
				preserveScrollOnRefresh: true,
				stripeRows:true
			},
			showRowActionsColumn:false,
			showPagingToolbar:false,
			enableEditing:false,
			context: this.getContext(),
			store: me.TeamCommitsStore
		});	
	},
	
	_loadRisksGrid: function(){
		var me = this;	

		var risksRecords = _.map(me.RisksFeatureStore.getRecords(), function(featureRecord){
			return Ext.create('RisksModel', {
				FormattedID: featureRecord.get('FormattedID'),
				Name: featureRecord.get('Name'),
				Risks: featureRecord.get('c_Risks')
			});
		});
		
		me.RisksStore = Ext.create('Rally.data.custom.Store', {
			data: risksRecords,
			model: 'RisksModel',
			proxy: {
				type:'sessionstorage',
				keyField:'risks' + Math.random()
			},
			listeners:{ 
				load: function(customStore, customRecords){
					console.log('syncing custom risks with features');
					var i, unaccountedFor = customRecords.slice(0);
					me.RisksFeatureStore.getRecords().forEach(function(featureRecord){
						var c_Risks = featureRecord.get('c_Risks');
						var risksRecord = customStore.findRecord('FormattedID', featureRecord.get('FormattedID'));
						if(!risksRecord && c_Risks){
							customStore.add(Ext.create('RisksModel',  {
								FormattedID: featureRecord.get('FormattedID'),
								Name: featureRecord.get('Name'),
								Risks: c_Risks
							}));
						} else if(risksRecord && !c_Risks){
							customStore.remove(riskRecord);
							for(i = 0;i<unaccountedFor.length;++i){
								if(unaccountedFor[i].get('FormattedID') === risksRecord.get('FormattedID')){
									unaccountedFor.splice(i, 1);
									return;
								}
							}
						} else if(!risksRecord && !c_Risks){
							return; //just got deleted
						} else {
							if(risksRecord.get('Risks') !== c_Risks) 
								risksRecord.set('Risks', c_Risks);
							for(i = 0;i<unaccountedFor.length;++i){
								if(unaccountedFor[i].get('FormattedID') === risksRecord.get('FormattedID')){
									unaccountedFor.splice(i, 1);
									return;
								}
							}
						}
					});
					unaccountedFor.forEach(function(riskRecord){
						customStore.remove(riskRecord);
					});
				}
			}
		});
		
		me.RisksGrid = me.add({
			xtype: 'rallygrid',
			title:'Risks',
			width: 920,
			height:500,
			style:'margin-bottom:10px',
			scroll:'vertical',
			columnCfgs: [
				{
					text:'ID', 
					dataIndex:'FormattedID',
					width:50,
					editor:false
				},{
					text:'Feature', 
					dataIndex:'Name',
					width:150,
					editor:false
				},{
					text:'length', 
					dataIndex:'Risks',
					width:50,
					renderer: function(json){
						return json.length;
					}
				},{
					dataIndex:'Risks',
					width:570,
					text:'Data',
					editor:false,
					renderer: function(json){
						return '<pre>' + json + '</pre>';
					}
				},{
					text:'',
					dataIndex:'FormattedID',
					width:80,
					xtype:'componentcolumn',
					renderer: function (fid, meta, risksRecord){
						return {
							xtype:'button',
							width:70,
							text:'Delete',
							handler: function () {
								var featureRecord = me.RisksFeatureStore.findRecord('FormattedID', fid);
								if(featureRecord){
									console.log('deleting featureRecord risk:', featureRecord);
									featureRecord.set('c_Risks', '');
									featureRecord.save();
								}
								me.RisksStore.remove(me.RisksStore.findRecord('FormattedID', fid));
							}
						};
					}
				}
			],
			plugins: [
				Ext.create('Ext.grid.plugin.CellEditing', {
					triggerEvent:'cellclick'
				})
			],
			viewConfig:{
				preserveScrollOnRefresh: true,
				stripeRows:true
			},
			showRowActionsColumn:false,
			showPagingToolbar:false,
			enableEditing:false,
			context: this.getContext(),
			store: me.RisksStore
		});	
	},
	
	_loadDependenciesGrid: function(){
		var me = this;	

		var dependenciesRecords = _.map(me.DependenciesUserStoryStore.getRecords(), function(userStoryRecord){
			return Ext.create('DependenciesModel', {
				FormattedID: userStoryRecord.get('FormattedID'),
				Name: userStoryRecord.get('Name'),
				Dependencies: userStoryRecord.get('c_Dependencies')
			});
		});
		
		me.DependenciesStore = Ext.create('Rally.data.custom.Store', {
			data: dependenciesRecords,
			model: 'DependenciesModel',
			proxy: {
				type:'sessionstorage',
				keyField:'deps' + Math.random()
			},
			listeners:{ 
				load: function(customStore, customRecords){
					console.log('syncing custom Dependencies with user Stories');
					var i, unaccountedFor = customRecords;
					me.DependenciesUserStoryStore.getRecords().forEach(function(usRecord){
						var c_Deps = usRecord.get('c_Dependencies');
						var dependenciesRecord = customStore.findRecord('FormattedID', usRecord.get('FormattedID'));
						if(!dependenciesRecord && c_Deps){
							customStore.add(Ext.create('DependenciesModel',  {
								FormattedID: usRecord.get('FormattedID'),
								Name: usRecord.get('Name'),
								Dependencies: c_Deps
							}));
						} else if(dependenciesRecord && !c_Deps){
							customStore.remove(dependenciesRecord);
							for(i = 0;i<unaccountedFor.length;++i){
								if(unaccountedFor[i].get('FormattedID') === dependenciesRecord.get('FormattedID')){
									unaccountedFor.splice(i, 1);
									return;
								}
							}
						} else if(!dependenciesRecord && !c_Deps){
							return; //just got deleted
						} else {
							if(dependenciesRecord.get('Dependencies') !== c_Deps)
								dependenciesRecord.set('Dependencies', c_Deps);
							for(i = 0;i<unaccountedFor.length;++i){
								if(unaccountedFor[i].get('FormattedID') === dependenciesRecord.get('FormattedID')){
									unaccountedFor.splice(i, 1);
									return;
								}
							}
						}
					});
					unaccountedFor.forEach(function(dependenciesRecord){
						customStore.remove(dependenciesRecord);
					});
				}
			}
		});
		me.DependenciesGrid = me.add({
			xtype: 'rallygrid',
			title:'Dependencies',
			width: 970,
			height:800,
			style:'margin-bottom:10px',
			scroll:'vertical',
			columnCfgs: [
				{
					text:'ID', 
					dataIndex:'FormattedID',
					width:100,
					editor:false
				},{
					text:'UserStory', 
					dataIndex:'Name',
					width:150,
					editor:false
				},{
					text:'length', 
					dataIndex:'Dependencies',
					width:50,
					renderer: function(json){
						return json.length;
					}
				},{
					dataIndex:'Dependencies',
					width:570,
					text:'Data',
					editor:false,
					renderer: function(json){
						return '<pre>' + json + '</pre>';
					}
				},{
					text:'',
					dataIndex:'FormattedID',
					width:80,
					xtype:'componentcolumn',
					renderer: function (fid, meta, dependencyRecord){
						return {
							xtype:'button',
							width:70,
							text:'Delete',
							handler: function () {
								var userStoryRecord = me.DependenciesUserStoryStore.findRecord('FormattedID', fid);
								if(userStoryRecord){
									console.log('deleting userStory dependency:', userStoryRecord);
									userStoryRecord.set('c_Dependencies', '');
									userStoryRecord.save();
								}
								me.DependenciesStore.remove(me.DependenciesStore.findRecord('FormattedID', fid));
							}
						};
					}
				}
			],
			plugins: [
				Ext.create('Ext.grid.plugin.CellEditing', {
					triggerEvent:'cellclick'
				})
			],
			viewConfig:{
				preserveScrollOnRefresh: true,
				stripeRows:true
			},
			showRowActionsColumn:false,
			showPagingToolbar:false,
			enableEditing:false,
			context: this.getContext(),
			store: me.DependenciesStore
		});	
	}	

});

            Rally.launchApp('CustomApp', {
                name:"Random App Name70221",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
  /* Add app styles here */
}
/* .x-grid-row-alt {
	background-color:gray !important;
} */
.intel-feature-not-committed .x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
.intel-feature-not-committed.x-grid-row-selected .x-grid-cell {
  background-color: rgba(255, 0, 0, 0.25) !important;
}
.intel-feature-committed .x-grid-cell {
  background-color: rgba(0, 255, 0, 0.15) !important;
}
.intel-feature-committed.x-grid-row-selected .x-grid-cell {
  background-color: rgba(0, 255, 0, 0.25) !important;
}

    </style>
</head>
<body>
</body>
</html>
