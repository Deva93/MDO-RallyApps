<!DOCTYPE html>
<html>
<head>
    <title>Risk Swimlane</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.6.0/lodash.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** this extends Rally.app.app. if you want to use it's utility functions, just
		extend IntelRallyApp instead of Rally.app.App
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	//increase timeouts to 2 minutes since rally can be slow sometimes
	var timeout = 120000;
	Ext.override(Ext.data.proxy.Ajax, { timeout: timeout });
	Ext.override(Ext.data.proxy.JsonP, { timeout: timeout });
	
	//rally's built-in jsonpproxy does not handle timeouts
	Ext.override(Rally.sdk.data.lookback.JsonPProxy, {
		setException: function(operation, response){
			var error = operation.getError() || {};
			operation.setException(Ext.apply(error, {
				errors:(response || {}).Errors || []
			}));
		}
	});
				
	Ext.define('IntelRallyApp', {
		alias: 'widget.intelrallyapp',
		extend: 'Rally.app.App',
		
		_ScrumGroupConfigPrefName: 'intel-portfolio-locations-config', //preference to store portfolio locations config for workspace
		
		_projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
		_portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'Release','c_TeamCommits', 'c_MoSCoW', 
			'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal'],
		_userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
			'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
		_releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
		
		/********************************************** APP CONFIGURATION **************************************/
		_loadScheduleStates: function(){ 
			var me=this, deferred = Q.defer();
			Rally.data.ModelFactory.getModel({
				type: 'UserStory',
				success: function(model) {
					model.getField('ScheduleState').getAllowedValueStore().load({
						callback: function(records, operation, success) {
							me.ScheduleStates = _.map(records, function(r){ return r.data.StringValue; });
							deferred.resolve();
						}
					});
				}
			});
			return deferred.promise;
		},
		_loadPortfolioItemStatesForEachType: function(){ 
			var me=this;
			me.PortfolioItemTypeStates = [];
			return Q.all(_.map(me.PortfolioItemTypes, function(portfolioType, ordinal){
				var store = Ext.create('Rally.data.wsapi.Store', {
					model: 'State',
					autoLoad:false,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Name', 'Enabled', 'OrderIndex'],
					filters: [{
						property: 'TypeDef.Name',
						value: portfolioType
					},{
						property: 'Enabled',
						value: true
					}]
				});
				return me._reloadStore(store).then(function(store){
					me.PortfolioItemTypeStates[ordinal] = store.getRange();
				});
			}));
		},
		_loadPortfolioItemTypes: function(){ 
			/** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
			var me=this,
				deferred = Q.defer(),
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'TypeDefinition',
					autoLoad:true,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					listeners:{
						load:function(portfolioTypeStore){
							me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(), 
								function(item){ return {Name: item.data.Name, Ordinal: item.data.Ordinal}; }),
								function(item){ return item.Ordinal; }),
								function(item){ return item.Name; });
							deferred.resolve();
						}
					}
				});
			return deferred.promise;
		},
		_loadModels: function(){ 
			/** loads models for project, userstories, and all the portfolio items */
			var me=this, 
				promises = [],
				models = {
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					PortfolioItem: 'PortfolioItem'
				};
			_.each(me.PortfolioItemTypes, function(name){ models['PortfolioItem/' + name] = 'PortfolioItem/' + name; });
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},
		_loadScrumGroupConfig: function(){
			/** scrum-groups are groups of scrums that share the same portfolio. The group of scrums may or may not be a train */
			/** me.ScrumGroupConfig is an array of these objects: 
				{
					ScrumGroupRootProjectOID: configItem.ScrumGroupRootProjectOID || 0,
					ScrumGroupName: configItem.ScrumGroupName || '',
					ScrumGroupAndPortfolioLocationTheSame: configItem.ScrumGroupAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0,
					IsTrain: configItem.IsTrain ? true : false
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._ScrumGroupConfigPrefName,
				success: function(prefs) {
					var configString = prefs[me._ScrumGroupConfigPrefName], scrumGroupConfig;
					try{ scrumGroupConfig = JSON.parse(configString); }
					catch(e){ scrumGroupConfig = []; }
					me.ScrumGroupConfig = scrumGroupConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveScrumGroupConfig: function(scrumGroupConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[me._ScrumGroupConfigPrefName] = JSON.stringify(scrumGroupConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._ScrumGroupConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_configureIntelRallyApp: function(){
			var me=this;
			me.BaseUrl = Rally.environment.getServer().getBaseUrl(); //is "" when in custom app iframe
			return Q.all([
				me._loadPortfolioItemTypes().then(function(){ 
					me._userStoryFields.push(me.PortfolioItemTypes[0]);  //HOLY PROGRAM BOARD BUG, BATMAN! (me._isUserStoryInRelease false for those who: (release == null && portfolioItrem.release.name == me.ReleaseRecord.data.Name)).
					return Q.all([
						me._loadModels(),
						me._loadPortfolioItemStatesForEachType()
					]);
				}),
				me._loadScrumGroupConfig(),
				me._loadScheduleStates()
			]);
		},
				
		/**************************** Generic store loading with Q wrapper, returns promise *************************************/		
		_reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		},
		
		/********************************************** LOADING SINGLE MODELS **************************************/	
		_loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LP');
			else if(!me.Project) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.Project.load(oid, {
					fetch: me._projectFields,
					context: { 
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadUserStory: function(oid, projectRecord){
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LUS');
			else if(!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.UserStory.load(oid, {
					fetch: me._userStoryFields,
					context: {
						workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
						project: projectRecord ? projectRecord.data._ref : null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByType: function(oid, type){
			var me = this, deferred = Q.defer();
			if(!oid || !type) return Q.reject('Invalid arguments: LPIBT');
			else {
				me[type].load(oid, {
					fetch: me._portfolioItemFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByOrdinal: function(oid, ordinal){
			var me = this, deferred = Q.defer(),
				type = me.PortfolioItemTypes[ordinal];
			return me._loadPortfolioItemByType(oid, type);
		},	
		
		/**************************************** ScrumGroup Funcs ***************************************************/
		_projectInWhichScrumGroup: function(projectRecord){ 
			/** returns scrumgroup the projectRecord is in, otherwise null. */
			if(!projectRecord) return Q();
			else {
				var me=this,
					foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
						return scrumGroupConfig.ScrumGroupRootProjectOID == projectRecord.data.ObjectID; 
					});
				if(foundScrumGroupConfig) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q();
					else {
						return me._loadProject(parent.ObjectID).then(function(parentRecord){
							return me._projectInWhichScrumGroup(parentRecord);
						});
					}
				}
			}
		},
		_loadScrumGroupPortfolioProject: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) return Q.reject('Invalid arguments: _loadScrumGroupPortfolioProject');
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) return Q.reject('Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum group!');
			if(foundScrumGroupConfig.ScrumGroupAndPortfolioLocationTheSame) return Q(scrumGroupRootProjectRecord);
			else return me._loadProject(foundScrumGroupConfig.PortfolioProjectOID);
		},
		_getScrumGroupName: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) throw 'Invalid arguments: _getScrumGroupName';
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) throw 'Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum-group!';
			if(foundScrumGroupConfig.ScrumGroupName) return foundScrumGroupConfig.ScrumGroupName;
			else return scrumGroupRootProjectRecord.data.Name;
		},
		_loadAllScrumGroups: function(){
			var me=this,
				filter = _.reduce(me.ScrumGroupConfig, function(filter, scrumGroupConfig){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', { property:'ObjectID', value: scrumGroupConfig.ScrumGroupRootProjectOID });
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			if(!filter) return Q([]);
			else {
				var store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._projectFields,
					filters:[filter],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
				return me._reloadStore(store).then(function(store){ return store.getRange(); });
			}
		},
		
		/**************************************** UserStory Funcs ************************************************/
		__getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ 
			/** only pull look at PortfolioItem Release if US.Release == null */
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property: lowestPortfolioItem + '.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property: lowestPortfolioItem + '.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		_loadRandomUserStory: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: LRUS');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: false,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{ 
						property:'Project.ObjectID', 
						value: projectRecord.data.ObjectID 
					}]
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadRandomUserStoryFromReleaseTimeframe: function(projectRecord, releaseRecord){
			if(!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: LRUSFR');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					disableMetaChangeEvent: true,
					fetch: me._userStoryFields,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project.ObjectID', value: projectRecord.data.ObjectID }).and(
						me.__getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me._reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		_loadUserStoryByFID: function(formattedID, projectRecord){
			if(!formattedID || !projectRecord) return Q.reject('Invalid arguments: LUSBFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		
		/**************************************** PortfolioItem Funcs ************************************************/
		_loadPortfolioItemsOfType: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: OPIOT');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					disableMetaChangeEvent: true,
					remoteSort:false,
					fetch: me._portfolioItemFields,
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store);
		},		
		_loadPortfolioItemsOfOrdinal: function(portfolioProject, ordinal){
			if(!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: LPIOO');
			var me=this, type = me.PortfolioItemTypes[ordinal];
			if(type) return me._loadPortfolioItemsOfType(portfolioProject, type);
			else return Q.reject('Invalid PortfolioItem ordinal');
		},
		_portfolioItemTypeToOrdinal: function(type){
			return this.PortfolioItemTypes.indexOf(type);
		},
		_getPortfolioItemTypeStateByOrdinal: function(ordinal, stateName){
			return _.find(this.PortfolioItemTypeStates[ordinal], function(state){ return state.data.Name == stateName; });
		},
		_getPortfolioItemTypeStateByName: function(portfolioType, stateName){
			return this._getPortfolioItemTypeStateByOrdinal(this._portfolioItemTypeToOrdinal(portfolioType), stateName);
		},
		
		/********************************************** Project Funcs ********************************************/
		/****************************** THESE DO NOT WORK WITH sdk 2.0. USE SDK 2.0rc3 *******************/
		__storeItemsToProjTree: function(projects){
			var me=this, projTree = {};
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			return projTree;
		},
		_loadAllProjects: function(){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				var map = _.reduce(store.getRange(), function(map, project){
					map[project.data.ObjectID] = project;
					return map;
				}, {});
				return map;
			});	
		},
		__addProjectsWithTeamMembersToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
			}
		},	
		_loadProjectsWithTeamMembers: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				projectsWithTeamMembers = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
					return projectsWithTeamMembers;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.TeamMembers.Count > 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},	
		__allChildProjectToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_loadAllChildrenProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				childrenProjects = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
					return childrenProjects;
				} else {
					return _.reduce(store.getRange(), function(map, project){
						map[project.data.ObjectID] = project;
						return map;
					}, {});
				}
			});
		},	
		__allLeafProjectsToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		_loadAllLeafProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				leafProjects = {}, 
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
					return leafProjects;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.Children.Count === 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},
		_loadProjectByName: function(projectName){
			if(!projectName) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [{
						property:'Name',
						value:projectName
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** Release loading ********************************************/	
		_loadAllReleases: function(projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesBeforeGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					disableMetaChangeEvent: true,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'<=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesBetweenDates: function(projectRecord, startDate, endDate){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit: Infinity,
					autoLoad:false,
					fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					},{
						property:'ReleaseDate',
						operator:'>',
						value: new Date(startDate).toISOString()
					},{
						property:'ReleaseStartDate',
						operator:'<',
						value: new Date(endDate).toISOString()
					}]
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesInTheFuture: function(projectRecord){
			return this._loadReleasesAfterGivenDate(projectRecord, new Date());
		},
		_loadReleasesByNameUnderProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					}],
					context:{
						project:projectRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleaseByNameForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						operator:'contains',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_getScopedRelease: function(releaseRecords, projectOID, appPrefs){			
			/** gets the most likely release to scope to base on the following order:
				1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
								to use preferences for this one)
				2) if we are currently in one of the releases
				3) the closest release planning date to the current date
			*/
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate)*1, d2 = new Date(r.data.ReleaseStartDate)*1, now = new Date()*1;
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
		/************************* MODEL FOR WORKWEEK DROPDOWNS *********************************************/
	Ext.define('WorkweekDropdown', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Workweek', type:'string'},
			{name: 'DateVal', type:'number'}
		]
	});
		
	/************************* USED FOR WORKSPACE TRAIN CONFIG *********************************************/
	Ext.define('ScrumGroupPortfolioConfigItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'ScrumGroupRootProjectOID', type: 'number'},
			{name: 'ScrumGroupName', type: 'string'},
			{name: 'ScrumGroupAndPortfolioLocationTheSame', type:'boolean'},
			{name: 'PortfolioProjectOID', type:'number'},
			{name: 'IsTrain', type:'boolean'}
		]
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
		/** this is used if you want to listen to events in the parent window (e.g. useful for rally apps that resize with browser screen
			vertically or things that need to know browser scroll position) 
		You also can artificially fire the events and have the listeners run
	*/
	Ext.define('WindowListener', {

		__initWindowEventListener: function(eventName){
			var me=this;
			if(!me._windowListeners) me._windowListeners = {};
			me._windowListeners[eventName] = [];
			
			window.parent['on' + eventName] = function(event){ 
				var listeners = me._windowListeners[eventName];
				for(var i=0, len=listeners.length; i<len; ++i)
					listeners[i](event);
			};
		},
		
		_addWindowEventListener: function(eventName, fn){
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) 
				me.__initWindowEventListener(eventName);
			me._windowListeners[eventName].push(fn);
		},
		
		_fireParentWindowEvent: function(eventName){ //eg: resize or scroll
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) return;
			var listeners = me._windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
		}
	});
}());
                /** this mixin is used to mess with the environment outside of the iframe that the rally app is put in. */
(function(){
	var Ext = window.Ext4 || window.Ext;

	var TOP_BAR_HEIGHT = 40,
		BOTTOM_BAR_HEIGHT = 24,
		BOTTOM_IFRAME_PADDING = 20,
		TITLE_BAR_HEIGHT = 33,
		IFRAME_HEADER_HEIGHT = 28;
		
	Ext.define('IframeResize', {
		requires: ['WindowListener'],
		
		_fixRallyDashboard: function(){ 
			/** makes app as large as screen, without the padding/margin */
			if(window && window.frameElement){
				var me=this,
					bottomEl = Ext.get(window.frameElement),
					portlet = bottomEl.up('.x-portlet'), 
					dashboard = portlet.up('#mydash_portlet'), //has huge padding values
					titleBar = dashboard.down('.titlebar'), //redundant with app header bar
					domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
					innerHeight = window.parent.innerHeight,
					innerWidth = window.parent.innerWidth;
				
				//adjust widths
				while(true){
					domNodeW.style.width = (innerWidth - 4) + 'px';
					domNodeW.style.padding = '0';
					domNodeW.style.margin = '0';
					if(domNodeW.id === 'mydash_portlet') break;
					domNodeW = domNodeW.parentNode;
				}
				
				//adjust heights
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT + IFRAME_HEADER_HEIGHT + BOTTOM_IFRAME_PADDING)) + 'px';
					if(domNodeH.classList.contains('x-portlet')) break;
					domNodeH = domNodeH.parentNode;
				}
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT)) + 'px';
					if(domNodeH.id == 'mydash_portlet') break;
					domNodeH = domNodeH.parentNode;
				}
				dashboard.dom.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT)) + 'px';
				
				//final touches LOL
				dashboard.dom.style.padding = "0 2px 0 2px";
				titleBar.dom.style.padding = "2px";
				titleBar.dom.style.margin = "0";
			}
		},		
		_initFixRallyDashboard: function(){ 
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
			}
			me._fixRallyDashboard();
		},

		_disableResizeHandle: function(){ 
			/** hides the draggable resize handle from under the app */
			var me=this, handle;
			if(window && window.frameElement){
				handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
				if(handle) {
					handle.hide();
					handle.dom.onshow = function(){ if(handle) handle.hide(); };
				}
			}
		},	
		_initDisableResizeHandle: function(){
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
			}
			me._disableResizeHandle();
		}
	});
}());
                /** this is pretty much like a mutex implementation. you call enqueue and then when its your function's turn
	you do stuff and then you call the callback passed to you so the next function can execute.
	
	IT WILL ALWAYS PERFORM YOUR QUEUED FUNCTION WRAPPED IN A setTimeout. 
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	//given named queues, only allows one function at a time in each queue to execute. 
	Ext.define('AsyncQueue', {
		
		QueueOfFuncs: {},
		
		_dequeue: function(queueName){
			var me=this;
			queueName = queueName || 'undefined'; //to be clear
			if(me.QueueOfFuncs[queueName]){
				me.QueueOfFuncs[queueName].shift();
				if(!me.QueueOfFuncs[queueName].length) return;
				else {
					setTimeout(function(){
						me.QueueOfFuncs[queueName][0].call(me, me._dequeue.bind(me, queueName));
					}, 0);
				}
			}
		},
		
		//callback(done)...make sure you call done when you are finished
		_enqueue: function(callback, queueName){
			var me=this;
			queueName = queueName || 'undefined'; //to be clear
			if(typeof callback !== 'function') throw 'ERROR: not a function';
			if(!me.QueueOfFuncs[queueName] || !me.QueueOfFuncs[queueName].length){
				me.QueueOfFuncs[queueName] = [callback];
				setTimeout(function(){
					callback.call(me, me._dequeue.bind(me, queueName));
				}, 0);
			}
			else me.QueueOfFuncs[queueName].push(callback);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/**  
		THIS IS ONLY USEFUL AS A RALLYAPP MIXIN 
		gives a window-centered alert or confirm dialog box that isn't ugly. 
	*/
	Ext.define('PrettyAlert', {

		__getMessageBoxY: function(){ 
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.frameElement ? window.parent.getWindowHeight() : window.innerHeight,
				ps = window.frameElement ? window.parent.getScrollY() : window.scrollY,
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},
		
		_alert: function(title, message){
			var me=this;
			message = message || '';
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<1) return;
			if(arguments.length===1){
				message = title;
				title = '';
			}
			Ext.MessageBox.alert(title, message).setY(me.__getMessageBoxY());
			setTimeout(function(){ //give some time to give the 'ok' or 'yes' button focus
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 50);
		},
		
		_confirm: function(title, message, fn){
			var me=this;
			message = message || '';
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = message;
				message = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			Ext.MessageBox.confirm(title, message, fn).setY(me.__getMessageBoxY());
			setTimeout(function(){
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 20);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;

	var intel_ww = {},
		SECOND = 1000,
		MINUTE = 60*SECOND,
		HOUR = 60*MINUTE,
		DAY = 24*HOUR,
		WEEK = 7*DAY;
		
	Ext.define('IntelWorkweek', {
		/** 
			intel workweek utility module. you can pass in Date objects, strings, or numbers.
			do not pass in Unix UTC millis though, or you will get wrong answer (eg: dont use Date.UTC(...))
		**/
		
		/** calculates intel workweek, returns integer */
		_getWorkweek: function(_date){  //ww1 always contains jan 1st
			var date = new Date(_date),
				yearStart = new Date(date.getFullYear(), 0, 1),
				dayIndex = yearStart.getDay(),
				ww01Start = new Date(yearStart - dayIndex*DAY),
				utcDateMillis = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
				ww01Millis = Date.UTC(ww01Start.getFullYear(), ww01Start.getMonth(), ww01Start.getDate()),
				timeDiff = utcDateMillis - ww01Millis,
				ww = Math.floor(timeDiff/WEEK) + 1,
				leap = (date.getFullYear() % 4 === 0),
				weekCount = ((leap && dayIndex >= 5) || (!leap && dayIndex === 6 )) ? 53 : 52; //weeks in this year
			return weekCount < ww ? 1 : ww;
		},
		
		/** returns the number of intel workweeks in the year the date is in */
		_getWeekCount: function(_date){  // # of intel workweeks in the year the date is in
			var date = new Date(_date),
				leap = (date.getFullYear() % 4 === 0),
				day = new Date(date.getFullYear(), 0, 1).getDay();
			return ((leap && day >= 5) || (!leap && day === 6 )) ? 53 : 52;
		},
		
		_roundDateDownToWeekStart: function(_date){
			var date = new Date(_date),
				day = date.getDay(),
				monthDate = date.getDate(),
				month = date.getMonth(),
				year = date.getFullYear(),
				sundayMidday = new Date(new Date(year, month, monthDate)*1 - (day*DAY - 0.5*DAY)); //daylight savings ._.
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/**  gets list of date numbers for each week start between start and end date*/
		_getWorkweekDates: function(startDate, endDate){ //gets list of dates for each week. INCLUSIVE
			var startWeekDate = this._roundDateDownToWeekStart(startDate),
				endWeekDate = this._roundDateDownToWeekStart(endDate),
				startMillis = Date.UTC(startWeekDate.getFullYear(), startWeekDate.getMonth(), startWeekDate.getDate()),
				endMillis = Date.UTC(endWeekDate.getFullYear(), endWeekDate.getMonth(), endWeekDate.getDate()),
				totalWeeks = Math.floor((endMillis - startMillis) / WEEK)+1,
				weeks = new Array(totalWeeks);
			for(var i=0; i<totalWeeks; ++i) {
				var sundayMidday = new Date(startWeekDate*1 + (WEEK*i + HOUR*12));
				weeks[i] = new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
			}
			return weeks;
		},
		
		_workweekToDate: function(ww, year){ //gets the Date() object of this ww and year
			var yearStart = new Date(year, 0, 1),
				dayIndex = yearStart.getDay(),
				ww01StartMidday = new Date(yearStart - (dayIndex*DAY - 0.5*DAY)),
				sundayMidday = new Date(ww01StartMidday*1 + (ww-1)*WEEK);
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		_getWorkWeeksForDropdown: function(releaseStartDate, releaseEndDate){ //assumes DropDown uses WorkweekDropdown model
			var workweeks = this._getWorkweekDates(releaseStartDate, releaseEndDate),
				data = new Array(workweeks.length);
			for(var i=0, len=workweeks.length; i<len; ++i){
				data[i] = { 
					Workweek: 'ww' + this._getWorkweek(workweeks[i]),
					DateVal: workweeks[i]*1
				};
			}
			return data;
		}	
	});
}());
                /** 
	Use this to load stores that have lots of records. it will load them in parallel instead of serially.
	what it does is loads 1 page and then based on the totalCount it loads the rest of the pages in parallel.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('ParallelLoader', {		
		_parallelLoadWsapiStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.wsapi.Store', _.merge({}, config, {
						pageSize:200,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.wsapi.Store', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = ((store.totalCount/200>>0) + (store.totalCount%200 ? 1 : 0)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		},
		_parallelLoadLookbackStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.lookback.SnapshotStore', _.merge({}, config, {
						pageSize:20000,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.lookback.SnapshotStore', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = ((store.totalCount/20000>>0) + (store.totalCount%20000 ? 1 : 0)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		}
	});
}());

                /** This class is used to save user preferences per project, that can follow the user from app to app **/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('UserAppsPreference', {
		
		_userAppsPref: 'intel-user-apps-preference', //preference name can be overridden, unless you want all apps to share prefs
		
		_loadAppsPreference: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				filterByUser:true,
				filterByName:me._userAppsPref,
				success: function(prefs) {
					var appPrefs = prefs[me._userAppsPref];
					try{ appPrefs = JSON.parse(appPrefs); }
					catch(e){ appPrefs = { projs:{}, refresh:0};}
					deferred.resolve(appPrefs);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveAppsPreference: function(prefs){
			var me=this, s = {}, deferred = Q.defer();
			prefs = {projs:prefs.projs, refresh:prefs.refresh};
			s[me._userAppsPref] = JSON.stringify(prefs); 
			Rally.data.PreferenceManager.update({
				filterByUser: true,
				filterByName:me._userAppsPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** this combo has filter-as-you-type and drops down on click. it also lets you navigate with arrow keys
		(although there is some arrow key scrolling bug) 
	*/
	Ext.define('IntelComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelcombo', 'widget.intelcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				enableKeyEvents:true,
				queryMode:'local',
				ignoreNoChange:true,
				allowBlank:true,
				listeners: {
					keyup: function(a,b){
						if(b.keyCode>=37 && b.keyCode <=40) return; //arrow keys
						var combo = this;
						combo.store.clearFilter();
						combo.store.filterBy(function(item){
							return item.data[combo.displayField].match(new RegExp(combo.getRawValue(), 'i')) !== null;
						});
					},
					focus: function(combo) {
						combo.store.clearFilter();
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('IntelFixedComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				editable: false,	
				allowBlank:true,
				queryMode:'local',
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					focus: function(combo) {
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}	
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** YOU MUST PASS IT 2 THINGS IN THE CONFIG
		1: releases (array of release records)
		2: currentRelease (what to show as initial value
	*/
	Ext.define('IntelReleasePicker', {
		extend: 'IntelFixedComboBox',
		alias: ['widget.intelreleasepicker'],
		
		constructor: function(options){
			if(!options.releases || !options.currentRelease) return;
			
			options.displayField = 'Name';
			options.value = options.currentRelease.data.Name;
			options.store = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(options.releases, function(r){ return {Name: r.data.Name }; })
			});
			
			options.fieldLabel = options.fieldLabel || 'Release:';
			options.editable = options.editable || false;
			options.width = options.width || 240;
			options.labelWidth = options.labelWidth || 50;
			
			this.callParent([options]); //now that we have the extra stuff added
		}
	});
}());

                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/************************* USED FOR PROGRAM-BOARD VIEW *********************************************/
	Ext.define('IntelVelocity', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Name', type: 'string'},
			{name: 'PlannedVelocity', type: 'number'},
			{name: 'RealVelocity', type:'number'}
		]
	});
	Ext.define('IntelTeamCommits', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PortfolioItemObjectID', type: 'number'},
			{name: 'PortfolioItemMoSCoW', type:'string'},
			{name: 'PortfolioItemName', type: 'string'},
			{name: 'PortfolioItemFormattedID', type:'string'},
			{name: 'PortfolioItemPlannedEnd', type:'number'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'Commitment', type: 'string'},
			{name: 'Expected', type: 'boolean'},
			{name: 'Objective', type:'string'}
		]
	});
	Ext.define('IntelRisk', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'RiskID', type:'string'},
			{name: 'PortfolioItemObjectID', type:'number'},
			{name: 'PortfolioItemFormattedID',  type: 'string'}, //can be different than PortfolioItemObjectID
			{name: 'PortfolioItemName', type:'string'}, //can be different than PortfolioItemObjectID
			{name: 'Description', type: 'string'}, 
			{name: 'Impact', type: 'string'},	
			{name: 'MitigationPlan', type: 'string'},					
			{name: 'Urgency', type: 'string'},
			{name: 'Status', type: 'string'},
			{name: 'Contact', type: 'string'},
			{name: 'Checkpoint', type: 'number'},
			{name: 'Edited', type: 'boolean'}
		]
	});

	Ext.define('IntelPredecessorItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PredecessorItemID',  type: 'string'}, 
			{name: 'PredecessorUserStoryObjectID', type: 'number'},
			{name: 'PredecessorProjectObjectID',  type: 'number'},
			{name: 'Supported', type: 'string'},
			{name: 'Assigned', type: 'boolean'} 
		]
	});

	Ext.define('IntelPredecessorDependency', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, //can be different than UserStoryObjectID
			{name: 'UserStoryName',  type: 'string'}, //can be different than UserStoryObjectID
			{name: 'Description', type: 'string'},
			{name: 'NeededBy', type: 'number'},
			{name: 'Status', type:'string'},
			{name: 'PredecessorItems', type: 'auto'}, 
			{name: 'Edited', type: 'boolean'}
		]
	});		
		
	Ext.define('IntelSuccessorDependency', { 
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'SuccessorUserStoryObjectID', type: 'string' },
			{name: 'SuccessorProjectObjectID', type: 'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, //can be different than UserStoryObjectID (or null)
			{name: 'UserStoryName', type: 'string'}, //can be different than UserStoryObjectID (or null)
			{name: 'Description', type: 'string'}, 
			{name: 'NeededBy', type: 'number'},
			{name: 'Supported', type: 'string'}, 
			{name: 'Assigned', type: 'boolean'},
			{name: 'Edited', type: 'boolean'}
		]
	});	

	/************************* USED FOR RISKS/DEPS AND SWIMLANE(RISKS ONLY) VIEW *********************************************/

	Ext.define('IntelRiskForTracking', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'RiskID', type:'string'},
			{name: 'PortfolioItemObjectID', type:'number'},
			{name: 'PortfolioItemFormattedID',  type: 'string'},
			{name: 'PortfolioItemName', type:'string'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'ProjectObjectID', type:'number'},
			{name: 'Description', type: 'string'},
			{name: 'Impact', type: 'string'},	
			{name: 'MitigationPlan', type: 'string'},					
			{name: 'Urgency', type: 'string'},
			{name: 'Status', type: 'string'},
			{name: 'Contact', type: 'string'},
			{name: 'Checkpoint', type: 'number'},
			{name: 'Edited', type: 'boolean'}
		]
	});

	Ext.define('IntelPredecessorDependencyForTracking', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, 
			{name: 'UserStoryName',  type: 'string'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'ProjectObjectID', type:'number'},
			{name: 'Description', type: 'string'},
			{name: 'NeededBy', type: 'number'},
			{name: 'Status', type:'string'},
			{name: 'PredecessorItems', type: 'auto'}, 
			{name: 'Edited', type: 'boolean'}
		]
	});		


	/************************* USED FOR TEAMCOMMITS VIEW *********************************************/
	Ext.define('CommitsMatrixPortfolioItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PortfolioItemObjectID', type: 'number'},
			{name: 'PortfolioItemRank', type: 'number'},
			{name: 'PortfolioItemName', type: 'string'},
			{name: 'PortfolioItemFormattedID', type:'string'},
			{name: 'PortfolioItemPlannedEnd', type:'number'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'MoSCoW', type: 'string'}
		]
	});
	
	/************************* USED FOR SWIMLANES VIEW *********************************************/
	Ext.define('IntelSwimlaneRiskForTracking', {
		extend: 'Rally.data.Model',							//rally cardboard is heavily tied to wsapi objects so we have to override a lot of stuff...
		fields: [
			{name: '_originalRiskData', type:'auto'},
			{name: 'RiskID', type:'string'},
			{name: 'Rank', type:'string'},										//idk man
			{name: 'PortfolioItem #', type: 'string'},
			{name: 'PortfolioItem Name', type:'string'},
			{name: 'Project', type:'string'},
			{name: 'Risk Description', type: 'string'},				//change from Description because Description is a wsapi field... and it causes an error			
			{name: 'Impact', type: 'string'},	
			{name: 'MitigationPlan', type: 'string'},
			{name: 'Urgency', type: 'string', attributeDefinition: {AttributeType:'Dropdown'}}, //add attributeDefinition because rallycardboard looks for this
			{name: 'Status', type: 'string'},
			{name: 'Contact', type: 'string'},
			{name: 'Checkpoint', type: 'string'},
			{name: 'updatable', type: 'boolean'}	//have to set updatable:true for each record or else they won't be draggable
		],
		idField: {name: 'RiskID'},							//so record.getId() works off of the RiskID field
		idProperty: 'RiskID',										//so sessionstorage proxy works off of the RiskID field
		isTask: function(){ return false; },		//rallycardboard calls this
		isSearch: function(){ return false;}		//rallypopoverfactory calls this for some reason
	});
	
	/************************* USED FOR CUSTOM-FIELD EDITOR *********************************************/
	Ext.define('SAFeCustomFieldsEditorModel', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'ItemFormattedID', type:'string'},
			{name: 'ItemName', type:'string'},
			{name: 'ProjectName', type:'string'},
			{name: 'ReleaseName', type:'string'},
			{name: 'CustomFieldValue',  type: 'string'}
		]
	});
}());
                /** all dependencies are injected, it assumes nothing about the app its mixed into other than it has to derive from IntelRallyApp */
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	var RALLY_MAX_STRING_SIZE = 32768;
	
	Ext.define('RisksLib', {
		requires: ['IntelRallyApp'],
		
		_getRisks: function(portfolioItemRecord){
			var risks = portfolioItemRecord.data.c_Risks;
			try{ risks = JSON.parse(atob(risks)) || {}; } //b64 decode risks
			catch(e) { risks = {}; }
			return risks;
		},
		
		_removeRisk: function(portfolioItemRecord, riskData, projectRecord, risksParsedData){ 
			risksParsedData = risksParsedData || [];
			
			var me=this,
				risks = me._getRisks(portfolioItemRecord),
				projectOID = projectRecord.data.ObjectID,
				deferred = Q.defer();
				
			if(risks[projectOID]){
				delete risks[projectOID][riskData.RiskID];
				
				var indexToSplice = _.findIndex(risksParsedData, function(cachedRisk){ /** update cache */
					return cachedRisk.RiskID === riskData.RiskID && cachedRisk.PortfolioItemObjectID === riskData.PortfolioItemObjectID; 
				});
				if(indexToSplice > -1) risksParsedData.splice(indexToSplice, 1);
				
				var risksString = btoa(JSON.stringify(risks, null, '\t')); //b64 encode 
				if(risksString.length >= RALLY_MAX_STRING_SIZE) 
					deferred.reject('Risks field for ' + portfolioItemRecord.data.FormattedID + ' ran out of space! Cannot save');
				else {
					portfolioItemRecord.set('c_Risks', risksString);
					portfolioItemRecord.save({
						callback:function(record, operation, success){
							if(!success) 
								deferred.reject('Failed to modify ' + me.PortfolioItemTypes[0] + ': ' + portfolioItemRecord.data.FormattedID);
							else deferred.resolve();
						}
					});
				}
			} else deferred.resolve();		
			return deferred.promise;
		},	
		_addRisk: function(portfolioItemRecord, riskData, projectRecord, risksParsedData){
			risksParsedData = risksParsedData || [];
			
			var me=this,
				risks = me._getRisks(portfolioItemRecord),
				projectOID = projectRecord.data.ObjectID,
				deferred = Q.defer();

			riskData = Ext.clone(riskData);
			riskData.Edited = false;
			
			if(!risks[projectOID]) risks[projectOID] = {};
			risks[projectOID][riskData.RiskID] = {
				Checkpoint: riskData.Checkpoint,
				Description: riskData.Description,
				Impact: riskData.Impact,
				MitigationPlan: riskData.MitigationPlan,
				Urgency: riskData.Urgency,
				Status: riskData.Status,
				Contact: riskData.Contact
			};
			
			var indexToSplice = _.findIndex(risksParsedData, function(cachedRisk){ /** update cache */
				return cachedRisk.RiskID === riskData.RiskID && cachedRisk.PortfolioItemObjectID === riskData.PortfolioItemObjectID; 
			});
			if(indexToSplice > -1) risksParsedData.splice(indexToSplice, 1);
			risksParsedData.push(riskData);
			
			var risksString = btoa(JSON.stringify(risks, null, '\t'));
			if(risksString.length >= RALLY_MAX_STRING_SIZE)
				deferred.reject('Risks field for ' + portfolioItemRecord.data.FormattedID + ' ran out of space! Cannot save');
			else {
				portfolioItemRecord.set('c_Risks', risksString);
				portfolioItemRecord.save({
					callback:function(record, operation, success){
						if(!success) 
							deferred.reject('Failed to modify ' + me.PortfolioItemTypes[0] + ': ' + portfolioItemRecord.data.FormattedID);
						else deferred.resolve();
					}
				});
			}	
			return deferred.promise;
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('RiskSwimlane', {
		extend: 'IntelRallyApp',
		cls:'RiskSwimlaneApp',
		mixins:[
			'WindowListener',
			'PrettyAlert',
			'IframeResize',
			'IntelWorkweek',
			'AsyncQueue',
			'ParallelLoader',
			'RisksLib',
			'UserAppsPreference'
		],
		
		layout: {
			type:'vbox',
			align:'stretch',
			pack:'start'
		},
		items:[{
			xtype:'container',
			itemId:'navbox',
			layout: {
				type:'hbox',
				align:'stretch',
				pack:'start'
			},
			items:[{
				xtype:'container',
				flex:3,
				itemId:'navboxLeft',
				layout: 'hbox',
				items:[{
					xtype:'container',
					flex:1,
					itemId:'navboxLeftVert',
					layout: 'vbox'
				}]
			},{
				xtype:'container',
				flex:2,
				itemId:'navboxRight',
				layout: {
					type:'hbox',
					pack:'end'
				}
			}]
		}],
		minWidth:910,
		
		_userAppsPref: 'intel-SAFe-apps-preference',

		/**___________________________________ DATA STORE METHODS ___________________________________*/	
		_loadPortfolioItemsOfTypeInRelease: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: _loadPortfolioItemsOfTypeInRelease');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					disableMetaChangeEvent: true,
					remoteSort:false,
					fetch: ['Name', 'ObjectID', 'FormattedID', 'c_Risks', 'Release', 
						'Project', 'PlannedEndDate', 'Parent', 'PortfolioItemType', 'Ordinal'],
					filters:[{ property:'Release.Name', value:me.ReleaseRecord.data.Name}],
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store);
		},	
		_loadPortfolioItems: function(){ 
			var me=this, deferred = Q.defer();
			me._enqueue(function(done){
				Q.all(_.map(me.PortfolioItemTypes, function(type, ordinal){
					return (ordinal ? //only load lowest portfolioItems in Release (upper porfolioItems don't need to be in a release)
							me._loadPortfolioItemsOfType(me.TrainPortfolioProject, type) : 
							me._loadPortfolioItemsOfTypeInRelease(me.TrainPortfolioProject, type)
						)
						.then(function(portfolioStore){
							return {
								ordinal: ordinal,
								store: portfolioStore
							};
						});
					}))
					.then(function(items){
						var orderedPortfolioItemStores = _.sortBy(items, function(item){ return item.ordinal; });
						if(me.PortfolioItemStore) me.PortfolioItemStore.destroyStore(); //destroy old store, so it gets GCed
						me.PortfolioItemStore = orderedPortfolioItemStores[0].store;
						
						//make the mapping of lowest to highest portfolioItems
						me.PortfolioItemMap = {};
						_.each(me.PortfolioItemStore.getRange(), function(lowPortfolioItemRecord){ //create the portfolioItem mapping
							var ordinal = 0, 
								parentPortfolioItemRecord = lowPortfolioItemRecord,
								getParentRecord = function(child, parentList){
									return _.find(parentList, function(parent){ 
										return child.data.Parent && parent.data.ObjectID == child.data.Parent.ObjectID; 
									});
								};
							while(ordinal < (orderedPortfolioItemStores.length-1) && parentPortfolioItemRecord){
								parentPortfolioItemRecord = getParentRecord(parentPortfolioItemRecord, orderedPortfolioItemStores[ordinal+1].store.getRange());
								++ordinal;
							}
							if(ordinal === (orderedPortfolioItemStores.length-1) && parentPortfolioItemRecord) //has a mapping, so add it
								me.PortfolioItemMap[lowPortfolioItemRecord.data.ObjectID] = parentPortfolioItemRecord.data.Name;
						});
						
						//destroy the stores, so they get GCed
						orderedPortfolioItemStores.shift();
						while(orderedPortfolioItemStores.length) orderedPortfolioItemStores.shift().store.destroyStore();
					})
					.then(function(){ done(); deferred.resolve();})
					.fail(function(reason){ done(); deferred.reject(reason); })
					.done();
				}, 'PortfolioItemQueue');
			return deferred.promise;
		},		

		/**___________________________________ RISKS STUFF___________________________________**/
		_parseRisksFromPortfolioItem: function(portfolioItemRecord){
			var me=this,
				array = [], 
				risks = me._getRisks(portfolioItemRecord),
				PortfolioItemFormattedID = portfolioItemRecord.data.FormattedID,
				PortfolioItemName = portfolioItemRecord.data.Name;
				
			_.each(risks, function(risksData, projectID){
				_.each(risksData, function(riskData, riskID){
					array.push({
						_originalRiskData: Ext.merge({RiskID: riskID}, riskData),
						RiskID: riskID,
						Rank: 1,
						"PortfolioItem #": PortfolioItemFormattedID,
						"PortfolioItem Name": PortfolioItemName,
						"Project": (_.find(me.ProjectsWithTeamMembers, function(project){ return project.data.ObjectID == projectID; }) || {data: {}}).data.Name || '?',
						"Risk Description": riskData.Description,
						Impact: riskData.Impact,
						MitigationPlan: riskData.MitigationPlan || " ",
						Urgency: riskData.Urgency || 'Undefined',
						Status: riskData.Status,
						Contact: riskData.Contact,
						Checkpoint: 'ww' + me._getWorkweek(riskData.Checkpoint),
						updatable: true
					});
				});
			});
			return array;
		},	
		_parseRisksData: function(){ 
			var me=this, 
				array = [];
			_.each(me.PortfolioItemStore.getRecords(), function(portfolioItemRecord){
				array = array.concat(me._parseRisksFromPortfolioItem(portfolioItemRecord));
			});
			return array;
		},		
		_saveRisk: function(riskData){
			var me=this,
				data = Ext.clone(riskData)._originalRiskData,
				portfolioItem = _.find(me.PortfolioItemStore.getRange(), function(pi){ return pi.data.FormattedID == riskData['PortfolioItem #']; }),
				projectRecord = _.find(me.ProjectsWithTeamMembers, function(project){ return project.data.Name == riskData.Project; });
			data.Urgency = riskData.Urgency;
			data.Status = riskData.Status;
			me._addRisk(portfolioItem, data, projectRecord); 
		},
		
		/**___________________________________ LOADING AND RELOADING ___________________________________*/
		_showSwimlanes: function(){
			var me=this;
			if(!me.RisksSwimlanes) me._loadRisksSwimlanes();
		},	
		_updateSwimlanes: function(){
			var me=this;
			if(me.PortfolioItemStore){
				if(me.MatrixStore) me.MatrixStore.intelUpdate();
			}
		},
		_clearEverything: function(){
			var me=this;
			
			if(me.RiskSwimlanes) {
				document.getElementById('risk-swimlanes').remove(); //can't properly destroy this because there is a bug in column.destroy() code
				me.RiskSwimlanes = undefined;
			}	
		},
		_reloadStores: function(){
			var me=this;
			return me._loadPortfolioItems()
				.then(function(){
					me.Risks = me._parseRisksData();
				});
		},
		
		_reloadEverything: function(){
			var me=this;

			me.setLoading('Loading Data');
			me._enqueue(function(done){
				me._reloadStores()
					.then(function(){
						me._clearEverything();
						if(!me.ReleasePicker) me._loadReleasePicker();			
					})
					.then(function(){ me._updateSwimlanes(); })
					.then(function(){ me._showSwimlanes(); })
					.fail(function(reason){ me._alert('ERROR', reason); })
					.then(function(){ me.setLoading(false); done(); })
					.done();
			}, 'ReloadAndRefreshQueue'); //eliminate race conditions between manual _reloadEverything and interval _refreshDataFunc
		},

		/**___________________________________ LAUNCH ___________________________________*/	
		launch: function(){
			var me = this;
			me.setLoading('Loading configuration');
			me._initDisableResizeHandle();
			me._initFixRallyDashboard();
			if(!me.getContext().getPermissions().isProjectEditor(me.getContext().getProject())){
				me.setLoading(false);
				me._alert('ERROR', 'You do not have permissions to edit this project');
				return;
			}	
			me._configureIntelRallyApp()
				.then(function(){
					var scopeProject = me.getContext().getProject();
					return me._loadProject(scopeProject.ObjectID);
				})
				.then(function(scopeProjectRecord){
					me.ProjectRecord = scopeProjectRecord;
					return Q.all([ //3 streams
						me._projectInWhichTrain(me.ProjectRecord) /********* 1 ********/
							.then(function(trainRecord){
								if(trainRecord && me.ProjectRecord.data.ObjectID == trainRecord.data.ObjectID){
									me.TrainRecord = trainRecord;
									return me._loadTrainPortfolioProject(me.TrainRecord)
										.then(function(trainPortfolioProject){
											if(!trainPortfolioProject) return Q.reject('Invalid portfolio location');
											me.TrainPortfolioProject = trainPortfolioProject;
										});
								} 
								else return Q.reject('You are not scoped to a train');
							}),
						me._loadAppsPreference() /********* 2 ********/
							.then(function(appsPref){
								me.AppsPref = appsPref;
								var twelveWeeks = 1000*60*60*24*7*12;
								return me._loadReleasesAfterGivenDate(me.ProjectRecord, (new Date()*1 - twelveWeeks));
							})
							.then(function(releaseRecords){
								me.ReleaseRecords = releaseRecords;
								var currentRelease = me._getScopedRelease(releaseRecords, me.ProjectRecord.data.ObjectID, me.AppsPref);
								if(currentRelease) me.ReleaseRecord = currentRelease;
								else return Q.reject('This project has no releases.');
							}),
						me._loadProjectsWithTeamMembers() /********* 3 ************/
							.then(function(projectsWithTeamMembers){
								me.ProjectsWithTeamMembers = projectsWithTeamMembers;
								me.ProjectNames = _.map(projectsWithTeamMembers, function(project){ return {Name: project.data.Name}; });
							})
					]);
				})
				.then(function(){ 
					return me._reloadEverything(); 
				})
				.fail(function(reason){
					me.setLoading(false);
					me._alert('ERROR', reason || '');
				})
				.done();
		},
		
		/**___________________________________ NAVIGATION AND STATE ___________________________________*/
		_releasePickerSelected: function(combo, records){
			var me=this, pid = me.ProjectRecord.data.ObjectID;
			if(me.ReleaseRecord.data.Name === records[0].data.Name) return;
			me.setLoading("Saving Preference");
			me.ReleaseRecord = _.find(me.ReleaseRecords, function(rr){ return rr.data.Name == records[0].data.Name; });
			if(typeof me.AppsPref.projs[pid] !== 'object') me.AppsPref.projs[pid] = {};
			me.AppsPref.projs[pid].Release = me.ReleaseRecord.data.ObjectID;
			me._saveAppsPreference(me.AppsPref)
				.then(function(){ me._reloadEverything(); })
				.done();
		},				
		_loadReleasePicker: function(){
			var me=this;
			me.ReleasePicker = me.down('#navboxLeftVert').add({
				xtype:'intelreleasepicker',
				id: 'releasePicker',
				labelWidth: 70,
				width: 250,
				releases: me.ReleaseRecords,
				currentRelease: me.ReleaseRecord,
				listeners: { select: me._releasePickerSelected.bind(me) }
			});
		},	

		/************************************************************* RENDER ********************************************************************/
		_loadRisksSwimlanes: function(){
			var me = this, 
				customStore = Ext.create('Ext.data.Store', {	//need to add custom store to go along with the _queryForData override
					data: me.Risks,
					sorters: [{property: Rally.data.Ranker.RANK_FIELDS.MANUAL, direction: 'ASC'}],
					model: 'IntelSwimlaneRiskForTracking',
					proxy: {
						type:'sessionstorage',
						id:'Risk-Swimlane-' + (Math.random()*1000000>>0)
					},
					reloadRecord: function(record){ //because wsapi.Store has this apparently 
						if(typeof record === 'string') return Deft.Promise.when(this.getById(record));
						else return Deft.Promise.when(record); 
					} 
				});
			_.each(customStore.getRange(), function(model){ model.setProxy(model.store.proxy); });	//since we are overriding Ext.data.Model need to reset proxy
			
			me.RiskSwimlanes = me.add({
				xtype:'rallycardboard',
				id:'risk-swimlanes',
				models: [Ext.ClassManager.get('IntelSwimlaneRiskForTracking')],	//need to instantiate this
				plugins: [{
					ptype: 'rallyscrollablecardboard',
					containerEl: this.getEl()
				},{
					ptype: 'rallyfixedheadercardboard'
				}],
				shouldRetrieveModels: function(){ return false; },							//override private function
				addRow: function(item, applySort) {															//override private function
					var value = item.isModel ? item.getData() : item;
					return this._createRow({showHeader: true, value: item.Urgency}, applySort);
        },
				_refreshAssociatedCards: function(record, changedFields) {			//this has to be overriden because it called getAssociatedRefs()
					this.refreshCard(record.getId());
        },
				attribute: 'Status',
				enableRanking:true, //if we set this to false, there is a bug in ColumnDropTarget.notifyOver where it indexes into cards[] wrong
				cardConfig: {
					xtype: 'rallycard',
					fields: ['PortfolioItem #', 'PortfolioItem Name', 'Project', 'Contact', 'Checkpoint', 'Risk Description', 'Impact', 'MitigationPlan'],
					showGearIcon: false
				},
				rowConfig: {
					field: 'Urgency',
					values: ['1-Hot', '2-Watch', '3-Simmer', 'Undefined'],
					enableCrossRowDragging: true
				},
				store: customStore,
				columns: _.map(['Undefined', 'Resolved', 'Owned', 'Accepted', 'Mitigated'], function(status){
					return {
						xtype: 'rallycardboardcolumn',
						value: status,
						columnHeaderConfig: { headerTpl: status},
						_queryForData: function() {		//override private function so board doesn't use storeConfig, but the passed in store object instead
							var me=this;
							this.store = this.ownerCardboard.store;
							this.fireEvent('storeload', this.store, this.store.getRange(), true);
							setTimeout(function(){ me._createAndAddCardsFromStore(me.store); }, 100);	//setting the timeout allows the board to render (avoids errors)
            }
					};
				}),
				listeners: {
					cardupdated: function(card){
						var cardID = card.record.data.RiskID;
						if(window[cardID]) return; //throttle the saving. this gets called 2 consecutive times per d-n-d
						else {
							window[cardID] = true;
							setTimeout(function(){ window[cardID] = false; }, 100);
							me._saveRisk(card.record.data);
						}
					}
				}
			});	
		}
	});
}());

            Rally.launchApp('RiskSwimlane', {
                name:"Risk Swimlane",
	            parentRepos:""
            });

        });
    </script>


    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"/>

    <style type="text/css">
        .x-grid-cell.intel-editor-cell *,
.x4-grid-cell.intel-editor-cell *,
.intel-editor-cell {
  cursor: pointer !important;
}
.fa.fa-md {
  font-size: 1.05rem;
  line-height: .75em;
  vertical-align: -15%;
}

    </style>

    <style type="text/css">
        .x-grid-cell.manager-expected-cell {
  background-image: -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 30px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-cell-small {
  background-image: -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-RED,
.x-grid-row-over .x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREEN,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(183, 183, 183, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREY,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(183, 183, 183, 0.7) !important;
}

    </style>

    <style type="text/css">
        .moscow-cell {
  padding-left: 20px;
}
.must-have {
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-image: -ms-linear-gradient(rleft, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-image: linear-gradient(to left, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-size: 100% 20px;
  background-repeat: repeat-y;
}
.should-have {
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-image: -ms-linear-gradient(rleft, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-image: linear-gradient(to left, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-size: 100% 20px;
  background-repeat: repeat-y;
}
.could-have {
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-image: -ms-linear-gradient(rleft, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-image: linear-gradient(to left, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-size: 100% 20px;
  background-repeat: repeat-y;
}
.wont-have {
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-image: -ms-linear-gradient(rleft, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-image: linear-gradient(to left, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-size: 100% 20px;
  background-repeat: repeat-y;
}

    </style>

    <style type="text/css">
        /************************************************ NAVBAR/CONTAINERS *****************************************/
#navbar {
  padding: 0 10px 10px 10px;
}
#releasePicker {
  margin: 4px 0 0 0;
}
/************************************************ RISK SWIMLANE STUFF *****************************************/
.RiskSwimlaneApp,
.RiskSwimlaneApp > div,
.RiskSwimlaneApp > div > div {
  height: 100%;
}
.rui-card .rui-card-right-side {
  display: none;
}
.rui-card .rui-field-label {
  font-weight: bold;
}
.rui-card .rui-field-value {
  display: inline !important;
}

    </style>
</head>
<body>
</body>
</html>
