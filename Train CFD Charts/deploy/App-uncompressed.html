<!DOCTYPE html>
<html>
<head>
    <title>TrainCFDCharts</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** this is used if you want to listen to events in the parent window (e.g. useful for rally apps that resize with browser screen
		vertically or things that need to know browser scroll position) */

Ext.define('WindowListener', {

	__initWindowEventListener: function(eventName){
		var me=this;
		if(!me._windowListeners) me._windowListeners = {};
		me._windowListeners[eventName] = [];
		
		window.parent['on' + eventName] = function(event){ 
			var listeners = me._windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i)
				listeners[i](event);
		};
	},
	
	_addWindowEventListener: function(eventName, fn){
		var me=this;
		if(!me._windowListeners || !me._windowListeners[eventName]) 
			me.__initWindowEventListener(eventName);
		me._windowListeners[eventName].push(fn);
	},
	
	_fireParentWindowEvent: function(eventName){
		var me=this;
		if(!me._windowListeners || !me._windowListeners[eventName]) return;
		var listeners = me._windowListeners[eventName];
		for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
	}
});
                /** resizes the iframe to be a little bigger than the inner contents, so theres no ugly double vertical scroll bar **/

Ext.define('IframeResize', {
	requires: ['WindowListener'],
	
	/** resizes the iframe to be the height of all the items in it, with 20 px padding in between + 50 px; */
	__applyIframeResize: function(){ 
		var w = window, p = w.parent, pd = w.parent.document, l = w.location,
			iframe = pd.querySelector('iframe[src="' + l.pathname + l.search + '"]'),
			ip1 = iframe.parentNode,
			ip2 = iframe.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode, //this is apparently the one that matters
			height = 0, next = this.down();
		while(next){
			height += next.getHeight() + next.getEl().getMargin('t')*1 + next.getEl().getMargin('b')*1;
			next = next.next();
		}
		height += 50;
		ip1.style.height = height + 'px';
		ip2.style.height = height + 'px';
		iframe.style.height = height + 'px';
	},
	
	_initIframeResize: function(){
		var me=this;
		if(me._addWindowEventListener){
			me._addWindowEventListener('resize', function(){ me.__applyIframeResize(); });
		}
	}
});
                /**  
	THIS IS ONLY USEFUL AS A RALLYAPP MIXIN 
	gives a window-centered alert or confirm dialog box that isn't ugly. 
*/
Ext.define('PrettyAlert', { 
	requires:['WindowListener'],
	
	_alert: function(title, str){
		Ext.MessageBox.alert(title || '', str || '').setY(this.__msgBoxY);
		setTimeout(function(){ //give some time to give the 'ok' or 'yes' button focus
			var x = Ext.MessageBox.down('button');
			while(x.isHidden()) x = x.nextSibling();
			x.focus();
		}, 20);
	},
	
	_confirm: function(title, str, fn){
		Ext.MessageBox.confirm(title || '', str || '', fn || function(){}).setY(this.__msgBoxY);
		setTimeout(function(){
			var x = Ext.MessageBox.down('button');
			while(x.isHidden()) x = x.nextSibling();
			x.focus();
		}, 20);
	},
	

	__applyMessageBoxConfig: function(){ 
		var w = window, p = w.parent, pd = w.parent.document, l = w.location,
			iframe = pd.querySelector('iframe[src="' + l.pathname + l.search + '"]');
		
		var ph = p.getWindowHeight(), 
			ps = p.getScrollY(), 
			ofy = ps + iframe.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
			iyOffset = Math.floor(ph/2 - ofy + ps - 50);
		this.__msgBoxY = iyOffset<0 ? 0 : iyOffset;
	},
	
	/** CALL THIS IN LAUNCH FUNCTION! **/
	_initPrettyAlert: function(){
		var me=this;
		if(me._addWindowEventListener){
			me._addWindowEventListener('resize', function(){ me.__applyMessageBoxConfig(); });
			me._addWindowEventListener('scroll', function(){ me.__applyMessageBoxConfig(); });
		}
	}
});
                Ext.define('IntelWorkweek', {
	
	/** calculates intel workweek, returns integer */
	_getWorkweek: function(date){ 
		var oneDay = 1000 * 60 * 60 * 24,
			yearStart = new Date(date.getFullYear(), 0, 1),
			dayIndex = yearStart.getDay(),
			ww01Start = yearStart - dayIndex*oneDay,
			timeDiff = date - ww01Start,
			dayDiff = timeDiff / oneDay,
			ww = Math.floor(dayDiff/7) + 1,
			leap = (date.getFullYear() % 4 === 0),
			weekCount = ((leap && dayIndex >= 5) || (!leap && dayIndex === 6 )) ? 53 : 52; //weeks in this year
		return weekCount < ww ? 1 : ww;
	},
	
	/** returns the number of intel workweeks in the year the date is in */
	_getWeekCount: function(date){ 
		var leap = (date.getFullYear() % 4 === 0),
			day = new Date(date.getFullYear(), 0, 1).getDay();
		return ((leap && day >= 5) || (!leap && day === 6 )) ? 53 : 52;
	},
	
	/**  gets list of workweeks between startDate and endDate (startDate and endDate dont have to be Date objects)  */
	_getWorkweeks: function(startDate, endDate){ 
		var i,
			sd_week = this._getWorkweek(startDate),
			ed_week = this._getWorkweek(endDate),
			week_count = this._getWeekCount(startDate);
			
		var weeks = [];
		if(ed_week < sd_week){
			for(i=sd_week; i<=week_count; ++i) weeks.push('ww' + i);
			for(i = 1; i<=ed_week;++i) weeks.push('ww' + i);
		}
		else for(i = sd_week; i<=ed_week;++i) weeks.push('ww' + i);
		return weeks;
	}
});
                /** Mixin functions related to queries, you need to require Q as a dependency in your rally app
	Q can be found here: https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js
	most functions return promises that resolve to stores
*/

Ext.define('ReleaseQuery', {
		
	/** gets releases for this project that have release date >= now. returns promise that resolves to the releaseStore */
	_loadReleasesInTheFuture: function(projectRecord){
		var deferred = Q.defer();
		Ext.create('Rally.data.wsapi.Store',{
			model: 'Release',
			limit:Infinity,
			autoLoad:true,
			fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
			context:{
				workspace: this.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'Project.ObjectID',
					value: projectRecord.data.ObjectID
				},{
					property:'ReleaseDate',
					operator:'>=',
					value: new Date().toISOString()
				}
			],
			listeners: {
				load: {
					fn: function(releaseStore, releaseRecords){
						console.log('releases loaded:', releaseRecords);
						deferred.resolve(releaseStore);
					},
					single:true
				}
			}
		});
		return deferred.promise;
	},
	
	/** loads this release for each scrum under this train. returns promise with the release Store 
		the scrums that the releases belong to will have at least 1 team member, and the train's release is not included
		in the results.
	**/
	_loadReleasesWithName: function(releaseName, trainName){ 
		var deferred = Q.defer();
		Ext.create('Rally.data.wsapi.Store',{
			model: 'Release',
			limit:Infinity,
			autoLoad:true,
			fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
			context:{
				workspace: this.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'Name', //match the release
					value: releaseName
				},{
					property:'Project.Name', //is a child of the train
					operator:'contains',
					value:trainName
				},{
					property:'Project.Children.Name', //has teamMembers 
					operator:'=',
					value:''
				},{
					property:'Project.Name', //but not the train release itsself
					operator:'!contains',
					value:' ART'
				}
			],
			listeners: {
				load: {
					fn: function(store, records){
						console.log('releasesWithName loaded:', records);
						deferred.resolve(store);
					},
					single:true
				}
			}
		});
		return deferred.promise;
	},
	
	/** gets the most likely release to scope to base on the following order:
		1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
						to use preferences for this one)
		2) if we are in a release
		3) the closest release planning date to the current date
	*/
	_getScopedRelease: function(releaseRecords, projectOID, appPrefs){
		var me=this,
			d = new Date(),
			rs = releaseRecords,
			prefOID = appPrefs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
		return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
			_.find(rs, function(r){
				return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
			}) ||
			_.reduce(rs, function(best, r){
				if(best===null) return r;
				else {
					var d1 = new Date(best.data.ReleaseStartDate), d2 = new Date(r.data.ReleaseStartDate), now = new Date();
					return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
				}
			}, null);
	}
});
                /** Fast CFD Calculator is like 1000x faster than the rally build in calculators because this is not a generic 
	calculator. it specifically is used to aggregate items with PlanEstimate and ScheduleState fields, in an area chart
	between two dates. Example app using this is Train CFD Charts */
	
Ext.define("FastCfdCalculator", {
	extend:'Rally.data.lookback.SnapshotStore',
	
	scheduleStates: ['Undefined', 'Defined', 'In-Progress', 'Completed', 'Accepted'],
	
	constructor: function() { //you MUST give this calculator startDate, and endDate. That is all it needs
		this.callParent(arguments);
	},
	
	_getDates:function(){
		var dates = [], curDay = this.startDate, day=1000*60*60*24;
		while(curDay<=this.endDate){
			var n = curDay.getDay(); 
			if(n!==0 && n!==6) dates.push(curDay); //dont get weekends
			curDay = new Date(curDay*1 + day);
		}
		return dates;
	},
	
	_dateToStringDisplay: function (date) {
		return Ext.Date.format(date, 'm/d/Y');
	},
	
	_getIndexHelper:function(d,ds){ //binsearches for the closest date to d
		var curVal = (ds.length/2), curInt = (curVal>>0), div=(curVal/2), lastInt=-1;
		while(curInt !== lastInt){
			if(ds[curInt]===d) return curInt;
			else if(ds[curInt]>d) curVal-=div;
			else curVal+=div;
			div/=2;
			lastInt = curInt;
			curInt = curVal>>0;
		}
		return curInt;
	},
	
	_getIndexOnOrBefore: function(d, ds){
		if(ds.length===0) return -1;
		var pos = this._getIndexHelper(d,ds);
		if(pos===0) { if(ds[pos] <= d) return pos; else return -1; } //either start of list or everything is after d
		else if(ds[pos] <= d) return pos;
		else return pos-1;
	},
	
	_getIndexOnOrAfter: function(d, ds){
		if(ds.length===0) return -1;
		var pos = this._getIndexHelper(d,ds);
		if(pos===ds.length-1) { if(ds[pos] >= d) return pos; else return -1; } //either start of list or everything is after d
		else if(ds[pos] >= d) return pos;
		else return pos+1;
	},
	
	runCalculation:function(items){
		if(!this.scheduleStates || !this.startDate || !this.endDate) {
			console.log('invalid constructor config', this); return; }
		var dates = this._getDates(), day=1000*3600*24,
			dateMapTemplate = _.map(new Array(dates.length), function(){ return 0;}); 
		var totals = _.reduce(this.scheduleStates, function(map, ss){ 
			map[ss] = dateMapTemplate.slice();
			return map; 
		}, {});
		for(var itemIndex=0, len=items.length; itemIndex<len; ++itemIndex){
			var item = items[itemIndex].raw, //dont work with records;
				iStart = new Date(item._ValidFrom),
				iEnd = new Date(item._ValidTo), 
				state = item.ScheduleState, 
				pe = item.PlanEstimate;
			if(!pe || ((iStart/day>>0) === (iEnd/day>>0))) continue; //no need to continue with this one
			var startIndex = this._getIndexOnOrAfter(iStart, dates), 
				endIndex = this._getIndexOnOrBefore(iEnd, dates);
			if(startIndex===-1 || endIndex===-1) continue; //no need to continue here
			for(var i=startIndex;i<=endIndex;++i)
				totals[state][i]+=pe;
		}
		return {
			categories:_.map(dates, function(d){ return this._dateToStringDisplay(d); }, this), 
			series: _.reduce(this.scheduleStates, function(ar, ss){
				return ar.concat([{name:ss, type:'area', dashStyle:'Solid', data:totals[ss]}]);
			}, [])
		};
	}
});
                /** updates the chart data. the following boolean options exist:
	noDatemap: to NOT set window.Datemap to allow for a tooltip mapping of points to non-workweek dates
	noTrends: to NOT show ideal tredn
	*/
Ext.define('ChartUpdater', {
	requires:['IntelWorkweek'],
	
	__tooltipfunc: function () {
		return "<b>100% Complete</b><br />" + 
			"<b>" + this.x + '</b> (' + window.Datemap[this.point.x] + ")";
	},
	
	_updateChartData: function(data, opts){
		var me = this, now = new Date();
		if(!opts || !opts.noDatemap) window.Datemap = []; //for the tooltip to have extra info to display on the chart

		//get ideal trendline
		var total = (new Date(data.categories[0]) > now ? 0 : 
				_.reduce(data.series, function(sum, s){return sum + (s.data[s.data.length-1] || 0); }, 0) || 0),
			idealTrend, ratio;
			
		if(!opts || !opts.noTrends){
			idealTrend = {type:'spline', dashStyle:'Solid', name:'Ideal', data:new Array(data.categories.length)};
			ratio = (total/(data.categories.length-1)) || 0; //for NaN
			idealTrend.data = _.map(idealTrend.data, function(e, i){ return Math.round(100*(0 + i*ratio))/100; });
		}
		
		//zero future points, convert to workweeks, and set window.Datemap
		_.each(data.categories, function(c, i, a){
			var d = new Date(c);
			a[i] = 'WW' + me._getWorkweek(d);
			if(!opts || !opts.noDatemap) window.Datemap[i] = c;
			if(d>now){
				_.each(data.series, function(s, j){
					s.data = s.data.slice(0, i).concat(_.map(new Array(a.length - i), function(){ return 0; }));
				});
			}
		});

		if(!opts || !opts.noTrends){
			//get projected trendline
			var s = _.find(data.series, function(s){ return s.name === 'Accepted'; }), i, len,
				projectedTrend = {type:'spline', dashStyle:'Solid', name:'Projected', data:s.data.slice()},
				begin=0, end=projectedTrend.data.length-1;
			for(i=1;i<projectedTrend.data.length;++i)
				if(projectedTrend.data[i]!==null && projectedTrend.data[i] !==0){
					begin = i-1; break; }
			for(i=end;i>=begin;--i) //start at the END, not at begin+1 (remember ISSG_binsplit bug)
				if(projectedTrend.data[i]!==0){
					end = i; break; }
			ratio = end===begin ? 0 : (projectedTrend.data[end] - 0)/(end-begin);
			projectedTrend.data = _.map(projectedTrend.data, function(p, j){ 
				if(j>=begin) return Math.round(100*(0 + (j-begin)*ratio))/100;
				else return p; 
			});

			//apply label to correct point if needed IGNORE FIRST POINT!
			for(i=1,len=projectedTrend.data.length; i<len;++i){
				if(projectedTrend.data[i] >= total){
					projectedTrend.data[i] = {
						// dataLabels: {
							// enabled: true,
							// backgroundColor:'white',
							// borderColor:'black',
							// borderRadius:3,
							// borderWidth:1,
							// formatter: me.__tooltipfunc,
							// align:((len-i)/len > 0.75) 'center', y:-25
						// },
						color:'red',
						marker:{
							enabled:true,
							lineWidth:4,
							symbol:'circle',
							fillColor:'red',
							lineColor:'red'
						},
						y: projectedTrend.data[i]
					};
					break;
				}	
			}
			data.series.push(projectedTrend);
			data.series.push(idealTrend);
		}
		
		return data;
	}
});
                /************************** PRODUCTION *****************************/
console = { log: function(){} };	////DEBUG!!!	
preferenceName = 'intel-ART-CFD';

/****************************************************************/

Ext.define('TrainCfdCharts', {
	extend: 'Rally.app.App',
	requires:[
		'FastCfdCalculator'
	],
	mixins:[
		'WindowListener',
		'PrettyAlert',
		'IframeResize',
		'IntelWorkweek',
		'ReleaseQuery',
		'ChartUpdater'
	],
	minWidth:910,
	
	/****************************************************** SOME CONFIG CONSTANTS *******************************************************/
	_chartColors: ['#ABABAB', '#E57E3A', '#E5D038', '#0080FF', '#3A874F', '#000000','#26FF00'],
	
	_defaultChartConfig: {
		chart: {
			defaultSeriesType: "area",
			zoomType: "xy"
		},
		xAxis: {
			tickmarkPlacement: "on",
			title: {
				text: "Days",
				margin: 10
			},
			labels: {
				y: 20
			}
		},
		yAxis: {
			title: {
				text: "Points"
			},
			labels: {
				x: -5,
				y: 4
			}
		},
		tooltip: {
			formatter: function () {
				return "<b>" + this.x + '</b> (' + window.Datemap[this.point.x] + ")<br />" + this.series.name + ": " + this.y;
			}
		},
		plotOptions: {
			series: {
				marker: {
					enabled: false,
					states: {
						hover: {
							enabled: true
						}
					}
				},
				groupPadding: 0.01
			},
			area: {
				stacking: 'normal',
				lineColor: '#666666',
				lineWidth: 2,
				marker: {
					enabled: false
				}
			}
		}
	},
	
	_getConfiguredChartTicks: function (startDate, endDate, width) {
		var pixelTickWidth = 40,
			ticks = Math.floor(width / pixelTickWidth);
		var days = Math.floor((endDate*1 - startDate*1) / (86400000*5/7)); //only workdays
		var interval = Math.floor(Math.floor(days / ticks) / 5) * 5;
		if(interval < 5) return 5; //make it weekly at the minimum
		else return interval;
	},
	
	/****************************************************** DATA STORE METHODS ********************************************************/

	_loadModels: function(cb){
		Rally.data.ModelFactory.getModel({ //load project
			type:'Project',
			scope:this,
			success: function(model){ 
				this.Project = model; 
				cb(); 
			}
		});
	},
	
	_loadProject: function(project, cb){ //callback(project) project IS NOT a projectRecord
		var me = this;
		me.Project.load(project.ObjectID, {
			fetch: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name'],
			context: {
				workspace: me.getContext().getWorkspace()._ref,
				project: null
			},
			callback: function(record, operation){
				if(operation.wasSuccessful()) cb(record);
				else {
					me._alert('ERROR', 'failed to retreive project: ' + project.ObjectID);
					cb();
				}
			}
		});
	},

	_loadSnapshotStores: function(){
		var me = this, 
			promises = [];		
		me.AllSnapshots = [];
		me.TeamStores = {};
		me.ReleasesWithName.forEach(function(releaseRecord){
			var deferred = Q.defer();
			promises.push(deferred.promise);
			Ext.create('Rally.data.lookback.SnapshotStore', {
				autoLoad:true,
				limit: Infinity,
				context:{ 
					workspace: me.getContext().getWorkspace()._ref,
					project: null
				},
				sort:{_ValidFrom:1},
				compress:true,
				find: { 
					_TypeHierarchy:-51038, 
					Children:null,
					PlanEstimate: {$gte:0},
					Release: releaseRecord.get('ObjectID')
				},
				fetch:['ScheduleState', 'PlanEstimate'],
				hydrate:['ScheduleState', 'PlanEstimate'],
				listeners: {
					load: function(store, records){
						if(records.length > 0){
							me.TeamStores[releaseRecord.data.Project.Name] = records;
							me.AllSnapshots = me.AllSnapshots.concat(records);
						}
						deferred.resolve();
					},
					single:true
				}
			});
		});
		return Q.all(promises).then(function(){ 
			console.log('all snapshots done', me.AllSnapshots, me.TeamStores);
		});
	},
			
	_loadAllChildReleases: function(){ 
		var me = this,
			releaseName = me.ReleaseRecord.data.Name,
			trainName = me.TrainRecord.data.Name.split(' ART')[0];			
		return me._loadReleasesWithName(releaseName, trainName)
			.then(function(releaseStore){
				me.ReleasesWithName = releaseStore.getRange();
			});
	},
	
	/************************************************** Preferences FUNCTIONS ***************************************************/
	
	_loadPreferences: function(cb){ //parse all settings too
		var me = this,uid = me.getContext().getUser().ObjectID;
		Rally.data.PreferenceManager.load({
			appID: me.getAppId(),
      filterByName:preferenceName+ uid,
			success: function(prefs) {
				prefs = prefs[preferenceName + uid];
				try{ prefs = JSON.parse(prefs); }
				catch(e){ prefs = {projs: {}}; }
				me.AppPrefs = prefs;
				console.log('loaded prefs', prefs);
        cb();
			}
		});
	},

	_savePreferences: function(prefs, cb){ // stringify and save only the updated settings
		var me = this, s = {}, uid = me.getContext().getUser().ObjectID;
		prefs = {projs: prefs.projs};
    s[preferenceName + uid] = JSON.stringify(prefs);
    console.log('saving prefs', prefs);
		Rally.data.PreferenceManager.update({
			appID: me.getAppId(),
			settings: s,
			success: cb,
			scope:me
		});
	},
	
	/*************************************************** RANDOM HELPERS ******************************************************/	
	_projectInWhichTrain: function(projectRecord, cb){ // returns train the projectRecord is in, otherwise null.
		var me = this;
		if(!projectRecord) cb();
		var split = projectRecord.data.Name.split(' ART');
		if(split.length>1) cb(projectRecord);
		else { 
			var parent = projectRecord.data.Parent;
			if(!parent) cb();
			else {
				me._loadProject(parent, function(parentRecord){
					me._projectInWhichTrain(parentRecord, cb);
				});
			}
		}
	},

	/******************************************************* LAUNCH ********************************************************/
		
	_resizeWhenRendered: function(){
		var me = this;
		setTimeout(function(){ 
			me._fireParentWindowEvent('resize');
		}, 0);
	},
	
	_reloadEverything:function(){
		var me=this;
		me.setLoading(true);		
		me._loadAllChildReleases().then(function(){
			me._loadSnapshotStores().then(function(){
				me.removeAll();
				me.setLoading(false);
				me._renderReleasePicker();
				me._renderCharts(); 
			});
		});
	},
	
	_loadReleases: function(){
		var me=this;
		me._loadReleasesInTheFuture(me.TrainRecord).then(function(releaseStore){
			me.ReleaseStore = releaseStore;
			var currentRelease = me._getScopedRelease(me.ReleaseStore.getRange(), me.TrainRecord.data.ObjectID, me.AppPrefs);
			if(currentRelease){
				me.ReleaseRecord = currentRelease;
				console.log('release loaded', currentRelease);
				me._reloadEverything();
			} else {
				me.setLoading(false);
				me._alert('ERROR', 'This ART has no valid releases');
			}
		});
	},

	launch: function(){
		var me = this;
		me._initPrettyAlert();
		me._initIframeResize();	
		me.setLoading(true);
		if (Rally && Rally.sdk && Rally.sdk.dependencies && Rally.sdk.dependencies.Analytics) {
			Rally.sdk.dependencies.Analytics.load(function(){	
				me._loadPreferences(function(){
					me._loadModels(function(){
						var scopeProject = me.getContext().getProject();
						me._loadProject(scopeProject, function(scopeProjectRecord){
							me._projectInWhichTrain(scopeProjectRecord, function(trainRecord){
								if(trainRecord){
									me.TrainRecord = trainRecord; 
									console.log('train loaded:', trainRecord);
									me._loadReleases();
								} else {
									me.removeAll();
									me._alert('ERROR', 'Project "' + scopeProject.Name + '" not a train or sub-project of train');
								}
							});
						});
					});
				});
			});
		}
	},
	
	
	/******************************************************* RENDERING CHARTS ********************************************************/

	_renderReleasePicker: function(){
		var me=this;
		me.ReleasePicker = me.add({
			xtype:'combobox',
			margin:'0 0 10 0',
			store: Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(me.ReleaseStore.getRecords(), function(r){ return {Name: r.get('Name') }; })
			}),
			displayField: 'Name',
			fieldLabel: 'Release:',
			editable:false,
			value:me.ReleaseRecord.get('Name'),
			listeners: {
				select: function(combo, records){
					if(me.ReleaseRecord.get('Name') === records[0].get('Name')) return;
					me.ReleaseRecord = me.ReleaseStore.findExactRecord('Name', records[0].get('Name'));
					var pid = me.TrainRecord.data.ObjectID;
					if(!me.AppPrefs.projs[pid]) me.AppPrefs.projs[pid] = {};
					me.AppPrefs.projs[pid].Release = me.ReleaseRecord.data.ObjectID;
					me._savePreferences(me.AppPrefs, function(){ me._reloadEverything(); });					
				}, 
				focus: function(combo){ combo.expand(); }
			}
		});
	},
	
  _renderCharts: function(){
		var me = this;
		
		if(me.AllSnapshots.length === 0){
			me._alert('ERROR', me.TrainRecord.data.Name + ' has no data for release: ' + me.ReleaseRecord.data.Name);
			return;
		}
		
		/************************************** CHART STUFF *********************************************/
		me.panel = me.add({
			xtype: 'container',
			layout: 'column',
			width:'100%'
		});	
		me.trainPanel = me.panel.add({	
			xtype: 'container',
			layout: 'column',
			columnWidth:1
		});
	
		var calc = Ext.create('FastCfdCalculator', {
			startDate: me.ReleaseRecord.get('ReleaseStartDate'),
			endDate: me.ReleaseRecord.get('ReleaseDate')
		});
		
		me.trainPanel.add({
			xtype:'panel',
			html:'',
			columnWidth:0.16
		});
		me.trainPanel.add({
			xtype:'rallychart',
			columnWidth:0.66,
			loadMask:false,
			chartColors:me._chartColors,
			chartData: me._updateChartData(calc.runCalculation(me.AllSnapshots)),
			chartConfig: Ext.Object.merge({
				chart: {
					height:400
				},
				legend:{
					borderWidth:0,
					width:500,
					itemWidth:100
				},
				title: {
					text: me.TrainRecord.get('Name')
				},
				subtitle:{
					text: me.ReleaseRecord.get('Name')
				},
				xAxis:{
					tickInterval: me._getConfiguredChartTicks(
						me.ReleaseRecord.get('ReleaseStartDate'), me.ReleaseRecord.get('ReleaseDate'), me.getWidth()*0.66)
				}
			}, me._defaultChartConfig),
			listeners:{
				afterrender: me._resizeWhenRendered.bind(me)
			}
		});
		me.trainPanel.add({
			xtype:'panel',
			html:'',
			columnWidth:0.16
		});	
		
		/************************************** Scrum CHARTS STUFF *********************************************/	
		for(var projectName in me.TeamStores){
			me.panel.add({
				xtype:'rallychart',
				columnWidth:0.32,
				loadMask:false,
				height:360,
				padding:"20px 0 0 0",
				chartColors:me._chartColors,
				chartData: me._updateChartData(calc.runCalculation(me.TeamStores[projectName]), {noDatemap:true}),
				chartConfig: Ext.Object.merge({
					chart: {
						height:300
					},
					legend: {
						enabled: false
					},
					title: {
						text: null
					},
					subtitle:{
						text: projectName
					},
					xAxis: {
						tickInterval: me._getConfiguredChartTicks(
							me.ReleaseRecord.get('ReleaseStartDate'), me.ReleaseRecord.get('ReleaseDate'), me.getWidth()*0.32)
					}
				}, me._defaultChartConfig),
				listeners:{
					afterrender: me._resizeWhenRendered.bind(me)
				}
			});
		}
	}
});


            Rally.launchApp('TrainCfdCharts', {
                name:"TrainCFDCharts",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
  /* Add app styles here */
}

    </style>
</head>
<body>
</body>
</html>
