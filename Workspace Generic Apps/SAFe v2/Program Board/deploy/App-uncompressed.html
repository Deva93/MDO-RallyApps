<!DOCTYPE html>
<html>
<head>
    <title>Program Board</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** this extends Rally.app.app. if you want to use it's utility functions, just
		extend IntelRallyApp instead of Rally.app.App
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('IntelRallyApp', {
		alias: 'widget.intelrallyapp',
		extend: 'Rally.app.App',
		
		_TrainConfigPrefName: 'intel-train-config', //preference to store train config for workspace
		
		_projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
		_portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'c_TeamCommits', 'c_MoSCoW', 'Release',
			'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal'],
		_userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
			'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
		_releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
		
		/********************************************** APP CONFIGURATION **************************************/
		_loadScheduleStates: function(){ 
			var me=this, deferred = Q.defer();
			Rally.data.ModelFactory.getModel({
				type: 'UserStory',
				success: function(model) {
					model.getField('ScheduleState').getAllowedValueStore().load({
						callback: function(records, operation, success) {
							me.ScheduleStates = _.map(records, function(r){ return r.data.StringValue; });
							deferred.resolve();
						}
					});
				}
			});
			return deferred.promise;
		},
		_loadPortfolioItemStatesForEachType: function(){ 
			var me=this;
			me.PortfolioItemTypeStates = [];
			return Q.all(_.map(me.PortfolioItemTypes, function(portfolioType, ordinal){
				var store = Ext.create('Rally.data.wsapi.Store', {
					model: 'State',
					autoLoad:false,
					limit:Infinity,
					fetch:['Name', 'Enabled', 'OrderIndex'],
					filters: [{
						property: 'TypeDef.Name',
						value: portfolioType
					},{
						property: 'Enabled',
						value: true
					}]
				});
				return me._reloadStore(store).then(function(store){
					me.PortfolioItemTypeStates[ordinal] = store.getRange();
				});
			}));
		},
		_loadPortfolioItemTypes: function(){ 
			/** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
			var me=this,
				deferred = Q.defer(),
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'TypeDefinition',
					autoLoad:true,
					limit:Infinity,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					listeners:{
						load:function(portfolioTypeStore){
							me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(), 
								function(item){ return {Name: item.data.Name, Ordinal: item.data.Ordinal}; }),
								function(item){ return item.Ordinal; }),
								function(item){ return item.Name; });
							deferred.resolve();
						}
					}
				});
			return deferred.promise;
		},
		_loadModels: function(){ 
			/** loads models for project, userstories, and all the portfolio items */
			var me=this, 
				promises = [],
				models = {
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					PortfolioItem: 'PortfolioItem'
				};
			_.each(me.PortfolioItemTypes, function(name){ models[name] = 'PortfolioItem/' + name; });
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},
		_loadTrainConfig: function(){
			/** me.TrainConfig is an array of these objects: 
				{
					TrainProjectOID: configItem.TrainProjectOID || 0,
					TrainName: configItem.TrainName || '',
					TrainAndPortfolioLocationTheSame: configItem.TrainAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._TrainConfigPrefName,
				success: function(prefs) {
					var workspaceConfigString = prefs[me._TrainConfigPrefName], trainConfig;
					try{ trainConfig = JSON.parse(workspaceConfigString); }
					catch(e){ trainConfig = []; }
					me.TrainConfig = trainConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveTrainConfig: function(trainConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[me._TrainConfigPrefName] = JSON.stringify(trainConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._TrainConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_configureIntelRallyApp: function(){
			var me=this;
			return Q.all([
				me._loadPortfolioItemTypes().then(function(){ 
					return Q.all([
						me._loadModels(),
						me._loadPortfolioItemStatesForEachType()
					]);
				}),
				me._loadTrainConfig(),
				me._loadScheduleStates()
			]);
		},
				
		/**************************** Generic store loading with Q wrapper, returns promise *************************************/		
		_reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		},
		
		/********************************************** LOADING SINGLE MODELS **************************************/	
		_loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LP');
			else if(!me.Project) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.Project.load(oid, {
					fetch: me._projectFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadUserStory: function(oid, projectRecord){
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LUS');
			else if(!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.UserStory.load(oid, {
					fetch: me._userStoryFields,
					context: {
						workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
						project: projectRecord ? projectRecord.data._ref : null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByType: function(oid, type){
			var me = this, deferred = Q.defer();
			if(!oid || !type) return Q.reject('Invalid arguments: LPIBT');
			else {
				me[type].load(oid, {
					fetch: me._portfolioItemFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
						
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByOrdinal: function(oid, ordinal){
			var me = this, deferred = Q.defer(),
				type = me.PortfolioItemTypes[ordinal];
			return me._loadPortfolioItemByType(oid, type);
		},	
		
		/**************************************** Train Funcs ***************************************************/
		_projectInWhichTrain: function(projectRecord){ 
			/** returns train the projectRecord is in, otherwise null. */
			if(!projectRecord) return Q();
			else {
				var me=this,
					foundTrainConfig = _.find(me.TrainConfig, function(trainConfig){ 
						return trainConfig.TrainProjectOID == projectRecord.data.ObjectID; 
					});
				if(foundTrainConfig) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q();
					else {
						return me._loadProject(parent.ObjectID).then(function(parentRecord){
							return me._projectInWhichTrain(parentRecord);
						});
					}
				}
			}
		},
		_loadTrainPortfolioProject: function(trainRecord){
			if(!trainRecord) return Q.reject('Invalid arguments: ltpp');
			var me=this,
				foundTrainConfig = _.find(me.TrainConfig, function(trainConfig){ 
					return trainConfig.TrainProjectOID == trainRecord.data.ObjectID; 
				});
			if(!foundTrainConfig) return Q.reject('Project ' + trainRecord.data.Name + ' is not a train!');
			if(foundTrainConfig.TrainAndPortfolioLocationTheSame) return Q(trainRecord);
			else return me._loadProject(foundTrainConfig.PortfolioProjectOID);
		},
		_getTrainName: function(trainRecord){
			if(!trainRecord) throw 'Invalid arguments: gtn';
			var me=this,
				foundTrainConfig = _.find(me.TrainConfig, function(trainConfig){ 
					return trainConfig.TrainProjectOID == trainRecord.data.ObjectID; 
				});
			if(!foundTrainConfig) throw 'Project ' + trainRecord.data.Name + ' is not a train!';
			if(foundTrainConfig.TrainName) return foundTrainConfig.TrainName;
			else return trainRecord.data.Name;
		},
		_loadAllTrains: function(){
			var me=this,
				filter = _.reduce(me.TrainConfig, function(filter, item){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', { property:'ObjectID', value: item.TrainProjectOID });
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			if(!filter) return Q([]);
			else {
				var store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:Infinity,
					autoLoad:false,
					fetch: me._projectFields,
					filters:[filter],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
				return me._reloadStore(store).then(function(store){ return store.getRange(); });
			}
		},
		
		/**************************************** UserStory Funcs ************************************************/
		__getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ 
			/** only pull look at PortfolioItem Release if US.Release == null */
			var me=this,
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property:'PortfolioItem.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property:'PortfolioItem.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		_loadRandomUserStory: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: LRUS');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					fetch: false,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters:[{ 
						property:'Project.ObjectID', 
						value: projectRecord.data.ObjectID 
					}]
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadRandomUserStoryFromReleaseTimeframe: function(projectRecord, releaseRecord){
			if(!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: LRUSFR');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					fetch: me._userStoryFields,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project.ObjectID', value: projectRecord.data.ObjectID }).and(
						me.__getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me._reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		_loadUserStoryByFID: function(formattedID, projectRecord){
			if(!formattedID || !projectRecord) return Q.reject('Invalid arguments: LUSBFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		
		/**************************************** PortfolioItem Funcs ************************************************/
		_loadPortfolioItemsOfType: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: OPIOT');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					remoteSort:false,
					fetch: me._portfolioItemFields,
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store);
		},		
		_loadPortfolioItemsOfOrdinal: function(portfolioProject, ordinal){
			if(!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: LPIOO');
			var me=this, type = me.PortfolioItemTypes[ordinal];
			if(type) return me._loadPortfolioItemsOfType(portfolioProject, type);
			else return Q.reject('Invalid PortfolioItem ordinal');
		},
		_portfolioItemTypeToOrdinal: function(type){
			return this.PortfolioItemTypes.indexOf(type);
		},
		_getPortfolioItemTypeStateByOrdinal: function(ordinal, stateName){
			return _.find(this.PortfolioItemTypeStates[ordinal], function(state){ return state.data.Name == stateName; });
		},
		_getPortfolioItemTypeStateByName: function(portfolioType, stateName){
			return this._getPortfolioItemTypeStateByOrdinal(this._portfolioItemTypeToOrdinal(portfolioType), stateName);
		},
		
		/********************************************** Project Funcs ********************************************/	
		__storeItemsToProjTree: function(projects){
			var me=this, projTree = {};
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			return projTree;
		},
		_loadAllProjects: function(){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				var map = _.reduce(store.getRange(), function(map, project){
					map[project.data.ObjectID] = project;
					return map;
				}, {});
				return map;
			});	
		},
		__addProjectsWithTeamMembersToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
			}
		},	
		_loadProjectsWithTeamMembers: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				projectsWithTeamMembers = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
					return projectsWithTeamMembers;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.TeamMembers.Count > 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},	
		__allChildProjectToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_loadAllChildrenProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				childrenProjects = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
					return childrenProjects;
				} else {
					return _.reduce(store.getRange(), function(map, project){
						map[project.data.ObjectID] = project;
						return map;
					}, {});
				}
			});
		},	
		__allLeafProjectsToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		_loadAllLeafProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				leafProjects = {}, 
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
					return leafProjects;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.Children.Count === 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},
		_loadProjectByName: function(projectName){
			if(!projectName) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [{
						property:'Name',
						value:projectName
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** Release loading ********************************************/	
		_loadAllReleases: function(projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesBeforeGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'<=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesInTheFuture: function(projectRecord){
			return this._loadReleasesAfterGivenDate(projectRecord, new Date());
		},
		_loadReleasesByNameUnderProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					}],
					context:{
						project:projectRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleaseByNameForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						operator:'contains',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_getScopedRelease: function(releaseRecords, projectOID, appPrefs){			
			/** gets the most likely release to scope to base on the following order:
				1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
								to use preferences for this one)
				2) if we are currently in one of the releases
				3) the closest release planning date to the current date
			*/
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate), d2 = new Date(r.data.ReleaseStartDate), now = new Date();
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
		/************************* MODEL FOR WORKWEEK DROPDOWNS *********************************************/
	Ext.define('WorkweekDropdown', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Workweek', type:'string'},
			{name: 'DateVal', type:'number'}
		]
	});
		
	/************************* USED FOR WORKSPACE TRAIN CONFIG *********************************************/
	Ext.define('TrainConfigItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'TrainProjectOID', type: 'number'},
			{name: 'TrainName', type: 'string'},
			{name: 'TrainAndPortfolioLocationTheSame', type:'boolean'},
			{name: 'PortfolioProjectOID', type:'number'}
		]
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
		/** this is used if you want to listen to events in the parent window (e.g. useful for rally apps that resize with browser screen
			vertically or things that need to know browser scroll position) 
		You also can artificially fire the events and have the listeners run
	*/
	Ext.define('WindowListener', {

		__initWindowEventListener: function(eventName){
			var me=this;
			if(!me._windowListeners) me._windowListeners = {};
			me._windowListeners[eventName] = [];
			
			window.parent['on' + eventName] = function(event){ 
				var listeners = me._windowListeners[eventName];
				for(var i=0, len=listeners.length; i<len; ++i)
					listeners[i](event);
			};
		},
		
		_addWindowEventListener: function(eventName, fn){
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) 
				me.__initWindowEventListener(eventName);
			me._windowListeners[eventName].push(fn);
		},
		
		_fireParentWindowEvent: function(eventName){ //eg: resize or scroll
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) return;
			var listeners = me._windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
		}
	});
}());
                /** this mixin is used to mess with the environment outside of the iframe that the rally app is put in. */
(function(){
	var Ext = window.Ext4 || window.Ext;

	var TOP_BAR_HEIGHT = 40,
		BOTTOM_BAR_HEIGHT = 24,
		TITLE_BAR_HEIGHT = 33,
		IFRAME_HEADER_HEIGHT = 28;
		
	Ext.define('IframeResize', {
		requires: ['WindowListener'],
		
		_fixRallyDashboard: function(){ 
			/** makes app as large as screen, without the padding/margin */
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				portlet = bottomEl.up('.x-portlet'), 
				dashboard = portlet.up('#mydash_portlet'), //has huge padding values
				titleBar = dashboard.down('.titlebar'), //redundant with app header bar
				domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
				innerHeight = window.parent.innerHeight,
				innerWidth = window.parent.innerWidth;
			
			//adjust widths
			while(true){
				domNodeW.style.width = (innerWidth - 4) + 'px';
				domNodeW.style.padding = '0';
				domNodeW.style.margin = '0';
				if(domNodeW.id === 'mydash_portlet') break;
				domNodeW = domNodeW.parentNode;
			}
			
			//adjust heights
			while(true){
				domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT + IFRAME_HEADER_HEIGHT)) + 'px';
				if(domNodeH.classList.contains('x-portlet')) break;
				domNodeH = domNodeH.parentNode;
			}
			while(true){
				domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT)) + 'px';
				if(domNodeH.id == 'mydash_portlet') break;
				domNodeH = domNodeH.parentNode;
			}
			dashboard.dom.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT)) + 'px';
			
			//final touches LOL
			dashboard.dom.style.padding = "0 2px 0 2px";
			titleBar.dom.style.padding = "2px";
			titleBar.dom.style.margin = "0";
		},		
		_initFixRallyDashboard: function(){ 
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
			}
			me._fixRallyDashboard();
		},

		_disableResizeHandle: function(){ 
			/** hides the draggable resize handle from under the app */
			var me=this, handle;
			if(window.frameElement) handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
			else handle = me.el.up('.x-portlet').down('.x-resizable-handle');
			if(handle){
				handle.hide();
				handle.dom.onshow = function(){ if(handle) handle.hide(); };
			}
		},	
		_initDisableResizeHandle: function(){
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
			}
			me._disableResizeHandle();
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/**  
		THIS IS ONLY USEFUL AS A RALLYAPP MIXIN 
		gives a window-centered alert or confirm dialog box that isn't ugly. 
	*/
	Ext.define('PrettyAlert', {

		__getMessageBoxY: function(){ 
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.parent.getWindowHeight(), 
				ps = window.parent.getScrollY(), 
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},
		
		_alert: function(title, message){
			var me=this;
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<1) return;
			if(arguments.length===1){
				message = title;
				title = '';
			}
			Ext.MessageBox.alert(title, message).setY(me.__getMessageBoxY());
			setTimeout(function(){ //give some time to give the 'ok' or 'yes' button focus
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 50);
		},
		
		_confirm: function(title, message, fn){
			var me=this;
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = message;
				message = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			Ext.MessageBox.confirm(title, message, fn).setY(me.__getMessageBoxY());
			setTimeout(function(){
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 20);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;

	var intel_ww = {},
		SECOND = 1000,
		MINUTE = 60*SECOND,
		HOUR = 60*MINUTE,
		DAY = 24*HOUR,
		WEEK = 7*DAY;
		
	Ext.define('IntelWorkweek', {
		/** 
			intel workweek utility module. you can pass in Date objects, strings, or numbers.
			do not pass in Unix UTC millis though, or you will get wrong answer (eg: dont use Date.UTC(...))
		**/
		
		/** calculates intel workweek, returns integer */
		_getWorkweek: function(_date){  //ww1 always contains jan 1st
			var date = new Date(_date),
				yearStart = new Date(date.getFullYear(), 0, 1),
				dayIndex = yearStart.getDay(),
				ww01Start = new Date(yearStart - dayIndex*DAY),
				utcDateMillis = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
				ww01Millis = Date.UTC(ww01Start.getFullYear(), ww01Start.getMonth(), ww01Start.getDate()),
				timeDiff = utcDateMillis - ww01Millis,
				ww = Math.floor(timeDiff/WEEK) + 1,
				leap = (date.getFullYear() % 4 === 0),
				weekCount = ((leap && dayIndex >= 5) || (!leap && dayIndex === 6 )) ? 53 : 52; //weeks in this year
			return weekCount < ww ? 1 : ww;
		},
		
		/** returns the number of intel workweeks in the year the date is in */
		_getWeekCount: function(_date){  // # of intel workweeks in the year the date is in
			var date = new Date(_date),
				leap = (date.getFullYear() % 4 === 0),
				day = new Date(date.getFullYear(), 0, 1).getDay();
			return ((leap && day >= 5) || (!leap && day === 6 )) ? 53 : 52;
		},
		
		_roundDateDownToWeekStart: function(_date){
			var date = new Date(_date),
				day = date.getDay(),
				monthDate = date.getDate(),
				month = date.getMonth(),
				year = date.getFullYear(),
				sundayMidday = new Date(new Date(year, month, monthDate)*1 - (day*DAY - 0.5*DAY)); //daylight savings ._.
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/**  gets list of date numbers for each week start between start and end date*/
		_getWorkweekDates: function(startDate, endDate){ //gets list of dates for each week. INCLUSIVE
			var startWeekDate = this._roundDateDownToWeekStart(startDate),
				endWeekDate = this._roundDateDownToWeekStart(endDate),
				startMillis = Date.UTC(startWeekDate.getFullYear(), startWeekDate.getMonth(), startWeekDate.getDate()),
				endMillis = Date.UTC(endWeekDate.getFullYear(), endWeekDate.getMonth(), endWeekDate.getDate()),
				totalWeeks = Math.floor((endMillis - startMillis) / WEEK)+1,
				weeks = new Array(totalWeeks);
			for(var i=0; i<totalWeeks; ++i) {
				var sundayMidday = new Date(startWeekDate*1 + (WEEK*i + HOUR*12));
				weeks[i] = new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
			}
			return weeks;
		},
		
		_workweekToDate: function(ww, year){ //gets the Date() object of this ww and year
			var yearStart = new Date(year, 0, 1),
				dayIndex = yearStart.getDay(),
				ww01StartMidday = new Date(yearStart - (dayIndex*DAY - 0.5*DAY)),
				sundayMidday = new Date(ww01StartMidday*1 + (ww-1)*WEEK);
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		_getWorkWeeksForDropdown: function(releaseStartDate, releaseEndDate){ //assumes DropDown uses WorkweekDropdown model
			var workweeks = this._getWorkweekDates(releaseStartDate, releaseEndDate),
				data = new Array(workweeks.length);
			for(var i=0, len=workweeks.length; i<len; ++i){
				data[i] = { 
					Workweek: 'ww' + this._getWorkweek(workweeks[i]),
					DateVal: workweeks[i]*1
				};
			}
			return data;
		}	
	});
}());
                /** this is pretty much like a mutex implementation. you call enqueue and then when its your function's turn
	you do stuff and then you call the callback passed to you so the next function can execute */
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	//given named queues, only allows one function at a time in each queue to execute. 
	Ext.define('AsyncQueue', {
		
		QueueOfFuncs: {},
		
		_dequeue: function(queueName){
			var me=this;
			queueName = queueName || 'undefined'; //to be clear
			if(me.QueueOfFuncs[queueName]){
				me.QueueOfFuncs[queueName].shift();
				if(!me.QueueOfFuncs[queueName].length) return;
				else me.QueueOfFuncs[queueName][0].call(me, me._dequeue.bind(me, queueName));
			}
		},
		
		//callback(done)...make sure you call done when you are finished
		_enqueue: function(callback, queueName){
			var me=this;
			queueName = queueName || 'undefined'; //to be clear
			if(typeof callback !== 'function') throw 'ERROR: not a function';
			if(!me.QueueOfFuncs[queueName] || !me.QueueOfFuncs[queueName].length){
				me.QueueOfFuncs[queueName] = [callback];
				callback.call(me, me._dequeue.bind(me, queueName));
			}
			else me.QueueOfFuncs[queueName].push(callback);
		}
	});
}());
                /** use this to load stores that have lots of records. it will load them in parallel instead of serially.
	what it does is loads 1 page and then based on the totalResultCount it loads the rest of the pages in parallel.
	
		for wsapiStore, the config needs to be: {
			pagesize: <defaults to 200>
			url:<host:port/path>
			params: query parameter object with keys and vals
			model: the instantiated wsapi model (need to load this first)
		}
		for lookbackStore, the config needs to be: {
			pagesize: <defaults to 20000>
			url:<host:port/path defaults to standard analytics url. host is window.location.host>
			params: query parameter object with keys and vals
		}
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('ParallelLoader', { 
		
		__parallelLoadData: function(config){
			var me=this,
				pagesize = config.pagesize,
				url = config.url,
				params = config.params,
				promises = [],
				outputItems = [];
				totalRequestsSent = 1; //1 is the minimum number of requests sent
			_.times(totalRequestsSent, function(pageNum){
				var thisDeferred = Q.defer(),
					thisParams = Ext.merge({}, params);
				promises.push(thisDeferred.promise);
				thisParams.start = config.itemOffset + pagesize*pageNum;
				Ext.Ajax.request({
					url:url,
					method:'GET',
					params: thisParams,
					success: function(response){
						var resJSON  = JSON.parse(response.responseText),
							items = resJSON.QueryResult ? resJSON.QueryResult.Results : resJSON.Results,
							totalCount = resJSON.QueryResult ? resJSON.QueryResult.TotalResultCount : resJSON.TotalResultCount,
							totalPages = (totalCount/pagesize>>0)+(totalCount%pagesize ? 1 : 0);			
						outputItems = outputItems.concat(items);
						if(totalRequestsSent < totalPages){
							var	additionalPromises = [];
							_.times(totalPages - totalRequestsSent, function(){
								var nextDeferred = Q.defer(),
									thisParams = Ext.merge({}, params);
								additionalPromises.push(nextDeferred.promise);
								thisParams.start = config.itemOffset + pagesize*totalRequestsSent;
								++totalRequestsSent;
								Ext.Ajax.request({
									url:url,
									method:'GET',
									params: thisParams,
									success: function(response){
										var resJSON  = JSON.parse(response.responseText),
											items = resJSON.QueryResult ? resJSON.QueryResult.Results : resJSON.Results;
										outputItems = outputItems.concat(items);
										nextDeferred.resolve();
									},
									failure: function(response){ nextDeferred.reject(response); }
								});
							});
							Q.all(additionalPromises).then(function(){ thisDeferred.resolve(); });
						}
						else thisDeferred.resolve();
					},
					failure: function(response){ thisDeferred.reject(response); }
				});
			});
			return Q.all(promises).then(function(){ return outputItems; });
		},		
		_parallelLoadWsapiStore: function(config){
			var me=this;
			config.itemOffset = 1; //page index starts at 1 for wsapi
			config.pagesize = (config.pagesize > 0 && config.pagesize <= 200) ? config.pagesize : 200;
			return me.__parallelLoadData(config).then(function(items){
				return Ext.create('Rally.data.wsapi.Store', {
					model: config.model,
					totalCount: items.length,
					data: items,
					load: function(){}
				});
			});
		},
		_parallelLoadLookbackStore: function(config){
			var me=this;
			config.itemOffset = 0; //page index starts at 0 for lookback
			config.pagesize = (config.pagesize > 0 && config.pagesize <= 20000) ? config.pagesize : 20000;
			return me.__parallelLoadData(config).then(function(items){
				return Ext.create('Rally.data.lookback.SnapshotStore', {
					totalCount: items.length,
					data: items,
					model: Ext.define('Rally.data.lookback.SnapshotModel-' + Ext.id(), {
						extend: 'Rally.data.lookback.SnapshotModel',
						fields: JSON.parse(config.params.fields || "[]")
					}),
					load: function(){}
				});
			});
		}
	});
}());
                /** This class is used to save user preferences per project, that can follow the user from app to app **/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('UserAppsPreference', {
		
		_userAppsPref: 'intel-user-apps-preference', //preference name can be overridden, unless you want all apps to share prefs
		
		_loadAppsPreference: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				filterByUser:true,
				filterByName:me._userAppsPref,
				success: function(prefs) {
					var appPrefs = prefs[me._userAppsPref];
					try{ appPrefs = JSON.parse(appPrefs); }
					catch(e){ appPrefs = { projs:{}, refresh:0};}
					deferred.resolve(appPrefs);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveAppsPreference: function(prefs){
			var me=this, s = {}, deferred = Q.defer();
			prefs = {projs:prefs.projs, refresh:prefs.refresh};
			s[me._userAppsPref] = JSON.stringify(prefs); 
			Rally.data.PreferenceManager.update({
				filterByUser: true,
				filterByName:me._userAppsPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                /** This class is used to communicate between apps the location of the sanity dashboard **/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('SanityDashboardObjectIDPreference', {
		
		_sanityObjectIdPref: 'intel-sanity-objectid',
		
		_loadSanityDashboardObjectID: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName:me._sanityObjectIdPref,
				success: function(prefs){
					var objectID = prefs[me._sanityObjectIdPref]*1;
					deferred.resolve(objectID);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_setSanityDashboardObjectID: function(){
			var me=this, s = {}, deferred = Q.defer(),
				objectID = window.parent.location.hash.split("/").pop();
			s[me._sanityObjectIdPref] = objectID; 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName:me._sanityObjectIdPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	var POLL_INTERVAL_MS = 10;
	
	/*!
	 * CTemplate
	 * Version 1.1
	 * Copyright(c) 2011-2013 Skirtle's Den
	 * License: http://skirtlesden.com/ux/ctemplate
	 
		MY NOTE: how this works. XTemplates use apply() to convert the template to the actual HTML. CTemplate converts XTemplate into a bunch
		of <p> tags and stores the ids of them and then immediately starts polling for them in doPolling. do POlling calls injectComponents
		after the poll interval and if injectComponents does not render all the components, it calls doPolling again.
		injectComponents calls renderComponent for each component.
		overwrite and doInsert call the XTemplate parent functions, which call CTemplate's apply, and then they call injectComponents.
		
		NOTE: everytime apply() is called, the me.ids[] is generated, and when injectComponents is finished, me.ids[] is empty!
	 */
	Ext.define('Skirtle.CTemplate',{
		extend: 'Ext.XTemplate',
		statics: { AUTO_ID: 0 },
		
		copyDepth: 10,		
		cTpl: '<p id="ctemplate-{0}-{1}"></p>',
		isCTemplate: true,

		constructor: function(){
			var me = this;
			me.callParent(arguments);
			me.id = ++me.statics().AUTO_ID;
			me.reset();
		},

		copyValues: function(values, depth){
			/* Takes a recursive copy of the values provided, switching out components for placeholder values. The component ids
			 * are recorded and injectComponents() uses the ids to find the placeholder elements in the DOM and switch in the
			 * components.
			 */
			var me = this,
				id,
				copy = {},
				copyDepth = depth || me.copyDepth;

			if(copyDepth === 1) return values;

			if(Ext.isArray(values)){
				return Ext.Array.map(values, function(value) {
					return me.copyValues(value, copyDepth - 1);
				});
			}

			if(!Ext.isObject(values)) return values;

			// This is the key sleight-of-hand that makes the whole thing work
			if(values.isComponent){
				id = values.getId();
				me.ids.push(id);
				return Ext.String.format(me.cTpl, id, me.id);
			}

			Ext.Object.each(values, function(key, value) {
				// $comp is a special value for a renderTpl that references the current component
				copy[key] = key === '$comp' ? value : me.copyValues(value, copyDepth - 1);
			});

			return copy;
		},
		doInsert: function() { // Override
			//(calls this.apply() to convert ids to templates for XTemplate to put in the DOM
			var ret = this.callParent(arguments);	
			this.injectComponents();// There's no guarantee this will succeed so we still need polling as well
			return ret;
		},
		doPolling: function(interval) {
			var me = this;
			me.pollInterval = interval;
			if(me.pollId) clearTimeout(me.pollId);
			me.pollId = Ext.defer(me.injectComponents, interval, me);
		},
		getPlaceholderEl: function(id) {
			return Ext.get('ctemplate-' + id + '-' + this.id);
		},	
		injectComponents: function() {
			/* Attempts to substitute all placeholder elements with the real components. If a component is successfully injected
			 * or it has been destroyed then it won't be attempted again. This method is repeatedly invoked by a polling
			 * mechanism until no components remain, however relying on the polling is not advised. Instead it is preferable to
			 * call this method directly as soon as the generated HTML is inserted into the DOM.
			 */
			var me = this,
				ids = me.ids,
				index = ids.length - 1,
				id,
				cmp,
				placeholderEl;

			// Iterate backwards because we remove some elements in the loop
			for( ; index >= 0 ; --index){
				id = ids[index];
				cmp = Ext.getCmp(id);
				placeholderEl = me.getPlaceholderEl(id);
				if(me.renderComponent(cmp, placeholderEl) || !cmp){
					// Either we've successfully done the switch or the component has been destroyed
					Ext.Array.splice(ids, index, 1);
					if(placeholderEl) placeholderEl.remove();
				}
			}
			// Some components have not been injected. Polling acts both to do deferred injection and as a form of GC
			if(ids.length) me.doPolling(me.pollInterval); //originally was me.pollInterval * 1.5
		},
		overwrite: function(el){ // Override 
			//(calls this.apply() to convert ids to templates for XTemplate to put in the DOM
			var dom,
				firstChild,
				ret;

			/* In IE setting the innerHTML will destroy the nodes for the previous content. If we try to reuse components it
			 * will fail as their DOM nodes will have been torn apart. We can't defend against external updates to the DOM
			 * but we can guard against the case where all updates come through this template.
			 */
			if(Ext.isIE){
				dom = Ext.getDom(el);
				while(dom.firstChild){
					dom.removeChild(dom.firstChild);
				}
			}
			ret = this.callParent(arguments);		
			this.injectComponents(); // There's no guarantee this will succeed so we still need polling as well
			return ret;
		},
		renderComponent: function(cmp, placeholderEl){
			if(cmp && placeholderEl){
				var parent = placeholderEl.parent();
				
				// Move a component that has been rendered previously
				if(cmp.rendered) cmp.getEl().replace(placeholderEl);
				else cmp.render(parent, placeholderEl);

				// Some components (mostly form fields) reserve space but fail to show up without a repaint in IE6
				if(Ext.isIE6)	parent.repaint();
				return true;
			}
			else return false;
		},
		reset: function() {
			var me = this;	
			me.ids = [];// The ids of injected components that haven't yet been rendered
			if(me.pollId){
				clearTimeout(me.pollId);
				me.pollId = null;
			}
		}
	}, function(ctemplate) {
		var apply = function(){
			var me = this,
				args = Ext.Array.slice(arguments);
			args[0] = me.copyValues(args[0]);
			me.doPolling(POLL_INTERVAL_MS); // As we're returning an HTML string/array we can't actually complete the injection here
			return me.callParent(args);
		};
		// The main override is different depending on whether we're using ExtJS 4.0 or 4.1+
		if(ctemplate.prototype.applyOut) ctemplate.override({ applyOut: apply });// 4.1+
		else {	
			ctemplate.override({ applyTemplate: apply }); // 4.0
			ctemplate.createAlias('apply', 'applyTemplate');
		}
	});

	/*!
	 * Component Column
	 * Version 1.1
	 * Copyright(c) 2011-2013 Skirtle's Den
	 * License: http://skirtlesden.com/ux/component-column
	 */
	Ext.define('Skirtle.grid.column.Component', {
		alias: 'widget.componentcolumn',
		extend: 'Ext.grid.column.Column',
		requires: ['Skirtle.CTemplate'],

		autoWidthComponents: true, // Whether or not to automatically resize the components when the column resizes		
		componentGC: true, // Whether or not to destroy components when they are removed from the DOM
		hasCustomRenderer: true, // Override the superclass - this must always be true or odd things happen, especially in IE
		lastFrameWidth: 12, // The estimated size of the cell frame. This is updated once there is a cell where it can be measured

		/* Defer durations for updating the component width when a column resizes. Required when a component has an animated
		 * resize that causes the scrollbar to appear/disappear. Otherwise the animated component can end up the wrong size.
		 *
		 * For ExtJS 4.0 both delays are required. For 4.1 just having the 10ms delay seems to be sufficient.
		 */
		widthUpdateDelay: [10, 400],

		constructor: function(cfg) {
			var me = this;

			me.callParent(arguments);

			// Array of component ids for both component queries and GC
			me.compIds = [];

			// We need a dataIndex, even if it doesn't correspond to a real field
			me.dataIndex = me.dataIndex || Ext.id(null, 'cc-dataIndex-');
			me.tpl = me.createTemplate(me.tpl);
			me.renderer = me.createRenderer(me.renderer);
			me.registerColumnListeners();
		},
		addRefOwner: function(child) {
			var me = this,
				fn = me.refOwnerFn || (me.refOwnerFn = function() { return me; });
			if(me.extVersion < 40200) child.getBubbleTarget = fn; // Component queries for ancestors use getBubbleTarget in 4.1 ...
			else child.getRefOwner = fn; // ... and getRefOwner in 4.2+
		},
		applyTemplate: function(data, value) {
			if(Ext.isDefined(value)) data[this.dataIndex] = value;
			return this.tpl.apply(data);
		},
		beforeViewRefresh: function() {
			/* In IE setting the innerHTML will destroy the nodes for the previous content. If we try to reuse components it
			 * will fail as their DOM nodes will have been torn apart. To defend against this we must remove the components
			 * from the DOM just before the grid view is refreshed.
			 */
			if (Ext.isIE) {
				var ids = this.compIds,
					index = 0,
					len = ids.length,
					item,
					el,
					parentEl;

				for ( ; index < len ; index++) {
					if ((item = Ext.getCmp(ids[index])) && (el = item.getEl()) && (el = el.dom) && (parentEl = el.parentNode)) {
						parentEl.removeChild(el);
					}
				}
			}
		},
		calculateFrameWidth: function(component) {
			var el = component.getEl(),
				parentDiv = el && el.parent(),
				// By default the TD has no padding but it is quite common to add some via a tdCls
				parentTd = parentDiv && parentDiv.parent();

			if(parentTd){
				// Cache the frame width so that it can be used as a 'best guess' in cases where we don't have the elements
				return this.lastFrameWidth = parentDiv.getFrameWidth('lr') + parentTd.getFrameWidth('lr');
			}
		},
		createRenderer: function(renderer) {
			var me = this;
			return function(value, p, record) {
				var data = Ext.apply({}, record.data, record.getAssociatedData());
				if(renderer) value = renderer.apply(this, arguments); // Scope must be this, not me
				// Process the value even with no renderer defined as the record may contain a component config
				value = me.processValue(value);
				return me.applyTemplate(data, value);
			};
		},
		createTemplate: function(tpl) {
			return tpl && tpl.isTemplate ? tpl : Ext.create('Skirtle.CTemplate', tpl || ['{', this.dataIndex ,'}']);
		},
		destroyChild: function(child) { child.destroy(); },
		getRefItems: function(deep) {
			var items = this.callParent([deep]),
					ids = this.compIds,
					index = 0,
					len = ids.length,
					item;

			for( ; index < len ; index++){
				item = Ext.getCmp(ids[index]);
				if(item){
					items.push(item);
					if(deep && item.getRefItems) items.push.apply(items, item.getRefItems(true));
				}
			}
			return items;
		},
		onChildAfterRender: function(child){ this.resizeChild(child); },
		onChildBoxReady: function(child){
			// Pass false to avoid triggering deferred resize, the afterrender listener will already cover those cases
			this.resizeChild(child, false);
		},
		onChildDestroy: function(child){ Ext.Array.remove(this.compIds, child.getId()); },
		onChildResize: function(){ this.redoScrollbars(); },
		onColumnResize: function(column){ column.resizeAll(); },
		onColumnShow: function(column){ column.resizeAll(); },
		onColumnVisibilityChange: function(column) {
			// This is called in IE 6/7 as the components can still be seen even when a column is hidden
			var items = column.getRefItems(),
				index = 0,
				length = items.length,
				visible = !column.isHidden();

			// In practice this probably won't help but it shouldn't hurt either
			if(Ext.suspendLayouts) Ext.suspendLayouts();

			for( ; index < length ; ++index){
				items[index].setVisible(visible);
			}
			if(Ext.resumeLayouts) Ext.resumeLayouts(true);
		},
		onDestroy: function() {
				Ext.destroy(this.getRefItems());

				this.callParent();
		},
		onRender: function(){ // Override
			this.registerViewListeners();
			this.callParent(arguments);
		},
		onViewChange: function() {
			// View has changed, may be a full refresh or just a single row
			var me = this,
				tpl = me.tpl;

			// Batch the resizing of child components until after they've all been injected
			me.suspendResizing();

			if (tpl.isCTemplate) {
				// No need to wait for the polling, the sooner we inject the less painful it is
				tpl.injectComponents();
				// If the template picked up other components in the data we can just ignore them, they're not for us
				tpl.reset();
			}
			// A view change could mean scrollbar problems. Note this won't actually do anything till we call resumeResizing
			me.redoScrollbars();
			me.resumeResizing();			
			me.performGC();
		},
		performGC: function() {
			// Component GC, try to stop components leaking
			var compIds = this.compIds,
				index = compIds.length - 1,
				comp,
				el;

			for( ; index >= 0 ; --index){
				// Could just assume that the component id is the el id but that seems risky
				comp = Ext.getCmp(compIds[index]);
				el = comp && comp.getEl();

				if (!el || (this.componentGC && (!el.dom || Ext.getDom(Ext.id(el)) !== el.dom))) {
					// The component is no longer in the DOM
					if(comp && !comp.isDestroyed) comp.destroy();
				}
			}
		},
		processValue: function(value) {
			var me = this,
				compIds = me.compIds,
				id, initialWidth, dom, parent;

			if(Ext.isObject(value) && !value.isComponent && value.xtype) {
				// Do not default to a panel, not only would it be an odd default but it makes future enhancements trickier
				value = Ext.widget(value.xtype, value);
			}

			if(value && value.isComponent){
				id = value.getId();
				// When the view is refreshed the renderer could return a component that's already in the list
				if(!Ext.Array.contains(compIds, id)) compIds.push(id);
				me.addRefOwner(value);
				me.registerListeners(value);
				if(value.rendered){
					/* This is only necessary in IE because it is just another manifestation of the innerHTML problems.
					 * The problem occurs when a record value is changed and the components in that same row are being
					 * reused. The view doesn't go through a full refresh, instead it performs a quick update on just the
					 * one row. Unfortunately this nukes the existing components so we need to remove them first.
					 */
					if(Ext.isIE){
						// TODO: Should this be promoted to CTemplate?
						dom = value.el.dom;
						parent = dom.parentNode;

						if(parent){
							if(me.extVersion === 40101){
								// Workaround for the bugs in Element.syncContent - p tag matches CTemplate.cTpl
								Ext.core.DomHelper.insertBefore(dom, {tag: 'p'});
							}
							// TODO: Removing the element like this could fall foul of Element GC
							parent.removeChild(dom);
						}
					}
				}
				else if (me.autoWidthComponents) {
					/* Set the width to a 'best guess' before the component is rendered to ensure that the component's
					 * layout is using a configured width and not natural width. This avoids problems with 4.1.1 where
					 * subsequent calls to setWidth are ignored because it believes the width is already correct but only
					 * the outermost element is actually sized correctly. We could use an arbitrary width but instead we
					 * make a reasonable guess at what the actual width will be to try to avoid extra resizing.
					 */
					initialWidth = me.getWidth() - me.lastFrameWidth;

					// Impose a minimum width of 4, we really don't want negatives values or NaN slipping through
					initialWidth = initialWidth > 4 ? initialWidth : 4;

					value.setWidth(initialWidth);
				}
				// Part of the same IE 6/7 hack as onColumnVisibilityChange
				if((Ext.isIE6 || Ext.isIE7) && me.isHidden()) value.hide();
			}

			return value;
		},
		redoScrollbars: function() {
			var me = this,
				grid = me.up('tablepanel');

			if(grid){
				// The presence of a resizeQueue signifies that we are currently suspended
				if(me.resizeQueue){
					me.redoScrollbarsRequired = true;
					return;
				}

				// After components are injected the need for a grid scrollbar may need redetermining
				if(me.extVersion < 40100){ // 4.0	
					grid.invalidateScroller();
					grid.determineScrollbars();
				}
				else grid.doLayout(); // 4.1+
			}
		},
		registerColumnListeners: function() {
			var me = this;

			if(me.autoWidthComponents){
				// Need to resize children when the column resizes
				me.on('resize', me.onColumnResize);
				// Need to resize children when the column is shown as they can't be resized correctly while it is hidden
				me.on('show', me.onColumnShow);
			}
			if(Ext.isIE6 || Ext.isIE7){
				me.on({
					hide: me.onColumnVisibilityChange,
					show: me.onColumnVisibilityChange
				});
			}
		},
		registerListeners: function(component) {
			var me = this;

			// Remove the component from the child list when it is destroyed
			component.on('destroy', me.onChildDestroy, me);
			if(me.autoWidthComponents){
				// Need to resize children after render as some components (e.g. comboboxes) get it wrong otherwise
				component.on('afterrender', me.onChildAfterRender, me, {single: true});

				// With 4.1 boxready gives more reliable results than afterrender as it occurs after the initial sizing
				if(me.extVersion >= 40100) component.on('boxready', me.onChildBoxReady, me, {single: true});
			}

			// Need to redo scrollbars when a child resizes
			component.on('resize', me.onChildResize, me);
		},
		registerViewListeners: function() {
				var me = this,
					view = me.up('tablepanel').getView();
				me.mon(view, 'beforerefresh', me.beforeViewRefresh, me);
				me.mon(view, 'refresh', me.onViewChange, me);
				me.mon(view, 'itemupdate', me.onViewChange, me);
				me.mon(view, 'itemadd', me.onViewChange, me);
				me.mon(view, 'itemremove', me.onViewChange, me);
		},
		resizeAll: function() {
				var me = this;
				me.suspendResizing();
				me.resizeQueue = me.getRefItems();
				me.resumeResizing();
		},
		resizeChild: function(component, defer) {
			var me = this,
				frameWidth,
				newWidth,
				oldWidth,
				resizeQueue;

			if(me.resizingSuspended){
				resizeQueue = me.resizeQueue;
				if(!Ext.Array.contains(resizeQueue, component)) resizeQueue.push(component);
				return;
			}
			frameWidth = me.calculateFrameWidth(component);

			// TODO: Should we destroy the component here if it doesn't have a parent element? Already picked up anyway?
			if(Ext.isNumber(frameWidth)){
				newWidth = me.getWidth() - frameWidth;
				oldWidth = component.getWidth();

				// Returns true if a resize actually happened
				if(me.setChildWidth(component, newWidth, oldWidth)){
					// Avoid an infinite resizing loop, deferring will only happen once
					if(defer !== false){
						// Do the sizing again after a delay. This is because child panel collapse animations undo our sizing
						Ext.each(me.widthUpdateDelay, function(delay){
							Ext.defer(me.resizeChild, delay, me, [component, false]);
						});
					}
				}
			}
		},
		resumeResizing: function() {
			var me = this,
				index = 0,
				resizeQueue = me.resizeQueue,
				len = resizeQueue.length;

			if(!--me.resizingSuspended) {
				for ( ; index < len ; ++index){
					me.resizeChild(resizeQueue[index]);
				}
				me.resizeQueue = null;
				if (me.redoScrollbarsRequired) me.redoScrollbars();
			}
		},
		setChildWidth: function(component, newWidth, oldWidth) {
			if(oldWidth === newWidth) return false;
			component.setWidth(newWidth);
			return true;
		},
		suspendResizing: function() {
			var me = this;
			me.resizingSuspended = (me.resizingSuspended || 0) + 1;
			if(!me.resizeQueue) me.resizeQueue = [];
		}
	}, 
	function(cls){
		var proto = cls.prototype,
			version = Ext.getVersion();
		proto.extVersion = (version.getMajor() * 100 + version.getMinor()) * 100 + version.getPatch(); // ExtJS version detection
		// 4.1.1 initially reported its version as 4.1.0
		if(Ext.Element.prototype.syncContent && version.toString() === '4.1.0') proto.extVersion = 40101;
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** this combo has filter-as-you-type and drops down on click. it also lets you navigate with arrow keys
		(although there is some arrow key scrolling bug) 
	*/
	Ext.define('IntelComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelcombo', 'widget.intelcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				enableKeyEvents:true,
				queryMode:'local',
				ignoreNoChange:true,
				allowBlank:true,
				listeners: {
					keyup: function(a,b){
						if(b.keyCode>=37 && b.keyCode <=40) return; //arrow keys
						var combo = this;
						combo.store.clearFilter();
						combo.store.filterBy(function(item){
							return item.data[combo.displayField].match(new RegExp(combo.getRawValue(), 'i')) !== null;
						});
					},
					focus: function(combo) {
						combo.store.clearFilter();
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('IntelFixedComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				editable: false,	
				allowBlank:true,
				queryMode:'local',
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					focus: function(combo) {
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}	
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** YOU MUST PASS IT 2 THINGS IN THE CONFIG
		1: releases (array of release records)
		2: currentRelease (what to show as initial value
	*/
	Ext.define('IntelReleasePicker', {
		extend: 'IntelFixedComboBox',
		alias: ['widget.intelreleasepicker'],
		
		constructor: function(options){
			if(!options.releases || !options.currentRelease) return;
			
			options.displayField = 'Name';
			options.value = options.currentRelease.data.Name;
			options.store = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				sorters: [function(o1, o2){ return o1.data.Name > o2.data.Name ? -1 : 1; }],
				data: _.map(options.releases, function(r){ return {Name: r.data.Name }; })
			});
			
			options.fieldLabel = options.fieldLabel || 'Release:';
			options.editable = options.editable || false;
			options.width = options.width || 240;
			options.labelWidth = options.labelWidth || 50;
			
			this.callParent([options]); //now that we have the extra stuff added
		}
	});
}());

                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('IntelTextarea', {
		extend: 'Ext.form.field.TextArea',
		alias: ['widget.inteltextarea'],
		
		grow:true,
		growMin:20,
		growMax:160,
		maxLength:150,
		enforceMaxLength:true,
		enterIsSpecial:true
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
	Ext.define('intel.grid.column.Component.', {
		alias: 'widget.fastgridcolumn',
		extend: 'Skirtle.grid.column.Component',

		autoWidthComponents: false,
		componentGC: true,
		hasCustomRenderer: true,
		lastFrameWidth: 12,		
		constructor: function(cfg) {
			var me = this;
			me.callParent(arguments);
		},
		registerViewListeners: function() {
			var me = this,
				view = me.up('tablepanel').getView();

			me.mon(view, 'beforerefresh', me.beforeViewRefresh, me);
			me.mon(view, 'refresh', me.onViewChange, me);
			//me.mon(view, 'itemupdate', me.onViewChange, me); //why are these necessary...
			//me.mon(view, 'itemadd', me.onViewChange, me);
			//me.mon(view, 'itemremove', me.onViewChange, me);
		},
		onViewChange: function() {
			var me = this, tpl = me.tpl;
			me.suspendResizing();
			if (tpl.isCTemplate) {
					tpl.injectComponents();
					tpl.reset();
			}
			//me.redoScrollbars();
			me.resumeResizing();
			me.performGC();
		},		
		resumeResizing: function(){
			var me = this,
				index = 0,
				resizeQueue = me.resizeQueue,
				len = resizeQueue.length;
			if (!--me.resizingSuspended) {
				for ( ; index < len ; ++index) me.resizeChild(resizeQueue[index]);
				me.resizeQueue = null;
				/* if (me.redoScrollbarsRequired) {
						me.redoScrollbars();
				} */
			}
		},
		onChildResize: function() {
			//this.redoScrollbars();
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
	/**
		the regular proxy calls record.commit() and later on, datarefresh event is called. since these both cause a rerender, 
		we make the record edits SILENT, so only the datarefresh actually rerender the page
	*/

	Ext.define('Intel.data.proxy.SessionStorage', {
		extend: 'Ext.data.proxy.SessionStorage',
		alias: 'proxy.fastsessionproxy',

		constructor: function(cfg) {
			var me = this;
			me.callParent(arguments);
		},
		
		create: function(operation, callback, scope) {
			var me = this,
				records = operation.records,
				length = records.length,
				ids = me.getIds(),
				id, record, i;

			operation.setStarted();
			if(me.isHierarchical === undefined) {
					
					
				me.isHierarchical = !!records[0].isNode;
				if(me.isHierarchical) {
					me.getStorageObject().setItem(me.getTreeKey(), true);
				}
			}
			for (i = 0; i < length; i++) {
				record = records[i];

				if (record.phantom) {
					record.phantom = false;
					id = me.getNextId();
				} else {
					id = record.getId();
				}
				
				record.beginEdit();
				me.setRecord(record, id);
				record.endEdit(true); //SILENT!!!
				record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!
				
				ids.push(id);
			}
			me.setIds(ids);

			operation.setCompleted();
			operation.setSuccessful();

			if (typeof callback == 'function') {
				callback.call(scope || me, operation);
			}
		},
		
		update: function(operation, callback, scope) {
			var records = operation.records,
				length = records.length,
				ids = this.getIds(),
				record, id, i;
				
			operation.setStarted();
			for (i = 0; i < length; i++) {
				record = records[i];
				this.setRecord(record);
			
				record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!

				id = record.getId();
				if (id !== undefined && Ext.Array.indexOf(ids, id) == -1) ids.push(id);
			}
			this.setIds(ids);

			operation.setCompleted();
			operation.setSuccessful();
			if (typeof callback == 'function') callback.call(scope || this, operation);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
	Ext.define('Intel.data.FastStore', {  //doesn't redundantly call fireEvent... me.sync() calls that downstream 
		extend: 'Ext.data.Store',
		alias: 'store.faststore',

		constructor: function(cfg) {
			var me = this;
			me.callParent(arguments);
		},
		
		afterEdit: function(record, modifiedFieldNames) {
			var me = this, i, shouldSync;
			if (me.autoSync && !me.autoSyncSuspended) {
				for (i = modifiedFieldNames.length; i--;) {
					if (record.fields.get(modifiedFieldNames[i]).persist) {
						me.sync();  //all rendering changes made here
						break;
					}
				}
			}
			me.onUpdate(record, Ext.data.Model.EDIT, modifiedFieldNames);
			//me.fireEvent('update', me, record, Ext.data.Model.EDIT, modifiedFieldNames); //redundant with me.sync()
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
	/**
		Cell editing has redundant calls to store.afterEdit, which in turn renders the page multiple times per edit. 
		fastcellediting solves this by wrapping all the calls in beginEdit and endEdit, so store.afterEdit is called only once
	*/
	Ext.define('Intel.grid.plugin.CellEditing', {
		alias: 'plugin.fastcellediting',
		extend: 'Ext.grid.plugin.CellEditing',

		triggerEvent:'cellclick',
		
		onEditComplete : function(ed, value, startValue) {
			var me = this,
				activeColumn = me.getActiveColumn(),
				context = me.context,
				record;
			if (activeColumn) {
				record = context.record;

				me.setActiveEditor(null);
				me.setActiveColumn(null);
				me.setActiveRecord(null);

				context.value = value;
				if (!me.validateEdit()) {
						me.editing = false;
						return;
				}
				record.beginEdit(); //only call store.AfterEdit at the very End 
				if (!record.isEqual(value, startValue)) 
						record.set(activeColumn.dataIndex, value); //dont call store.AfterEdit

				context.view.focusRow(context.rowIdx, 100);
				me.fireEvent('edit', me, context); //dont call store.AfterEdit if record.set() is called in here
				record.endEdit(); //now call store.AfterEdit!
				me.editing = false;
			}
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
	Ext.define('Intel.view.ScrollTable', {  //keeps the scrollbar steady. Cant believe Extjs cant do this
		extend: 'Ext.view.Table',
		alias: 'widget.scrolltableview',
		
		constructor: function(cfg) {
			var me = this;
			me.callParent(arguments);
		},
		
		refresh: function() {
			var me = this,
				targetEl,
				targetParent,
				oldDisplay,
				nextSibling,
				dom,
				records,
				el = me.getEl(), //edit
				scroll = el && el.getScrollTop();//edit
				
			if (!me.rendered || me.isDestroyed) return;

			if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) {
				targetEl = me.getTargetEl();
				records = me.getViewRange();
				dom = targetEl.dom;
				if (!me.preserveScrollOnRefresh) {
					targetParent = dom.parentNode;
					oldDisplay = dom.style.display;
					dom.style.display = 'none';
					nextSibling = dom.nextSibling;
					targetParent.removeChild(dom);
				}
				if (me.refreshCounter) me.clearViewEl();
				else {
					me.fixedNodes = targetEl.dom.childNodes.length;
					me.refreshCounter = 1;
				}
				me.tpl.append(targetEl, me.collectData(records, me.all.startIndex));

				if (records.length < 1) {
					if (!this.store.loading && (!me.deferEmptyText || me.hasFirstRefresh)) {
						Ext.core.DomHelper.insertHtml('beforeEnd', targetEl.dom, me.emptyText);
					}
					me.all.clear();
				} else {
					me.collectNodes(targetEl.dom);
					me.updateIndexes(0);
				}
				if (me.hasFirstRefresh) {
					if (me.refreshSelmodelOnRefresh !== false) {
						me.selModel.refresh();
					} else {
						me.selModel.pruneIf();
					}
				}
				me.hasFirstRefresh = true;

				if (!me.preserveScrollOnRefresh) {
					targetParent.insertBefore(dom, nextSibling);
					dom.style.display = oldDisplay;
				}

				Ext.suspendLayouts();
				this.refreshSize();
				me.fireEvent('refresh', me);
				Ext.resumeLayouts(true);
				
				if (!me.viewReady) {
					me.viewReady = true;
					me.fireEvent('viewready', me);
				}
			}
			
			if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
		},
		
		onRemove : function(ds, records, indexes) {
			var me = this,
				fireItemRemove = me.hasListeners.itemremove,
				i,
				record,
				index,
				el = me.getEl(),//edit
				scroll = el && el.getScrollTop();//edit

			if (me.all.getCount()) {
				if (me.dataSource.getCount() === 0) {
					if (fireItemRemove) {
						for (i = indexes.length - 1; i >= 0; --i) {
							me.fireEvent('itemremove', records[i], indexes[i]);
						}
					}
					//me.refresh();
				} else {
					for (i = indexes.length - 1; i >= 0; --i) {
						record = records[i];
						index = indexes[i];
						me.doRemove(record, index);
						if (fireItemRemove) {
							me.fireEvent('itemremove', record, index);
						}
					}
					me.updateIndexes(indexes[0]);
				}
				this.refreshSize();
				if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
			}
		},
		
		onUpdate : function(ds, record){
			var me = this,
				index,
				node,
				el = me.getEl(),//edit
				scroll = el && el.getScrollTop();//edit

			if (me.viewReady) {
				index = me.dataSource.indexOf(record);
				if (index > -1) {
					node = me.bufferRender([record], index)[0];
					if (me.getNode(record)) {
						me.all.replaceElement(index, node, true);
						me.updateIndexes(index, index);
						me.selModel.onUpdate(record);
						if (me.hasListeners.itemupdate) {
							me.fireEvent('itemupdate', record, index, node);
						}
						return node;
					}
				}
				if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
			}
		},
		
		onAdd : function(store, records, index) {
			var me = this,
				nodes,
				el = me.getEl(),
				scroll = el && el.getScrollTop();

			if (me.rendered) {
				if (me.all.getCount() === 0) {
					me.refresh();
					nodes = me.all.slice();
				} else {
					nodes = me.doAdd(records, index);
					if (me.refreshSelmodelOnRefresh !== false) {
						me.selModel.refresh();
					}
					me.updateIndexes(index);
					//me.refreshSize(); //already being refreshed by store.sync()
				}

				if (me.hasListeners.itemadd) {
					me.fireEvent('itemadd', records, index, nodes);
				}
				if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
			}
		},

		scrollRowIntoView: function(row) {
			if(row===0){										//this is just added because its a LOT faster and the main use case
				this.getEl().setScrollTop(0);
				return;
			}
			row = this.getNode(row, true);
			if (row) {
				Ext.fly(row).scrollIntoView(this.el, false);
			}
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/************************* USED FOR PROGRAM-BOARD VIEW *********************************************/
	Ext.define('IntelVelocity', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Name', type: 'string'},
			{name: 'PlannedVelocity', type: 'number'},
			{name: 'RealVelocity', type:'number'}
		]
	});
	Ext.define('IntelTeamCommits', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PortfolioItemObjectID', type: 'number'},
			{name: 'PortfolioItemRank', type: 'number'},
			{name: 'PortfolioItemName', type: 'string'},
			{name: 'PortfolioItemFormattedID', type:'string'},
			{name: 'PortfolioItemPlannedEnd', type:'number'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'Commitment', type: 'string'},
			{name: 'Expected', type: 'boolean'},
			{name: 'Objective', type:'string'}
		]
	});
	Ext.define('IntelRisk', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'RiskID', type:'string'},
			{name: 'PortfolioItemObjectID', type:'number'},
			{name: 'PortfolioItemFormattedID',  type: 'string'}, //can be different than PortfolioItemObjectID
			{name: 'PortfolioItemName', type:'string'}, //can be different than PortfolioItemObjectID
			{name: 'Description', type: 'string'}, 
			{name: 'Impact', type: 'string'},	
			{name: 'MitigationPlan', type: 'string'},					
			{name: 'Urgency', type: 'string'},
			{name: 'Status', type: 'string'},
			{name: 'Contact', type: 'string'},
			{name: 'Checkpoint', type: 'number'},
			{name: 'Edited', type: 'boolean'}
		]
	});

	Ext.define('IntelPredecessorItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PredecessorItemID',  type: 'string'}, 
			{name: 'PredecessorUserStoryObjectID', type: 'number'},
			{name: 'PredecessorProjectObjectID',  type: 'number'},
			{name: 'Supported', type: 'string'},
			{name: 'Assigned', type: 'boolean'} 
		]
	});

	Ext.define('IntelPredecessorDependency', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, //can be different than UserStoryObjectID
			{name: 'UserStoryName',  type: 'string'}, //can be different than UserStoryObjectID
			{name: 'Description', type: 'string'},
			{name: 'NeededBy', type: 'number'},
			{name: 'Status', type:'string'},
			{name: 'PredecessorItems', type: 'auto'}, 
			{name: 'Edited', type: 'boolean'}
		]
	});		
		
	Ext.define('IntelSuccessorDependency', { 
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'SuccessorUserStoryObjectID', type: 'string' },
			{name: 'SuccessorProjectObjectID', type: 'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, //can be different than UserStoryObjectID (or null)
			{name: 'UserStoryName', type: 'string'}, //can be different than UserStoryObjectID (or null)
			{name: 'Description', type: 'string'}, 
			{name: 'NeededBy', type: 'number'},
			{name: 'Supported', type: 'string'}, 
			{name: 'Assigned', type: 'boolean'},
			{name: 'Edited', type: 'boolean'}
		]
	});	

	/************************* USED FOR RISKS/DEPS VIEW *********************************************/

	Ext.define('IntelRiskForTracking', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'RiskID', type:'string'},
			{name: 'PortfolioItemObjectID', type:'number'},
			{name: 'PortfolioItemFormattedID',  type: 'string'},
			{name: 'PortfolioItemName', type:'string'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'ProjectObjectID', type:'number'},
			{name: 'Description', type: 'string'},
			{name: 'Impact', type: 'string'},	
			{name: 'MitigationPlan', type: 'string'},					
			{name: 'Urgency', type: 'string'},
			{name: 'Status', type: 'string'},
			{name: 'Contact', type: 'string'},
			{name: 'Checkpoint', type: 'number'},
			{name: 'Edited', type: 'boolean'}
		]
	});

	Ext.define('IntelPredecessorDependencyForTracking', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, 
			{name: 'UserStoryName',  type: 'string'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'ProjectObjectID', type:'number'},
			{name: 'Description', type: 'string'},
			{name: 'NeededBy', type: 'number'},
			{name: 'Status', type:'string'},
			{name: 'PredecessorItems', type: 'auto'}, 
			{name: 'Edited', type: 'boolean'}
		]
	});		


	/************************* USED FOR TEAMCOMMITS VIEW *********************************************/
	Ext.define('CommitsMatrixPortfolioItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PortfolioItemObjectID', type: 'number'},
			{name: 'PortfolioItemRank', type: 'number'},
			{name: 'PortfolioItemName', type: 'string'},
			{name: 'PortfolioItemFormattedID', type:'string'},
			{name: 'PortfolioItemPlannedEnd', type:'number'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'MoSCoW', type: 'string'}
		]
	});

	/************************* USED FOR CUSTOM-FIELD EDITOR *********************************************/
	Ext.define('SAFeCustomFieldsEditorModel', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'ItemFormattedID', type:'string'},
			{name: 'ItemName', type:'string'},
			{name: 'ProjectName', type:'string'},
			{name: 'ReleaseName', type:'string'},
			{name: 'CustomFieldValue',  type: 'string'}
		]
	});
}());
                /** all dependencies are injected, it assumes nothing about the app its mixed into other than it has to derive from IntelRallyApp */
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	var RALLY_MAX_STRING_SIZE = 32768;
	
	Ext.define('RisksLib', {
		requires: ['IntelRallyApp'],
		
		_getRisks: function(portfolioItemRecord){
			var risks = portfolioItemRecord.data.c_Risks;
			try{ risks = JSON.parse(atob(risks)) || {}; } //b64 decode risks
			catch(e) { risks = {}; }
			return risks;
		},
		
		_removeRisk: function(portfolioItemRecord, riskData, projectRecord, risksParsedData){ 
			risksParsedData = risksParsedData || [];
			
			var me=this,
				risks = me._getRisks(portfolioItemRecord),
				projectOID = projectRecord.data.ObjectID,
				deferred = Q.defer();
				
			if(risks[projectOID]){
				delete risks[projectOID][riskData.RiskID];
				
				var indexToSplice = _.findIndex(risksParsedData, function(cachedRisk){ /** update cache */
					return cachedRisk.RiskID === riskData.RiskID && cachedRisk.PortfolioItemObjectID === riskData.PortfolioItemObjectID; 
				});
				if(indexToSplice > -1) risksParsedData.splice(indexToSplice, 1);
				
				var risksString = btoa(JSON.stringify(risks, null, '\t')); //b64 encode 
				if(risksString.length >= RALLY_MAX_STRING_SIZE) 
					deferred.reject('Risks field for ' + portfolioItemRecord.data.FormattedID + ' ran out of space! Cannot save');
				else {
					portfolioItemRecord.set('c_Risks', risksString);
					portfolioItemRecord.save({
						callback:function(record, operation, success){
							if(!success) 
								deferred.reject('Failed to modify ' + me.PortfolioItemTypes[0] + ': ' + portfolioItemRecord.data.FormattedID);
							else deferred.resolve();
						}
					});
				}
			} else deferred.resolve();		
			return deferred.promise;
		},	
		_addRisk: function(portfolioItemRecord, riskData, projectRecord, risksParsedData){
			risksParsedData = risksParsedData || [];
			
			var me=this,
				risks = me._getRisks(portfolioItemRecord),
				projectOID = projectRecord.data.ObjectID,
				deferred = Q.defer();

			riskData = Ext.clone(riskData);
			riskData.Edited = false;
			
			if(!risks[projectOID]) risks[projectOID] = {};
			risks[projectOID][riskData.RiskID] = {
				Checkpoint: riskData.Checkpoint,
				Description: riskData.Description,
				Impact: riskData.Impact,
				MitigationPlan: riskData.MitigationPlan,
				Urgency: riskData.Urgency,
				Status: riskData.Status,
				Contact: riskData.Contact
			};
			
			var indexToSplice = _.findIndex(risksParsedData, function(cachedRisk){ /** update cache */
				return cachedRisk.RiskID === riskData.RiskID && cachedRisk.PortfolioItemObjectID === riskData.PortfolioItemObjectID; 
			});
			if(indexToSplice > -1) risksParsedData.splice(indexToSplice, 1);
			risksParsedData.push(riskData);
			
			var risksString = btoa(JSON.stringify(risks, null, '\t'));
			if(risksString.length >= RALLY_MAX_STRING_SIZE)
				deferred.reject('Risks field for ' + portfolioItemRecord.data.FormattedID + ' ran out of space! Cannot save');
			else {
				portfolioItemRecord.set('c_Risks', risksString);
				portfolioItemRecord.save({
					callback:function(record, operation, success){
						if(!success) 
							deferred.reject('Failed to modify ' + me.PortfolioItemTypes[0] + ': ' + portfolioItemRecord.data.FormattedID);
						else deferred.resolve();
					}
				});
			}	
			return deferred.promise;
		}
	});
}());
                /** all dependencies are injected, it assumes nothing about the app its mixed into other than it has to derive from IntelRallyApp */
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	var RALLY_MAX_STRING_SIZE = 32768;
	
	Ext.define('DependenciesLib', {
		requires: ['IntelRallyApp'],
		
		_getDependencies: function(userStoryRecord){
			var dependencies, dependencyString = userStoryRecord.data.c_Dependencies;
			if(dependencyString === '') dependencies = { Predecessors:{}, Successors:{} };
			else {
				try{ dependencies = JSON.parse(atob(dependencyString)); }
				catch(e) { dependencies = { Predecessors:{}, Successors:{} }; }
			}		
			if(!dependencies.Predecessors) dependencies.Predecessors = {};
			if(!dependencies.Successors) dependencies.Successors = {};
			return dependencies;
		},	
		
		_syncCollection: function(userStoryRecord, depsToAdd, depsToRemove, collectionType){
			/** this function modifies the Predecessor and Successor built in fields on UserStories in Rally to reflect the
				dependencies made in the programBoard. These fields are edited before the c_Dependencies field is saved on the UserStory */
			var me=this, syncDeferred = Q.defer();
			
			depsToAdd = _.filter(depsToAdd, function(objectID){ return !!objectID; });
			depsToRemove = _.filter(depsToRemove, function(objectID){ return !!objectID; });
				
			userStoryRecord.getCollection(collectionType).load({
				fetch:['ObjectID'],
				callback: function(){
					var promises = [],
						syncCollectionProxy = false,
						collectionStore = this,
						collectionRecords = collectionStore.getRange();
					_.each(depsToAdd, function(userStoryObjectID){
						if(!_.find(collectionRecords, function(cr){ return cr.data.ObjectID === userStoryObjectID; })){
							promises.push(me._loadUserStory(userStoryObjectID).then(function(us){
								if(us){ 
									syncCollectionProxy = true; 
									collectionStore.add(us); 
								}
							}));
						}
					});
					_.each(depsToRemove, function(userStoryObjectID){
						var realDep = _.find(collectionRecords, function(cr) { return cr.data.ObjectID === userStoryObjectID; });
						if(realDep) { 
							collectionStore.remove(realDep); 
							syncCollectionProxy = true;
						}
					});
					
					//attempt to sync collection until it passes, 5 == max attempts
					var attempts = 0;
					Q.all(promises)
						.then(function retrySync(){
							if(++attempts > 5){
								me._alert("INFO:", "Failed to modify " + collectionType + " field on " + userStoryRecord.data.FormattedID);
								syncDeferred.resolve();		
							}
							else if(syncCollectionProxy) {
								collectionStore.sync({ 
									failure:function(){ retrySync(); },
									success:function(){ syncDeferred.resolve(); }
								});
							}
							else syncDeferred.resolve();
						})
						.fail(function(reason){ syncDeferred.reject(reason); })
						.done();
				}
			});	
			return syncDeferred.promise;
		},	
		_collectionSynced: function(userStoryRecord, dependencies){
			var me=this, 
				dependenciesString = btoa(JSON.stringify(dependencies, null, '\t')),
				deferred = Q.defer();
			if(dependenciesString.length >= RALLY_MAX_STRING_SIZE) 
				deferred.reject('Dependencies field for ' + userStoryRecord.data.FormattedID + ' ran out of space! Cannot save');
			else {
				userStoryRecord.set('c_Dependencies', dependenciesString);
				//attempt to save until it passes, 5 == max attempts
				var attempts = 0;
				(function retrySync(){
					if(++attempts > 5) deferred.reject('Failed to modify User Story ' + userStoryRecord.data.FormattedID);
					else {
						userStoryRecord.save({
							callback:function(record, operation, success){
								if(!success) retrySync();
								else deferred.resolve();
							}
						});
					}
				}());
			}
			return deferred.promise;
		},	
		_removePredecessor: function(userStoryRecord, predecessorData, currentProjectRecord, dependenciesParsedData){
			dependenciesParsedData = dependenciesParsedData || {};
			dependenciesParsedData.Predecessors = dependenciesParsedData.Predecessors || [];
			
			var me=this, 
				dependencies = me._getDependencies(userStoryRecord),
				cachedPredecessors = dependenciesParsedData.Predecessors,
				depsToAdd = [], 
				depsToRemove = [], 
				dependencyID = predecessorData.DependencyID;

			depsToRemove = _.map(dependencies.Predecessors[dependencyID].PredecessorItems || [], function(item){ 
				return item.PredecessorUserStoryObjectID;
			});
			
			delete dependencies.Predecessors[dependencyID];
			
			if(!currentProjectRecord || (userStoryRecord.data.Project.ObjectID === currentProjectRecord.data.ObjectID)){
				cachedPredecessors = _.filter(cachedPredecessors, function(cachedPredecessor){ 
					return cachedPredecessor.DependencyID !== dependencyID; 
				});
				dependenciesParsedData.Predecessors = cachedPredecessors;
			}
			
			_.each(dependencies.Predecessors, function(predecessor){
				_.each(predecessor.PredecessorItems, function(predecessorItem){
					if(predecessorItem.Assigned){
						depsToRemove = _.filter(depsToRemove, function(userStoryObjectID){ 
							return userStoryObjectID != predecessorItem.PredecessorUserStoryObjectID; 
						});
						depsToAdd = _.union(depsToAdd, [predecessorItem.PredecessorUserStoryObjectID]);
					}
				});
			});
			
			return me._syncCollection(userStoryRecord, depsToAdd, depsToRemove, 'Predecessors').then(function(){ 
				return me._collectionSynced(userStoryRecord, dependencies); 
			});
		},	
		_removeSuccessor: function(userStoryRecord, successorData, currentProjectRecord, dependenciesParsedData){
			dependenciesParsedData = dependenciesParsedData || {};
			dependenciesParsedData.Successors = dependenciesParsedData.Successors || [];
			
			var me=this, 
				dependencies = me._getDependencies(userStoryRecord),
				cachedSuccessors = dependenciesParsedData.Successors,
				depsToAdd = [],
				depsToRemove = [successorData.SuccessorUserStoryObjectID], 
				dependencyID = successorData.DependencyID;
				
			delete dependencies.Successors[dependencyID]; 
			
			if(!currentProjectRecord || (userStoryRecord.data.Project.ObjectID === currentProjectRecord.data.ObjectID)){
				cachedSuccessors = _.filter(cachedSuccessors, function(cachedSuccessor){ 
					return cachedSuccessor.DependencyID !== dependencyID; 
				});
				dependenciesParsedData.Successors = cachedSuccessors;
			}

			_.each(dependencies.Successors, function(successor){
				if(successor.Assigned){
					depsToRemove = _.filter(depsToRemove, function(userStoryObjectID){ 
						return userStoryObjectID != successor.SuccessorUserStoryObjectID; 
					});
					depsToAdd = _.union(depsToAdd, [successor.SuccessorUserStoryObjectID]);
				}
			});
			
			return me._syncCollection(userStoryRecord, depsToAdd, depsToRemove, 'Successors').then(function(){
				return me._collectionSynced(userStoryRecord, dependencies);
			});
		},
		_addPredecessor: function(userStoryRecord, predecessorData, currentProjectRecord, dependenciesParsedData){ 
			dependenciesParsedData = dependenciesParsedData || {};
			dependenciesParsedData.Predecessors = dependenciesParsedData.Predecessors || [];
			
			var me=this, 
				dependencies = me._getDependencies(userStoryRecord),
				cachedPredecessors = dependenciesParsedData.Predecessors,
				depsToAdd = [], 
				dependencyID = predecessorData.DependencyID;
			
			predecessorData = Ext.clone(predecessorData);
			predecessorData.Edited = false;
					
			dependencies.Predecessors[dependencyID] = {
				Description: predecessorData.Description,
				NeededBy: predecessorData.NeededBy,
				Status: predecessorData.Status,
				PredecessorItems: predecessorData.PredecessorItems
			};

			if(!currentProjectRecord || (userStoryRecord.data.Project.ObjectID === currentProjectRecord.data.ObjectID)){
				cachedPredecessors = _.filter(cachedPredecessors, function(cachedPredecessor){ 
					return cachedPredecessor.DependencyID !== dependencyID; 
				});
				cachedPredecessors.push(predecessorData);
				dependenciesParsedData.Predecessors = cachedPredecessors;
			}

			_.each(dependencies.Predecessors, function(predecessor){ 
				_.each(predecessor.PredecessorItems, function(predecessorItem){
					if(predecessorItem.Assigned) depsToAdd = _.union(depsToAdd, [predecessorItem.PredecessorUserStoryObjectID]);
				});
			});
				
			return me._syncCollection(userStoryRecord, depsToAdd, [], 'Predecessors').then(function(){
				return me._collectionSynced(userStoryRecord, dependencies);
			});
		},
		_addSuccessor: function(userStoryRecord, successorData, currentProjectRecord, dependenciesParsedData){ 
			dependenciesParsedData = dependenciesParsedData || {};
			dependenciesParsedData.Successors = dependenciesParsedData.Successors || [];
			
			var me=this, 
				dependencies = me._getDependencies(userStoryRecord),
				cachedSuccessors = dependenciesParsedData.Successors,
				depsToAdd = [],
				dependencyID = successorData.DependencyID;
			
			successorData = Ext.clone(successorData);
			successorData.Edited = false;
				
			dependencies.Successors[dependencyID] = {
				SuccessorUserStoryObjectID: successorData.SuccessorUserStoryObjectID,
				SuccessorProjectObjectID: successorData.SuccessorProjectObjectID,
				Description: successorData.Description,
				NeededBy: successorData.NeededBy,
				Supported: successorData.Supported,
				Assigned: successorData.Assigned
			};

			if(!currentProjectRecord || (userStoryRecord.data.Project.ObjectID === currentProjectRecord.data.ObjectID)){
				cachedSuccessors = _.filter(cachedSuccessors, function(cachedSuccessor){ 
					return cachedSuccessor.DependencyID !== dependencyID; 
				});
				cachedSuccessors.push(successorData);
				dependenciesParsedData.Successors = cachedSuccessors;
			}

			_.each(dependencies.Successors, function(successor){ 
				depsToAdd = _.union(depsToAdd, [successor.SuccessorUserStoryObjectID]);
			});
			
			return me._syncCollection(userStoryRecord, depsToAdd, [], 'Successors').then(function(){
				return me._collectionSynced(userStoryRecord, dependencies);
			});
		},	
	
		_getOldAndNewUserStoryRecords: function(dependencyData, userStoryList){
			var me = this,
				newUserStoryRecord = _.find(userStoryList, function(userStory){
					return userStory.data.FormattedID == dependencyData.UserStoryFormattedID;
				});
				
			function loadOriginalParent(){
				return Q(dependencyData.UserStoryObjectID ? me._loadUserStory(dependencyData.UserStoryObjectID) : null)
				.then(function(oldUserStoryRecord){
					newUserStoryRecord = newUserStoryRecord || oldUserStoryRecord;
					return [oldUserStoryRecord, newUserStoryRecord];
				});
			}
			
			if(newUserStoryRecord){
				return me._loadUserStory(newUserStoryRecord.data.ObjectID).then(function(userStoryRecord){
					newUserStoryRecord = userStoryRecord; 
					return loadOriginalParent();
				});
			} else {
				newUserStoryRecord = null;
				return loadOriginalParent();
			}
		},	
		_getPredecessorItemArrays: function(localPredecessorData, realPredecessorData){ 
			/** returns arrays of the team dependencies from the dependency grouped on their status */
			var me=this, 
				addedItemsData = [], 
				updatedItemsData = [], 
				removedItemsData = [], 
				localPredecessorItemsData = localPredecessorData.PredecessorItems || [], 
				realPredecessorItemsData  = realPredecessorData ? (realPredecessorData.PredecessorItems || []) : [];
			if(!realPredecessorItemsData.length) addedItemsData = localPredecessorItemsData;
			else {		
				Outer:
				for(var i=localPredecessorItemsData.length-1;i>=0;--i){
					for(var j=0;j<realPredecessorItemsData.length;++j){
						if(localPredecessorItemsData[i].PredecessorItemID === realPredecessorItemsData[j].PredecessorItemID){
							updatedItemsData.push(realPredecessorItemsData.splice(j,1)[0]);
							continue Outer;
						}
					}
					addedItemsData.push(localPredecessorItemsData[i]); //teams we just added
				}
				removedItemsData = realPredecessorItemsData; //teams that we just removed	(we didn't splice them out of realPredecessorItemsData)
			}
			return {
				added: addedItemsData,
				updated: updatedItemsData,
				removed: removedItemsData
			};
		},	
		/* returns functions that add successor objects to each of the predecessorItems in the dependency */
		_getAddedPredecessorItemCallbacks: function(
				predecessorItemsData, 
				predecessorData, 
				successorProjectRecord, 
				projectOIDmap, 
				currentProjectRecord, 
				dependenciesParsedData){ 
			var me=this, 
				permissions = me.getContext().getPermissions();
			return Q.all(_.map(predecessorItemsData, function(predecessorItemData){
				return function(){
					var predecessorProjectRecord = projectOIDmap[predecessorItemData.PredecessorProjectObjectID];
					if(!permissions.isProjectEditor(predecessorProjectRecord)) 
						return Q.reject('You lack permissions to modify project: ' + predecessorProjectRecord.data.Name);
					else {
						return me._loadRandomUserStoryFromReleaseTimeframe(predecessorProjectRecord, me.ReleaseRecord).then(function(newUserStory){
							if(!newUserStory){
								return Q.reject('Project ' + predecessorProjectRecord.data.Name + ' has no user stories in this Release, cannot continue');
							} else {
								var newSuccessorDependency = {
									DependencyID: predecessorData.DependencyID,
									SuccessorUserStoryObjectID: predecessorData.UserStoryObjectID,
									SuccessorProjectObjectID: successorProjectRecord.data.ObjectID,
									UserStoryObjectID: newUserStory.data.ObjectID,
									UserStoryFormattedID: '',
									UserStoryName: '',
									Description: predecessorData.Description,
									NeededBy: predecessorData.NeededBy,
									Supported: predecessorItemData.Supported,
									Assigned: false,
									Edited: false
								};
								predecessorItemData.PredecessorUserStoryObjectID = newUserStory.data.ObjectID;
								return me._addSuccessor(newUserStory, newSuccessorDependency, currentProjectRecord, dependenciesParsedData);
							}
						});
					}
				};
			}));
		},	
		/* returns functions that update successor objects to each of the predecessorItems in the dependency */
		_getUpdatedPredecessorItemCallbacks: function(
				predecessorItemsData, 
				predecessorData, 
				successorProjectRecord, 
				projectOIDmap,
				currentProjectRecord, 
				dependenciesParsedData){
			/** NOTE: we dont have to worry about an updated predecessorItem being added to a different predecessor userstory because
				users cannot change the project or userstory of a predecessorItem from the 'dependencies we have on other teams' grid.
				This means we don't have to worry about cloning successor items inside this function
			*/
			var me=this, 
				permissions = me.getContext().getPermissions();
			return Q.all(_.map(predecessorItemsData, function(predecessorItemData){
				return function(){
					var predecessorProjectRecord = projectOIDmap[predecessorItemData.PredecessorProjectObjectID];
					if(!permissions.isProjectEditor(predecessorProjectRecord)) 
						return Q.reject('You lack permissions to modify project: ' + predecessorProjectRecord.data.Name);
					else {
						var updatedSuccessorDependency = {
							DependencyID: predecessorData.DependencyID,
							SuccessorUserStoryObjectID: predecessorData.UserStoryObjectID,
							SuccessorProjectObjectID: successorProjectRecord.data.ObjectID,
							UserStoryObjectID: 0, //need to set this after _loadUserStory
							UserStoryFormattedID: '', //need to set this after _loadUserStory
							UserStoryName: '', //need to set this after _loadUserStory
							Description: predecessorData.Description,
							NeededBy: predecessorData.NeededBy,
							Supported: predecessorItemData.Supported,
							Assigned: false, //need to set this after _loadUserStory
							Edited: false
						};
						return me._loadUserStory(predecessorItemData.PredecessorUserStoryObjectID).then(function(userStory){
							if(!userStory){
								return me._loadRandomUserStoryFromReleaseTimeframe(predecessorProjectRecord, me.ReleaseRecord)
								.then(function(newUserStory){
									if(!newUserStory){
										return Q.reject('Project ' + predecessorProjectRecord.data.Name + ' has no user stories in this Release, cannot continue');
									} else {
										predecessorItemData.PredecessorUserStoryObjectID = newUserStory.data.ObjectID;
										predecessorItemData.Assigned = false;
										
										updatedSuccessorDependency.UserStoryObjectID = newUserStory.data.ObjectID;
										updatedSuccessorDependency.UserStoryName = '';
										updatedSuccessorDependency.FormattedID = '';
										updatedSuccessorDependency.Assigned = false;						
										return me._addSuccessor(newUserStory, updatedSuccessorDependency, currentProjectRecord, dependenciesParsedData); 
									}
								});
							} else {
								updatedSuccessorDependency.UserStoryObjectID = userStory.data.ObjectID;
								updatedSuccessorDependency.UserStoryFormattedID = userStory.data.FormattedID;
								updatedSuccessorDependency.UserStoryName = userStory.data.Name;
								updatedSuccessorDependency.Assigned = predecessorItemData.Assigned;
								return me._addSuccessor(userStory, updatedSuccessorDependency, currentProjectRecord, dependenciesParsedData);
							}
						});
					}
				};
			}));
		},	
		/* returns functions that remove successor objects for each of the predecessorItems in the dependency */
		_getRemovedPredecessorItemCallbacks: function(
				predecessorItemsData, 
				predecessorData, 
				successorProjectRecord, 
				projectOIDmap,
				currentProjectRecord, 
				dependenciesParsedData){
			var me=this, 
				permissions = me.getContext().getPermissions();
			return Q.all(_.map(predecessorItemsData, function(predecessorItemData){
				return function(){
					var predecessorProjectRecord = projectOIDmap[predecessorItemData.PredecessorProjectObjectID];
					if(!permissions.isProjectEditor(predecessorProjectRecord)) 
						return Q.reject('You lack permissions to modify project: ' + predecessorProjectRecord.data.Name);
					else {
						return me._loadUserStory(predecessorItemData.PredecessorUserStoryObjectID).then(function(userStory){
							if(userStory){
								var successorDependency = {
									DependencyID: predecessorData.DependencyID,
									SuccessorUserStoryObjectID: predecessorData.UserStoryObjectID,
									SuccessorProjectObjectID: me.ProjectRecord.data.ObjectID,
									UserStoryObjectID: userStory.data.ObjectID,
									UserStoryFormattedID: '',
									UserStoryName: '',
									Description: '',
									NeededBy: 0,
									Supported: '',
									Assigned: predecessorItemData.Assigned,
									Edited: false
								};
								return me._removeSuccessor(userStory, successorDependency, currentProjectRecord, dependenciesParsedData);
							}
						});
					}
				};
			}));
		},
		/* Updates a single PredecessorItem on the successor for a dependency */
		_updateSuccessor: function(
				predecessorUserStory, 
				successorData, 
				predecessorProjectRecord, 
				projectOIDmap,
				currentProjectRecord, 
				dependenciesParsedData){
			var me=this, 
				permissions = me.getContext().getPermissions(),
				successorProjectRecord = projectOIDmap[successorData.SuccessorProjectObjectID];
			if(!permissions.isProjectEditor(successorProjectRecord)){
				return Q.reject('You lack permissions to modify project: ' + successorProjectRecord.data.Name);
			} else {
				return me._loadUserStory(successorData.SuccessorUserStoryObjectID).then(function(userStory){
					if(!userStory) return Q.reject({SuccessorDeletedDependency:true, message:'Successor UserStory has been deleted.'});
					else {
						var successorsDependencies = me._getDependencies(userStory),
							successorsDependency = successorsDependencies.Predecessors[successorData.DependencyID];
						if(successorsDependency){
							var predecessorData = {
								DependencyID: successorData.DependencyID,
								UserStoryObjectID: userStory.data.ObjectID,
								UserStoryFormattedID: userStory.data.FormattedID,
								UserStoryName: userStory.data.Name,
								Description: successorsDependency.Description,
								NeededBy: successorsDependency.NeededBy,
								Status: successorsDependency.Status,
								PredecessorItems: successorsDependency.PredecessorItems || [], 
								Edited: false
							};
							var predecessorItem = _.find(predecessorData.PredecessorItems, function(predecessorItem){
								return predecessorItem.PredecessorProjectObjectID == predecessorProjectRecord.data.ObjectID;
							});
							if(predecessorItem){
								predecessorItem.PredecessorUserStoryObjectID = predecessorUserStory.data.ObjectID;
								predecessorItem.Supported = successorData.Supported;
								predecessorItem.Assigned = successorData.Assigned;
								return me._addPredecessor(userStory, predecessorData, currentProjectRecord, dependenciesParsedData);
							}
							else return Q.reject({SuccessorDeletedDependency:true, message:'Successor removed this dependency.'});
						}
						else return Q.reject({SuccessorDeletedDependency:true, message:'Successor removed this dependency.'});
					} 
				});
			}
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	var RALLY_MAX_STRING_SIZE = 32768;

	Ext.define('ProgramBoard', {
		extend: 'IntelRallyApp',
		mixins:[
			'WindowListener',
			'PrettyAlert',
			'IframeResize',
			'IntelWorkweek',
			'AsyncQueue',
			'ParallelLoader',
			'UserAppsPreference',
			'SanityDashboardObjectIDPreference',
			'RisksLib',
			'DependenciesLib'
		],
		
		layout: {
			type:'vbox',
			align:'stretch',
			pack:'start'
		},
		items:[{
			xtype:'container',
			height:45,
			id:'navbox',
			layout: {
				type:'hbox',
				align:'stretch',
				pack:'start'
			},
			items:[{
				xtype:'container',
				flex:3,
				id:'navboxLeft',
				layout: {
					type:'hbox'
				}
			},{
				xtype:'container',
				flex:2,
				id:'navboxRight',
				layout: {
					type:'hbox',
					pack:'end'
				}
			}]
		},{
			xtype:'container',
			id:'tcVelBox',
			layout: {
				type:'hbox',
				align:'stretch',
				pack:'start'
			},
			items: [{
				xtype:'container',
				flex:2,
				id: 'tcVelBoxLeft'
			},{
				xtype:'container',
				flex:1,
				id: 'tcVelBoxRight'
			}]
		}],
		minWidth:910, /** thats when rally adds a horizontal scrollbar for a pagewide app */
		
		_userAppsPref: 'intel-SAFe-apps-preference',
		
		/**___________________________________ DATA STORE METHODS ___________________________________*/
		_loadPortfolioItemsOfTypeInRelease: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: OPIOT');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					remoteSort:false,
					fetch: me._portfolioItemFields,
					filters:[{ property:'Release.Name', value:me.ReleaseRecord.data.Name}],
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store);
		},	
		_loadPortfolioItems: function(){ 
			var me=this;
			return Q.all(_.map(me.PortfolioItemTypes, function(type, ordinal){
				return (ordinal ? //only load lowest portfolioItems in Release (upper porfolioItems don't need to be in a release)
						me._loadPortfolioItemsOfType(me.TrainPortfolioProject, type) : 
						me._loadPortfolioItemsOfTypeInRelease(me.TrainPortfolioProject, type)
					)
					.then(function(portfolioStore){
						return {
							ordinal: ordinal,
							store: portfolioStore
						};
					});
				}))
				.then(function(items){
					var orderedPortfolioItemStores = _.sortBy(items, function(item){ return item.ordinal; });
					me.PortfolioItemStore = orderedPortfolioItemStores[0].store;
					me.PortfolioItemMap = {};
					_.each(me.PortfolioItemStore.getRange(), function(lowPortfolioItem){
						var ordinal = 0, 
							parentPortfolioItem = lowPortfolioItem,
							getParentRecord = function(child, parentList){
								return _.find(parentList, function(parent){ return child.data.Parent && parent.data.ObjectID == child.data.Parent.ObjectID; });
							};
						while(ordinal < (orderedPortfolioItemStores.length-1) && parentPortfolioItem){
							parentPortfolioItem = getParentRecord(parentPortfolioItem, orderedPortfolioItemStores[ordinal+1].store.getRange());
							++ordinal;
						}
						if(ordinal === (orderedPortfolioItemStores.length-1) && parentPortfolioItem)
							me.PortfolioItemMap[lowPortfolioItem.data.ObjectID] = parentPortfolioItem.data.Name;
					});
				});
		},
		_loadIterations: function(){
			var me=this,
				startDate =	Rally.util.DateTime.toIsoString(me.ReleaseRecord.data.ReleaseStartDate),
				endDate =	Rally.util.DateTime.toIsoString(me.ReleaseRecord.data.ReleaseDate);
				iterationStore = Ext.create("Rally.data.WsapiDataStore", {
					model: "Iteration",
					remoteSort: false,
					limit:Infinity,
					fetch: ["Name", "EndDate", "StartDate", "PlannedVelocity", "Project", "ObjectID"],
					context:{
						project: me.getContext().getProject()._ref,
						projectScopeUp:false,
						projectScopeDown:false
					},
					filters: [{
						property: "EndDate",
						operator: ">=",
						value: startDate
					},{
						property: "StartDate",
						operator: "<=",
						value: endDate  
					}]
				});
			return me._reloadStore(iterationStore)
				.then(function(iterationStore){ 
					me.IterationStore = iterationStore; 
				});
		},
		_getUserStoryFilter: function(){
			var me=this,
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(me.ReleaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(me.ReleaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property: 'PortfolioItem.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property: 'PortfolioItem.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		_loadUserStories: function(){	
			var me=this, 
				config = {
					model: me.UserStory,
					url: 'https://rally1.rallydev.com/slm/webservice/v2.0/HierarchicalRequirement',
					params: {
						pagesize:200,
						query: me._getUserStoryFilter().toString(),
						fetch:['Name', 'ObjectID', 'Project', 'PlannedEndDate', 'ActualEndDate', 'StartDate', 'EndDate', 'Iteration', 
							'Release', 'Description', 'Tasks', 'PlanEstimate', 'FormattedID', 'ScheduleState', 
							'Blocked', 'BlockedReason', 'Blocker', 'CreationDate', 'PortfolioItem', 'c_Dependencies'].join(','),
						project:me.ProjectRecord.data._ref,
						projectScopeDown:false,
						projectScopeUp:false
					}
				};
			return me._parallelLoadWsapiStore(config).then(function(store){
				me.UserStoryStore = store;
				return store;
			});
		},
		_getExtraSanityUserStoriesFilter: function(){			
			var me = this,
				releaseName = me.ReleaseRecord.data.Name,
				releaseDate = new Date(me.ReleaseRecord.data.ReleaseDate).toISOString(),
				releaseStartDate = new Date(me.ReleaseRecord.data.ReleaseStartDate).toISOString(),
				inIterationButNotReleaseFilter =
					Ext.create('Rally.data.wsapi.Filter', { property: 'Iteration.StartDate', operator:'<', value:releaseDate}).and(
					Ext.create('Rally.data.wsapi.Filter', { property: 'Iteration.EndDate', operator:'>', value:releaseStartDate})).and(
					Ext.create('Rally.data.wsapi.Filter', { property: 'Release.Name', value: null })),
				userStoryProjectFilter = Ext.create('Rally.data.wsapi.Filter', { 
					property: 'Project.ObjectID', 
					value: me.ProjectRecord.data.ObjectID
				});
			return userStoryProjectFilter.and(inIterationButNotReleaseFilter);
		},				
		_loadExtraSanityUserStories: function(){
			var me=this,
				config = {
					model: me.UserStory,
					url: 'https://rally1.rallydev.com/slm/webservice/v2.0/HierarchicalRequirement',
					params: {
						pagesize:200,
						query:me._getExtraSanityUserStoriesFilter().toString(),
						fetch:['Name', 'ObjectID', 'Project', 'PlannedEndDate', 'ActualEndDate', 'StartDate', 'EndDate', 'Iteration', 
							'Release', 'Description', 'Tasks', 'PlanEstimate', 'FormattedID', 'ScheduleState', 
							'Blocked', 'BlockedReason', 'Blocker', 'CreationDate', 'PortfolioItem'].join(','),
						workspace:me.getContext().getWorkspace()._ref,
						includePermissions:true
					}
				};
			return me._parallelLoadWsapiStore(config).then(function(store){
				me.ExtraSanityUserStoriesStore = store;
				return store;
			});
		},
		
		/**___________________________________ TEAM COMMITS STUFF ___________________________________**/		
		_getTeamCommit: function(portfolioItemRecord){	
			var teamCommits = portfolioItemRecord.data.c_TeamCommits,
				projectOID = this.ProjectRecord.data.ObjectID;
			try{ teamCommits = JSON.parse(atob(teamCommits))[projectOID] || {}; } 
			catch(e){ teamCommits = {}; }
			return teamCommits;
		},		
		_setTeamCommit: function(portfolioItemRecord, newTeamCommit){
			var teamCommits = portfolioItemRecord.data.c_TeamCommits,
				projectOID = this.ProjectRecord.data.ObjectID,
				deferred = Q.defer();
			try{ teamCommits = JSON.parse(atob(teamCommits)) || {}; }
			catch(e){ teamCommits = {}; }
			if(!teamCommits[projectOID]) teamCommits[projectOID] = {};
			teamCommits[projectOID].Commitment = newTeamCommit.Commitment;
			teamCommits[projectOID].Objective = newTeamCommit.Objective;
			var str = btoa(JSON.stringify(teamCommits, null, '\t'));
			if(str.length >= RALLY_MAX_STRING_SIZE)
				deferred.reject('TeamCommits field for ' + portfolioItemRecord.data.FormattedID + ' ran out of space! Cannot save');
			else {
				portfolioItemRecord.set('c_TeamCommits', str);
				portfolioItemRecord.save({ 
					callback:function(record, operation, success){
						if(!success) deferred.reject('Failed to modify PortfolioItem: ' + portfolioItemRecord.data.FormattedID);
						else deferred.resolve();
					}
				});
			}
			return deferred.promise;
		},
					
		_getStoryCount: function(portfolioItemObjectID){	
			var me=this;
			me._TeamCommitsCountHash = me._TeamCommitsCountHash || {};
			if(typeof me._TeamCommitsCountHash[portfolioItemObjectID] === 'undefined'){
				me._TeamCommitsCountHash[portfolioItemObjectID] = _.reduce(me.UserStoryStore.getRange(), function(sum, userStory){
					return sum + (userStory.data.PortfolioItem && userStory.data.PortfolioItem.ObjectID == portfolioItemObjectID)*1;
				}, 0);
			}
			return me._TeamCommitsCountHash[portfolioItemObjectID];
		},
		_getStoriesEstimate: function(portfolioItemObjectID){	
			var me=this;
			me._TeamCommitsEstimateHash = me._TeamCommitsEstimateHash || {};
			if(typeof me._TeamCommitsEstimateHash[portfolioItemObjectID] === 'undefined'){
				me._TeamCommitsEstimateHash[portfolioItemObjectID] = _.reduce(me.UserStoryStore.getRange(), function(sum, userStory){
					var isStoryInPortfolioItem = userStory.data.PortfolioItem && userStory.data.PortfolioItem.ObjectID == portfolioItemObjectID;
					return sum + (isStoryInPortfolioItem ? userStory.data.PlanEstimate : 0)*1;
				}, 0);
			}
			return me._TeamCommitsEstimateHash[portfolioItemObjectID];
		},

		/** __________________________________ SANITY STUFF ___________________________________**/
		_getSanityStoreData: function(){ 
			var me = this,
				releaseName = me.ReleaseRecord.data.Name,
				releaseDate = new Date(me.ReleaseRecord.data.ReleaseDate).toISOString(),
				releaseStartDate = new Date(me.ReleaseRecord.data.ReleaseStartDate).toISOString(),
				totalUserStories = me.UserStoryStore.getRange().concat(me.ExtraSanityUserStoriesStore.getRange());
			return [{
				title: 'Unsized Stories',
				userStories: _.filter(totalUserStories, function(item){ 
					if(!item.data.Release || item.data.Release.Name != releaseName) return false;
					return item.data.PlanEstimate === null; 
				})
			},{
				title: 'Improperly Sized Stories',
				userStories: _.filter(totalUserStories,function(item){
					if(!item.data.Release || item.data.Release.Name != releaseName) return false;
					if(item.data.Children.Count === 0) return false;
					var pe = item.data.PlanEstimate;
					return pe!==0 && pe!==1 && pe!==2 && pe!==4 && pe!==8 && pe!==16;
				})
			},{
				title: 'Stories in Release without Iteration',
				userStories: _.filter(totalUserStories,function(item){ 
					if(!item.data.Release || item.data.Release.Name != releaseName) return false;
					return !item.data.Iteration; 
				})
			},{
				title: 'Stories in Iteration not attached to Release',
				userStories: _.filter(totalUserStories,function(item){ 
					if(!item.data.Iteration || item.data.Release) return false;
					return new Date(item.data.Iteration.StartDate) < new Date(releaseDate) && 
						new Date(item.data.Iteration.EndDate) > new Date(releaseStartDate);
				})
			},{
				title: 'Stories with End Date past ' + me.PortfolioItemTypes[0] + ' End Date',
				userStories: _.filter(totalUserStories, function(item){
					if(!item.data.Release || item.data.Release.Name != releaseName) return false;
					if(!item.data.Iteration || !item.data.PortfolioItem || 
						(!item.data.PortfolioItem.PlannedEndDate && !item.data.PortfolioItem.ActualEndDate) || 
						!item.data.Iteration.EndDate) return false;
					return new Date(item.data.PortfolioItem.PlannedEndDate || item.data.PortfolioItem.ActualEndDate) < 
									new Date(item.data.Iteration.EndDate);
				})
			}];
		},

		/**___________________________________ RISKS STUFF ___________________________________**/	
		_parseRisksFromPortfolioItem: function(portfolioItemRecord){
			var me=this,
				array = [],
				projectOID = me.ProjectRecord.data.ObjectID, 
				risksData = me._getRisks(portfolioItemRecord),
				PortfolioItemObjectID = portfolioItemRecord.data.ObjectID,
				PortfolioItemFormattedID = portfolioItemRecord.data.FormattedID,
				PortfolioItemName = portfolioItemRecord.data.Name;
			
			_.each(risksData[projectOID], function(riskData, riskID){
				array.push({
					RiskID: riskID,
					PortfolioItemObjectID: PortfolioItemObjectID,
					PortfolioItemFormattedID: PortfolioItemFormattedID,
					PortfolioItemName: PortfolioItemName,
					Description: riskData.Description,
					Impact: riskData.Impact,
					MitigationPlan: riskData.MitigationPlan,
					Urgency: riskData.Urgency,
					Status: riskData.Status,
					Contact: riskData.Contact,
					Checkpoint: riskData.Checkpoint,
					Edited: false
				});
			});
			return array;
		},	
		_parseRisksData: function(){ 
			var me=this, 
				array = [];
			_.each(me.PortfolioItemStore.getRecords(), function(portfolioItemRecord){
				array = array.concat(me._parseRisksFromPortfolioItem(portfolioItemRecord));
			});
			return array;
		},		
		_spliceRiskFromList: function(riskID, risksData){ 
			/** removes and returns risk with riskID from the risksData (NOT list of records) */
			for(var i = 0; i<risksData.length; ++i){
				if(risksData[i].RiskID == riskID) {
					return risksData.splice(i, 1)[0];
				}
			}
		},	
		_getRealRiskData: function(oldPortfolioItemRecord, riskID){ 
			var me = this, realRisksData;
			if(oldPortfolioItemRecord) realRisksData = me._parseRisksFromPortfolioItem(oldPortfolioItemRecord);
			else realRisksData = [];
			return me._spliceRiskFromList(riskID, realRisksData) || null;		
		},
		
		/**___________________________________ DEPENDENCIES STUFF ___________________________________**/					
		_isUserStoryInRelease: function(userStoryRecord, releaseRecord){ 
			return ((userStoryRecord.data.Release || {}).Name === releaseRecord.data.Name) || 
				(!userStoryRecord.data.Release && ((userStoryRecord.data.PortfolioItem || {}).Release || {}).Name === releaseRecord.data.Name);
		},	
		_spliceDependencyFromList: function(dependencyID, dependenciesData){ 
			for(var i = 0; i<dependenciesData.length; ++i){
				if(dependenciesData[i].DependencyID == dependencyID) {
					return dependenciesData.splice(i, 1)[0];
				}
			}
		},
		_parseDependenciesFromUserStory: function(userStoryRecord){
			var me=this,
				predecessorsAndSuccessorsData = me._getDependencies(userStoryRecord), 
				inputPredecessors = predecessorsAndSuccessorsData.Predecessors, 
				inputSuccessors = predecessorsAndSuccessorsData.Successors,
				outputPredecessors = [], 
				outputSuccessors = [],
				UserStoryObjectID = userStoryRecord.data.ObjectID,
				UserStoryFormattedID = userStoryRecord.data.FormattedID,
				UserStoryName = userStoryRecord.data.Name;
			
			if(me._isUserStoryInRelease(userStoryRecord, me.ReleaseRecord)){
				_.each(inputPredecessors, function(predecessorDependencyData, dependencyID){
					outputPredecessors.push({
						DependencyID: dependencyID,
						UserStoryObjectID: UserStoryObjectID,
						UserStoryFormattedID: UserStoryFormattedID,
						UserStoryName: UserStoryName,
						Description: predecessorDependencyData.Description,
						NeededBy: predecessorDependencyData.NeededBy,
						Status: predecessorDependencyData.Status,
						PredecessorItems: predecessorDependencyData.PredecessorItems || [], 
						Edited: false
					});
				});
			}
			_.each(inputSuccessors, function(successorDependencyData, dependencyID){
				if(successorDependencyData.Assigned){ //if this was just placed on a random user story, or is assigned to this user story
					UserStoryFormattedID = userStoryRecord.data.FormattedID;
					UserStoryName = userStoryRecord.data.Name;
				} 
				else UserStoryFormattedID = UserStoryName = '';
						
				outputSuccessors.push({
					DependencyID: dependencyID,
					SuccessorUserStoryObjectID: successorDependencyData.SuccessorUserStoryObjectID,
					SuccessorProjectObjectID: successorDependencyData.SuccessorProjectObjectID,
					UserStoryObjectID: UserStoryObjectID,
					UserStoryFormattedID: UserStoryFormattedID,
					UserStoryName: UserStoryName,
					Description: successorDependencyData.Description,
					NeededBy: successorDependencyData.NeededBy,
					Supported: successorDependencyData.Supported,
					Assigned: successorDependencyData.Assigned,
					Edited: false
				});
			});
			return {Predecessors:outputPredecessors, Successors:outputSuccessors};
		},
		_parseDependenciesData: function(userStoryList){	
			var me=this, 
				predecessors = [], 
				successors = [];			

			_.each(userStoryList, function(userStoryRecord){
				var predecessorsAndSuccessorsData = me._parseDependenciesFromUserStory(userStoryRecord);
				predecessors = predecessors.concat(predecessorsAndSuccessorsData.Predecessors);
				successors = successors.concat(predecessorsAndSuccessorsData.Successors);
			});
			return {Predecessors:predecessors, Successors:successors};
		},		
		_getRealDependencyData: function(oldUserStoryRecord, dependencyID, type){ 
			var me = this, realDependenciesData;
			if(oldUserStoryRecord) realDependenciesData = me._parseDependenciesFromUserStory(oldUserStoryRecord)[type];
			else realDependenciesData = [];
			return me._spliceDependencyFromList(dependencyID, realDependenciesData) || null;		
		},
		_hydrateDependencyUserStories: function(dependenciesParsedData){
			var me=this, 
				storyOIDsToHydrate = [],
				dependenciesHydratedUserStories = {};
			
			_.each(dependenciesParsedData.Predecessors, function(predecessor){
				_.each(predecessor.PredecessorItems, function(predecessorItem){
					storyOIDsToHydrate.push(predecessorItem.PredecessorUserStoryObjectID);
				});
			});
			_.each(dependenciesParsedData.Successors, function(successor){
				storyOIDsToHydrate.push(successor.SuccessorUserStoryObjectID);
			});
			
			return Q.all(_.map(storyOIDsToHydrate, function(storyOID){
				return me._loadUserStory(storyOID).then(function(userStory){
					if(userStory) dependenciesHydratedUserStories[storyOID] = userStory;
				});
			}))
			.then(function(){ return dependenciesHydratedUserStories; });
		},
		_newPredecessorItem: function(){
			return {
				PredecessorItemID: 'PI' + (new Date() * 1) + '' + (Math.random() * 100 >> 0),
				PredecessorUserStoryObjectID: 0,
				PredecessorProjectObjectID: 0,
				Supported:'Undefined',
				Assigned:false
			};
		},
		
		/**___________________________________ MISC HELPERS ___________________________________*/		
		_htmlEscape: function(str) {
			return String(str)
				//.replace(/&/g, '&amp;')
				.replace(/"/g, '&quot;')
				.replace(/'/g, '&#39;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;');
		},	
		_getDirtyType: function(localRecord, realDataFromServer){ 
			/** if risk or dep record is new/edited/deleted/unchanged */
			if(!realDataFromServer)	return localRecord.data.Edited ? 'New' : 'Deleted'; //we just created the item, or it was deleted by someone else
			else return localRecord.data.Edited ? 'Edited' : 'Unchanged'; //we just edited the item, or it is unchanged
		},
		_updateUserStoryColumnStores: function(){ 
			/** updates the dropdown stores with the most recent user stories in the release (in case some were added */
			var me = this, userStories = me.UserStoriesInRelease;
			if(me.UserStoryFIDStore){
				me.UserStoryFIDStore.removeAll();
				_.each(userStories, function(userStory){
					me.UserStoryFIDStore.add({'FormattedID': userStory.data.FormattedID});
				});
			}
			if(me.UserStoryNameStore){
				me.UserStoryNameStore.removeAll();
				_.each(userStories, function(userStory){
					me.UserStoryNameStore.add({'Name': userStory.data.Name});
				});
			}
		},	
		_updatePortfolioItemColumnStores: function(){ 
			/** updates the dropdown stores with the most recent portfolioItems in the release */
			var me = this, 
				portfolioItems = me.PortfolioItemStore.getRange();
			if(me.PortfolioItemFIDStore){
				me.PortfolioItemFIDStore.removeAll();
				_.each(portfolioItems, function(portfolioItem){
					me.PortfolioItemFIDStore.add({'FormattedID': portfolioItem.data.FormattedID});
				});
			}
			if(me.PortfolioItemNameStore) {
				me.PortfolioItemNameStore.removeAll();
				_.each(portfolioItems, function(portfolioItem){
					me.PortfolioItemNameStore.add({'Name': portfolioItem.data.Name});
				});
			}
		},
		
		/**___________________________________ LOADING AND RELOADING ___________________________________*/
		_isEditingTeamCommits: false, 
		_isEditingVelocity: false,
		
		_isEditing: function(store){
			if(!store) return false;
			return _.some(store.getRange(), function(record){ return record.data.Edited; });
		},		
		_showGrids: function(){
			var me=this;
			if(!me.TeamCommitsGrid){
				me._loadTeamCommitsGrid();
				me._loadVelocityGrid();
				me._loadSanityGrid();
				me._loadRisksGrid();
				me._loadDependenciesGrids();
			}
		},	
		_checkForDuplicates: function(){ 
			/** duplicates are in a list of groups of duplicates for each type */
			var me=this,
				deferred = Q.defer(),
				duplicateRisks = _.filter(_.groupBy(me.RisksParsedData,
					function(risk){ return risk.RiskID; }),
					function(list, riskID){ return list.length > 1; }),
				duplicatePredecessors = _.filter(_.groupBy(me.DependenciesParsedData.Predecessors,
					function(dependency){ return dependency.DependencyID; }),
					function(list, dependencyID){ return list.length > 1; }),
				duplicateSuccessors = _.filter(_.groupBy(me.DependenciesParsedData.Successors,
					function(dependency){ return dependency.DependencyID; }),
					function(list, dependencyID){ return list.length > 1; });
			if(duplicateRisks.length || duplicatePredecessors.length || duplicateSuccessors.length){
				me._clearRefreshInterval();
				me._loadResolveDuplicatesModal(duplicateRisks, duplicatePredecessors, duplicateSuccessors)
					.then(function(){ 
						me._setRefreshInterval(); 
						me._clearEverything();
						me.setLoading('Loading Data');
						return me._reloadStores(); 
					})
					.then(function(){ return me._updateGrids(); })
					.then(function(){ me.setLoading(false); })
					.then(function(){ deferred.resolve(); })
					.fail(function(reason){ deferred.reject(reason); })
					.done();
			} else deferred.resolve();
			
			return deferred.promise;
		},
		_updateGrids: function(){
			var me=this,
				promises = [];
				isEditingRisks = me._isEditing(me.CustomRisksStore),
				isEditingDeps = me._isEditing(me.CustomPredecessorStore) || me._isEditing(me.CustomSuccessorStore);
			if(!me._isEditingVelocity && me.IterationStore && me.UserStoryStore)
				if(me.CustomVelocityStore) me.CustomVelocityStore.intelUpdate();
			if(!me._isEditingTeamCommits && me.PortfolioItemStore && me.UserStoryStore)
				if(me.CustomTeamCommitsStore) me.CustomTeamCommitsStore.intelUpdate();
			if(!isEditingRisks && me.PortfolioItemStore){
				me.RisksParsedData = me._parseRisksData(); 
				me._updatePortfolioItemColumnStores();
				if(me.CustomRisksStore) me.CustomRisksStore.intelUpdate();
			}
			if(!isEditingDeps && me.UserStoryStore && me.PortfolioItemStore){		
				/** me.UserStoriesInRelease is needed because some of the stories in me.UserStoryStore could be from other overlapping releases */
				me.UserStoriesInRelease = _.filter(me.UserStoryStore.getRange(), function(userStoryRecord){ 
					return me._isUserStoryInRelease(userStoryRecord, me.ReleaseRecord); 
				});
				me.DependenciesParsedData = me._parseDependenciesData(me.UserStoryStore.getRange());
				promises.push(me._hydrateDependencyUserStories(me.DependenciesParsedData).then(function(dependenciesHydratedUserStories){
					me.DependenciesHydratedUserStories = dependenciesHydratedUserStories;
					me._updateUserStoryColumnStores();
					if(me.CustomPredecessorStore) me.CustomPredecessorStore.intelUpdate();
					if(me.CustomSuccessorStore) me.CustomSuccessorStore.intelUpdate();
				}));
			}
			return Q.all(promises);
		},	
		_reloadStores: function(){
			var me=this,
				isEditingRisks = me._isEditing(me.CustomRisksStore),
				isEditingDeps = me._isEditing(me.CustomPredecessorStore) || me._isEditing(me.CustomSuccessorStore),
				promises = [];
			promises.push(me._loadExtraSanityUserStories());
			if(!me._isEditingVelocity) 
				promises.push(me._loadIterations());
			if(!me._isEditingTeamCommits && !isEditingRisks) 
				promises.push(me._loadPortfolioItems());
			if(!me._isEditingVelocity && !me._isEditingTeamCommits && !isEditingDeps) 
				promises.push(me._loadUserStories());
			return Q.all(promises);
		},
		_clearEverything: function(){
			var me=this;
			
			me._isEditingTeamCommits = false;
			me._isEditingVelocity = false;
			
			me.PortfolioItemMap = {};
			
			me.UserStoryStore = undefined;
			me.PortfolioItemStore = undefined;
			me.IterationStore = undefined;
			me.SanityStores = undefined;
			
			me.PredecessorGrid = undefined;
			me.SuccessorGrid = undefined;
			me.RisksGrid = undefined;
			me.VelocityGrid = undefined;
			me.TeamCommitsGrid = undefined;
			
			me.CustomPredecessorStore = undefined;
			me.CustomSuccessorStore = undefined;
			me.CustomRisksStore = undefined;
			me.CustomTeamCommitsStore = undefined;
			me.CustomVelocityStore = undefined;
			
			var toRemove = me.down('#tcVelBox').next(), tmp;
			while(toRemove){ //delete risks and dependencies 
				tmp = toRemove.next();
				toRemove.up().remove(toRemove);
				toRemove = tmp;
			}
			me.down('#tcVelBoxLeft').removeAll();
			me.down('#tcVelBoxRight').removeAll();
		},
		_reloadEverything:function(){
			var me = this;
			
			me._clearEverything();
			me.setLoading('Loading Data');
			if(!me.ReleasePicker){ //draw these once, never remove them
				me._loadReleasePicker();
				me._loadTrainPicker();
				me._loadRefreshIntervalCombo();
				me._loadManualRefreshButton();
			}		
			me._enqueue(function(unlockFunc){	
				me._reloadStores()
					.then(function(){ return me._updateGrids(); })
					.then(function(){ return me._checkForDuplicates(); })
					.then(function(){ return me._showGrids(); })
					.fail(function(reason){	me._alert('ERROR', reason || ''); })
					.then(function(){
						unlockFunc();
						me.setLoading(false); 
					})
					.done();
			}, 'Queue-Main');
		},
		
		/**___________________________________ REFRESHING DATA ___________________________________*/	
		_setLoadingMasks: function(){
			var me=this, message = 'Refreshing Data',
				isEditingRisks = me._isEditing(me.CustomRisksStore),
				isEditingDeps = me._isEditing(me.CustomPredecessorStore) || me._isEditing(me.CustomSuccessorStore);			
			if(me.TeamCommitsGrid && !me._isEditingTeamCommits) me.TeamCommitsGrid.setLoading(message);
			if(me.VelocityGrid && !me._isEditingVelocity) me.VelocityGrid.setLoading(message);
			if(me.RisksGrid && !isEditingRisks) me.RisksGrid.setLoading(message);
			if(me.PredecessorGrid && !isEditingDeps) me.PredecessorGrid.setLoading(message);
			if(me.SuccessorGrid && !isEditingDeps) me.SuccessorGrid.setLoading(message);
		},	
		_removeLoadingMasks: function(){
			var me=this,
				isEditingRisks = me._isEditing(me.CustomRisksStore),
				isEditingDeps = me._isEditing(me.CustomPredecessorStore) || me._isEditing(me.CustomSuccessorStore);		
			if(me.TeamCommitsGrid && !me._isEditingTeamCommits) me.TeamCommitsGrid.setLoading(false);
			if(me.VelocityGrid && !me._isEditingVelocity) me.VelocityGrid.setLoading(false);
			if(me.RisksGrid && !isEditingRisks) me.RisksGrid.setLoading(false);
			if(me.PredecessorGrid && !isEditingDeps) me.PredecessorGrid.setLoading(false);
			if(me.SuccessorGrid && !isEditingDeps) me.SuccessorGrid.setLoading(false);
		},	
		_refreshDataFunc: function(){
			var me=this;
			me._setLoadingMasks();
			me._enqueue(function(unlockFunc){
				me._reloadStores()
					.then(function(){ return me._updateGrids(); })
					.then(function(){ return me._checkForDuplicates(); })
					.then(function(){ return me._showGrids(); })
					.fail(function(reason){ me._alert('ERROR', reason || ''); })
					.then(function(){ 
						unlockFunc();
						me._removeLoadingMasks();
					})
					.done();
			}, 'Queue-Main');
		},	
		_clearRefreshInterval: function(){
			var me=this;
			if(me.RefreshInterval){ 
				clearInterval(me.RefreshInterval); 
				me.RefreshInterval = undefined; 
			}	
		},
		_setRefreshInterval: function(){
			var me=this;
			me._clearRefreshInterval();
			if(me.AppsPref.refresh!=='Off')
				me.RefreshInterval = setInterval(function(){ me._refreshDataFunc(); }, me.AppsPref.refresh*1000);
		},
		
		/**___________________________________ LAUNCH ___________________________________*/
		launch: function(){
			var me=this;
			me.setLoading('Loading Configuration');
			me._initDisableResizeHandle();
			me._initFixRallyDashboard();
			if(!me.getContext().getPermissions().isProjectEditor(me.getContext().getProject())) { //permission check
				me.setLoading(false);
				me._alert('ERROR', 'You do not have permissions to edit this project');
				return;
			} 
			me._configureIntelRallyApp()
				.then(function(){
					var scopeProject = me.getContext().getProject();
					return me._loadProject(scopeProject.ObjectID);
				})
				.then(function(scopeProjectRecord){
					me.ProjectRecord = scopeProjectRecord;
					return Q.all([ // 4 streams
						me._loadProjectsWithTeamMembers() /********* 1 ************/
							.then(function(projectsWithTeamMembers){
								me.ProjectsWithTeamMembers = projectsWithTeamMembers;
								me.ProjectNames = _.map(projectsWithTeamMembers, function(project){ return {Name: project.data.Name}; });
								if(!me.ProjectsWithTeamMembers[me.ProjectRecord.data.ObjectID])
									return Q.reject('Please scope to a project that has team members!');
							}),
						me._projectInWhichTrain(me.ProjectRecord) /********* 2 ************/
							.then(function(trainRecord){
								if(trainRecord){
									me.TrainRecord = trainRecord;
									return me._loadTrainPortfolioProject(me.TrainRecord)
										.then(function(trainPortfolioProject){
											me.TrainPortfolioProject = trainPortfolioProject;
										});
								} else {
									me.ProjectNotInTrain = true;
									return me._loadAllTrains()
										.then(function(trainRecords){
											me.AllTrainRecords = trainRecords;
											me.TrainNames = _.map(trainRecords, function(tr){ return {Name: me._getTrainName(tr)}; });
										});
								}
							}),
						me._loadAppsPreference() /********* 3 ************/
							.then(function(appsPref){
								me.AppsPref = appsPref;
								var twelveWeeks = 1000*60*60*24*7*12;
								return me._loadReleasesAfterGivenDate(me.ProjectRecord, (new Date()*1 - twelveWeeks));
							})
							.then(function(releaseRecords){
								me.ReleaseRecords = releaseRecords;
								var currentRelease = me._getScopedRelease(releaseRecords, me.ProjectRecord.data.ObjectID, me.AppsPref);
								if(currentRelease){
									me.ReleaseRecord = currentRelease;
									me.WorkweekData = me._getWorkWeeksForDropdown(currentRelease.data.ReleaseStartDate, currentRelease.data.ReleaseDate);
								}
								else return Q.reject('This project has no releases.');
							}),
						me._loadSanityDashboardObjectID() /********* 4 ************/
							.then(function(objectID){
								me.SanityDashboardObjectID = objectID;
							})
					]);
				})
				.then(function(){
					if(me.ProjectNotInTrain){
						var projectOID = me.ProjectRecord.data.ObjectID;
						if(me.AppsPref.projs[projectOID] && me.AppsPref.projs[projectOID].Train){
							me.TrainRecord = _.find(me.AllTrainRecords, function(p){ return p.data.ObjectID = me.AppsPref.projs[projectOID].Train; });
							if(!me.TrainRecord) me.TrainRecord = me.AllTrainRecords[0];
						} 
						else me.TrainRecord = me.AllTrainRecords[0];
						return me._loadTrainPortfolioProject(me.TrainRecord)
							.then(function(trainPortfolioProject){
								me.TrainPortfolioProject = trainPortfolioProject;
							});
					}
				})
				.then(function(){ 
					me._setRefreshInterval(); 
					return me._reloadEverything();
				})
				.fail(function(reason){
					me.setLoading(false);
					me._alert('ERROR', reason || '');
				})
				.done();
		},
		
		/**___________________________________ NAVIGATION AND STATE ___________________________________*/
		_releasePickerSelected: function(combo, records){
			var me=this, pid = me.ProjectRecord.data.ObjectID;
			if(me.ReleaseRecord.data.Name === records[0].data.Name) return;
			me.setLoading("Saving Preference");
			me.ReleaseRecord = _.find(me.ReleaseRecords, function(rr){ return rr.data.Name == records[0].data.Name; });
			me.WorkweekData = me._getWorkWeeksForDropdown(me.ReleaseRecord.data.ReleaseStartDate, me.ReleaseRecord.data.ReleaseDate);
			if(typeof me.AppsPref.projs[pid] !== 'object') me.AppsPref.projs[pid] = {};
			me.AppsPref.projs[pid].Release = me.ReleaseRecord.data.ObjectID;
			me._saveAppsPreference(me.AppsPref)
				.then(function(){ me._reloadEverything(); })
				.fail(function(reason){ me._alert('ERROR', reason || ''); })
				.then(function(){ me.setLoading(false); })
				.done();
		},				
		_loadReleasePicker: function(){
			var me=this;
			me.ReleasePicker = me.down('#navboxLeft').add({
				xtype:'intelreleasepicker',
				id: 'releasePicker',
				releases: me.ReleaseRecords,
				currentRelease: me.ReleaseRecord,
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					select: me._releasePickerSelected.bind(me)
				}
			});
		},	
		_trainPickerSelected: function(combo, records){
			var me=this, pid = me.ProjectRecord.data.ObjectID;
			if(me._getTrainName(me.TrainRecord) == records[0].data.Name) return;
			me.setLoading("Saving Preference");
			me.TrainRecord = _.find(me.AllTrainRecords, function(tr){ return me._getTrainName(tr) == records[0].data.Name; });
			if(typeof me.AppsPref.projs[pid] !== 'object') me.AppsPref.projs[pid] = {};
			me.AppsPref.projs[pid].Train = me.TrainRecord.data.ObjectID;
			Q.all([
				me._saveAppsPreference(me.AppsPref),
				me._loadTrainPortfolioProject(me.TrainRecord)
					.then(function(trainPortfolioProject){
						me.TrainPortfolioProject = trainPortfolioProject;
					})
			])
				.then(function(){ me._reloadEverything(); })
				.fail(function(reason){ me._alert('ERROR', reason || ''); })
				.then(function(){ me.setLoading(false); })
				.done();
		},	
		_loadTrainPicker: function(){
			var me=this;
			if(me.ProjectNotInTrain){
				me.down('#navboxLeft').add({
					xtype:'intelfixedcombo',
					width:240,
					labelWidth:40,
					store: Ext.create('Ext.data.Store', {
						fields: ['Name'],				
						data: me.TrainNames
					}),
					displayField: 'Name',
					fieldLabel: 'Train:',
					value: me._getTrainName(me.TrainRecord),
					listeners: {
						change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
						select: me._trainPickerSelected.bind(me)
					}
				});
			}
		},	
		_refreshComboSelected: function(combo, records){
			var me=this, rate = records[0].data.Rate;
			if(me.AppsPref.refresh === rate) return;
			me.AppsPref.refresh = rate;
			me._setRefreshInterval();
			me.setLoading("Saving Preference");
			me._saveAppsPreference(me.AppsPref)
				.fail(function(reason){ me._alert('ERROR', reason || ''); })
				.then(function(){ me.setLoading(false); })
				.done();
		},			
		_loadRefreshIntervalCombo: function(){
			var me=this;
			me.down('#navboxRight').add({
				xtype:'intelfixedcombo',
				store: Ext.create('Ext.data.Store', {
					fields: ['Rate'],
					data: [
						{Rate: 'Off'},
						{Rate: '10'},
						{Rate: '15'},
						{Rate: '30'},
						{Rate: '60'},
						{Rate: '120'}
					]
				}),
				displayField: 'Rate',
				fieldLabel: 'Auto-Refresh Rate (seconds):',
				value:me.AppsPref.refresh,
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					select: me._refreshComboSelected.bind(me)
				}
			});
		},
		_loadManualRefreshButton: function(){
			var me=this;
			me.down('#navboxRight').add({
				xtype:'button',
				id: 'manualRefreshButton',
				text:'Refresh Data',
				width:100,
				listeners:{
					click: me._refreshDataFunc.bind(me)
				}
			});
		},

		/**___________________________________ RENDER RESOLVE DUPLICATES ___________________________________*/	
		_loadResolveDuplicatesModal: function(duplicateRisks, duplicatePredecessors, duplicateSuccessors){
			var me=this,
				deferred = Q.defer(),
				defaultRenderer = function(val){ return val || '-'; },	
				modal = Ext.create('Ext.window.Window', {
					modal:true,
					closable:false,
					title:'ERROR: Duplicate Risks and/or Dependencies!',
					cls:'duplicates-modal',
					overflowY: 'scroll',
					resizable: true,
					height:me.getHeight()*0.9>>0,
					width:Math.min(900, me.getWidth()*0.9>>0),
					y:5,
					items: [{
						xtype:'container',
						html:'<p>Use the checkboxes to select which of the duplicates you want to keep. ' + 
							'You have to keep exactly 1 of the duplicates. When you have finished, click Done.</p><br/>',
						manageHeight:false
					}].concat(duplicateRisks.length ? [{
							xtype:'container',
							html:'<h2 class="grid-group-header">Duplicate Risks</h2>',
							manageHeight:false
						}].concat(_.map(duplicateRisks, function(risksOfOneID){
							return {
								xtype:'rallygrid',
								cls: 'program-board-grid duplicate-risks-grid rally-grid',
								columnCfgs: [{
									text:'#',
									dataIndex:'PortfolioItemFormattedID',
									width:80,
									editor: false,
									resizable:false,
									draggable:false,
									sortable:true,
									renderer:defaultRenderer
								},{
									text: me.PortfolioItemTypes[0], 
									dataIndex:'PortfolioItemName',
									flex:1,
									editor: false,
									resizable:false,
									draggable:false,
									sortable:true,
									renderer:defaultRenderer
								},{
									text:'Risk Description (If This...)', 
									dataIndex:'Description',
									flex:1,
									editor: false,
									resizable:false,
									draggable:false,
									sortable:false,
									renderer:defaultRenderer	
								},{
									text:'Impact (Then this...)', 
									dataIndex:'Impact',
									flex:1,
									resizable:false,
									draggable:false,
									sortable:false,
									editor: false,
									renderer:defaultRenderer
								},{
									text:'Mitigation Plan', 
									dataIndex:'MitigationPlan',
									flex:1,
									resizable:false,
									draggable:false,
									sortable:false,
									editor: false,
									renderer:defaultRenderer
								},{
									text:'Status',
									dataIndex:'Status',
									width:100,		
									tooltip:'(ROAM)',
									tooltipType:'title',		
									editor:false,
									resizable:false,
									draggable:false,
									sortable:true,
									renderer:function(val, meta){
										meta.tdCls += (val==='Undefined' ? ' risks-grid-error-cell' : '');
										return val || '-';
									}	
								},{
									text:'Contact', 
									dataIndex:'Contact',	
									flex:1,
									editor: false,
									sortable:false,
									resizable:false,
									draggable:false,
									renderer:defaultRenderer		
								},{
									text:'Checkpoint',	
									dataIndex:'Checkpoint',
									width:90,
									resizable:false,	
									draggable:false,			
									editor:false,
									sortable:true,
									renderer:function(date){ return date ? 'ww' + me._getWorkweek(date) : '-'; }
								}],
								selModel: Ext.create('Ext.selection.CheckboxModel', {
									mode:'SINGLE',
									allowDeselect:false
								}),
								listeners:{ viewready: function(){ this.getSelectionModel().select(0); }},
								manageHeight:false,
								sortableColumns:false,
								showRowActionsColumn:false,
								showPagingToolbar:false,
								enableEditing:false,
								store:Ext.create('Rally.data.custom.Store', { data: risksOfOneID })
							};
						})
					) : []).concat(duplicatePredecessors.length ? [{
							xtype:'container',
							html:'<h2 class="grid-group-header">Duplicate Predecessors</h2>',
							manageHeight:false
						}].concat(_.map(duplicatePredecessors, function(predecessorsOfOneID){
							return {
								xtype:'rallygrid',
								cls: 'program-board-grid duplicate-predecessors-grid rally-grid',
								columnCfgs: [{
									text:'#', 
									dataIndex:'UserStoryFormattedID',
									width:90,
									resizable:false,
									draggable:false,
									sortable:true,
									editor:false,
									renderer: defaultRenderer
								},{
									text:'UserStory', 
									dataIndex:'UserStoryName',
									flex:1,
									resizable:false,
									draggable:false,			
									sortable:true,
									editor:false,
									renderer: defaultRenderer
								},{
									text:'Dependency Description', 
									dataIndex:'Description',
									flex:1,
									resizable:false,	
									draggable:false,		
									sortable:false,
									editor:false,
									renderer: defaultRenderer			
								},{
									text:'Needed By',			
									dataIndex:'NeededBy',
									width:90,
									resizable:false,
									draggable:false,
									sortable:true,
									editor:false,
									renderer: function(date){ return (date ? 'ww' + me._getWorkweek(date) : '-');}
								},{
									text:'Teams Depended On',
									dataIndex:'DependencyID',
									xtype:'fastgridcolumn',
									html:	'<div class="predecessor-items-grid-header" style="width:10px !important;"></div>' +
											'<div class="predecessor-items-grid-header" style="width:110px !important;">Team Name</div>' +
											'<div class="predecessor-items-grid-header" style="width:95px  !important;">Supported</div>' +
											'<div class="predecessor-items-grid-header" style="width:70px  !important;">#</div>' +
											'<div class="predecessor-items-grid-header" style="width:130px !important;">User Story</div>',
									width:420,
									resizable:false,
									draggable:false,
									sortable:false,
									renderer: function(dependencyID, meta, record, rowIndex){
										var swallowEventHandler = {
											element: 'el',
											fn: function(a){ a.stopPropagation(); }
										};
										var predecessorItemColumnCfgs = [{
											dataIndex:'PredecessorProjectObjectID',
											width:115,
											resizable:false,
											renderer: function(val, meta){
												var projectRecord = me.ProjectsWithTeamMembers[val];
												if(val && projectRecord) return projectRecord.data.Name;
												else return '-';
											},
											editor: false
										},{
											dataIndex:'Supported',
											width:80,
											resizable:false,
											editor: false,
											renderer: function(val, meta){
												if(val == 'No') meta.tdCls = 'predecessor-item-not-supported-cell';
												else if(val == 'Yes') meta.tdCls = 'predecessor-item-supported-cell';
												return val;
											}
										},{
											dataIndex:'PredecessorUserStoryObjectID',
											width:75,
											resizable:false,
											editor: false,
											renderer: function(userStoryObjectID, meta, predecessorItemRecord){
												if(predecessorItemRecord.data.Assigned){
													var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
													if(userStory) return userStory.data.FormattedID;
													else return '?';
												}
												else return '-';
											}
										},{
											dataIndex:'PredecessorUserStoryObjectID',
											width:140,
											resizable:false,
											editor: false,
											renderer: function(userStoryObjectID, meta, predecessorItemRecord){
												if(predecessorItemRecord.data.Assigned){
													var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
													if(userStory) return userStory.data.Name;
													else return '?';
												}
												else return '-';
											}				
										}];
										
										return {
											xtype: 'rallygrid',
											cls:'program-board-grid duplicate-predecessor-items-grid rally-grid',
											viewConfig: { stripeRows:false },
											width:420,
											manageHeight:false,
											columnCfgs: predecessorItemColumnCfgs,
											listeners: {
												mousedown: swallowEventHandler,
												mousemove: swallowEventHandler,
												mouseout: swallowEventHandler,
												mouseover: swallowEventHandler,
												mouseup: swallowEventHandler,
												mousewheel: swallowEventHandler,
												scroll: swallowEventHandler,
												click: swallowEventHandler,
												dblclick: swallowEventHandler,
												contextmenu: swallowEventHandler,
												selectionchange: function(){ this.getSelectionModel().deselectAll(); }
											},
											rowLines:false,
											disableSelection: true,
											scroll:false,
											hideHeaders:true,
											showRowActionsColumn:false,
											showPagingToolbar:false,
											enableEditing:false,
											store: Ext.create('Rally.data.custom.Store', { data: predecessorsOfOneID[rowIndex].PredecessorItems })
										};
									}
								}],
								selModel: Ext.create('Ext.selection.CheckboxModel', {
									mode:'SINGLE',
									allowDeselect:false
								}),
								listeners:{ viewready: function(){ this.getSelectionModel().select(0); }},
								manageHeight:false,
								sortableColumns:false,
								showRowActionsColumn:false,
								showPagingToolbar:false,
								enableEditing:false,
								store:Ext.create('Rally.data.custom.Store', { data: predecessorsOfOneID })
							};
						})
					) : []).concat(duplicateSuccessors.length ? [{
							xtype:'container',
							html:'<h2 class="grid-group-header">Duplicate Successors</h2>'
						}].concat(_.map(duplicateSuccessors, function(successorsOfOneID){
							return {
								xtype:'rallygrid',
								cls: 'program-board-grid duplicate-successors-grid rally-grid',
								columnCfgs: [{	
									text:'Requested By',
									dataIndex:'SuccessorProjectObjectID',
									width:160,
									resizable:false,
									draggable:false,
									editor: false,
									sortable:true,
									renderer: function(projectOID){ return me.ProjectsWithTeamMembers[projectOID].data.Name; }
								},{
									text:'Req #',
									dataIndex:'SuccessorUserStoryObjectID',
									width:90,
									resizable:false,
									draggable:false,
									editor: false,
									sortable:true,
									renderer: function(userStoryObjectID){
										var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
										if(userStory) return userStory.data.FormattedID;
										else return '?';
									}
								},{
									text:'Req UserStory',
									dataIndex:'SuccessorUserStoryObjectID',
									flex:1,
									resizable:false,
									draggable:false,
									editor: false,
									sortable:true,
									renderer: function(userStoryObjectID){
										var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
										if(userStory) return userStory.data.Name;
										else return '?';
									}
								},{
									text:'Dependency Description', 
									dataIndex:'Description',
									flex:1,
									resizable:false,
									draggable:false,
									editor: false,
									sortable:false					
								},{
									text:'Needed By',
									dataIndex:'NeededBy',
									width:80,
									resizable:false,
									draggable:false,
									editor: false,
									sortable:true,
									renderer: function(date){ return (date ? 'ww' + me._getWorkweek(date) : '-');}	
								},{
									text:'Supported',					
									dataIndex:'Supported',
									width:90,
									resizable:false,
									draggable:false,
									editor: false,
									renderer: function(val, meta){
										if(val == 'No') meta.tdCls = 'successor-not-supported-cell';
										else if(val == 'Yes') meta.tdCls = 'successor-supported-cell';
										return val;
									}
								},{
									text:'Sup #', 
									dataIndex:'UserStoryFormattedID',
									width:90,
									resizable:false,
									draggable:false,
									editor: false,
									sortable:true,
									renderer:function(val, meta, record){ return val || '-';  }
								},{
									text:'Sup UserStory', 
									dataIndex:'UserStoryName',
									flex:1,
									resizable:false,
									draggable:false,
									editor:{
										xtype:'intelcombobox',
										store: me.UserStoryNameStore,
										displayField: 'Name'
									},
									sortable: true,
									renderer:function(val, meta, record){ return val || '-';  }
								}],
								selModel: Ext.create('Ext.selection.CheckboxModel', {
									mode:'SINGLE',
									allowDeselect:false
								}),
								listeners:{ viewready: function(){ this.getSelectionModel().select(0); }},
								manageHeight:false,
								sortableColumns:false,
								showRowActionsColumn:false,
								showPagingToolbar:false,
								enableEditing:false,
								store:Ext.create('Rally.data.custom.Store', { data: successorsOfOneID })
							};
						})
					) : []).concat([{
						xtype:'button',
						cls:'done-button',
						text:'Done',
						handler:function(){
							var grids = Ext.ComponentQuery.query('rallygrid', modal),
								riskGrids = _.filter(grids, function(grid){ return grid.hasCls('duplicate-risks-grid'); }),
								predecessorGrids = _.filter(grids, function(grid){ return grid.hasCls('duplicate-predecessors-grid'); }),
								successorGrids = _.filter(grids, function(grid){ return grid.hasCls('duplicate-successors-grid'); });

							modal.setLoading('Removing Duplicates');
							Q.all([
								Q.all(_.map(riskGrids, function(grid){ 
									var riskToKeep = grid.getSelectionModel().getSelection()[0],
										risksToDelete = _.filter(grid.store.getRange(), function(item){ return item.id != riskToKeep.id; });
									return Q.all(_.map(risksToDelete, function(riskRecord){
										var deferred = Q.defer();
										/** create a mutex for each portfolio item across all grids, so we don't overwrite ourselves on accident */
										me._enqueue(function(unlockFunc){
											me._loadPortfolioItemByOrdinal(riskRecord.data.PortfolioItemObjectID, 0)
											.then(function(oldPortfolioItemRecord){	
												var realRiskData = me._getRealRiskData(oldPortfolioItemRecord, riskRecord.data.RiskID);							
												if(!realRiskData) return;
												return me._removeRisk(oldPortfolioItemRecord, realRiskData, me.ProjectRecord, me.RisksParsedData);
											})
											.then(function(){ deferred.resolve(); })
											.fail(function(reason){ deferred.reject(reason); })
											.then(function(){ unlockFunc(); })
											.done();
										}, 'Queue-' + riskRecord.data.PortfolioItemObjectID); 
										return deferred.promise;
									}));
								})),
								Q.all(_.map(predecessorGrids, function(grid){ 
									var predecessorToKeep = grid.getSelectionModel().getSelection()[0],
										predecessorsToRemove = _.filter(grid.store.getRange(), function(item){ return item.id != predecessorToKeep.id; });
									return Q.all(_.map(predecessorsToRemove, function(predecessorRecord){			
										var deferred = Q.defer();
										/** this is about as fine grained as I want to get with 1 queue. otherwise we might end up with deadlock */
										me._enqueue(function(unlockFunc){
											me._getOldAndNewUserStoryRecords(predecessorRecord.data, me.UserStoriesInRelease).then(function(records){
												var oldUserStoryRecord = records[0],
													realPredecessorData = me._getRealDependencyData(
														oldUserStoryRecord, predecessorRecord.data.DependencyID, 'Predecessors');
												if(!realPredecessorData) return;
												return me._getRemovedPredecessorItemCallbacks(
														realPredecessorData.PredecessorItems,  
														realPredecessorData,
														me.ProjectRecord,
														me.ProjectsWithTeamMembers,
														me.ProjectRecord,
														me.DependenciesParsedData).then(function(removedCallbacks){
													var promise = Q();
													_.each(removedCallbacks, function(callback){ promise = promise.then(callback); });													
													return promise.then(function(){
														return me._removePredecessor(
															oldUserStoryRecord, realPredecessorData, me.ProjectRecord, me.DependenciesParsedData);
													});
												});											
											})
											.then(function(){ deferred.resolve(); })
											.fail(function(reason){ deferred.reject(reason); })
											.then(function(){ unlockFunc(); })
											.done();
										}, 'Queue-Dependencies'); 
										return deferred.promise;
									}))
									.then(function(){
										var deferred = Q.defer();
										/** this is about as fine grained as I want to get with 1 queue. otherwise we might end up with deadlock */
										me._enqueue(function(unlockFunc){
											me._getOldAndNewUserStoryRecords(predecessorToKeep.data, me.UserStoriesInRelease).then(function(records){
												var oldUserStoryRecord = records[0],
													realPredecessorData = me._getRealDependencyData(
														oldUserStoryRecord, predecessorToKeep.data.DependencyID, 'Predecessors');
												if(!realPredecessorData) return;
												return me._getAddedPredecessorItemCallbacks(
														realPredecessorData.PredecessorItems, 
														realPredecessorData,
														me.ProjectRecord,
														me.ProjectsWithTeamMembers,
														me.ProjectRecord,
														me.DependenciesParsedData).then(function(addedCallbacks){
													var promise = Q();
													_.each(addedCallbacks, function(callback){ promise = promise.then(callback); });			
													return promise.then(function(){
														return me._addPredecessor(
															oldUserStoryRecord, realPredecessorData, me.ProjectRecord, me.DependenciesParsedData);
													});
												});											
											})
											.then(function(){ deferred.resolve(); })
											.fail(function(reason){ deferred.reject(reason); })
											.then(function(){ unlockFunc(); })
											.done();
										}, 'Queue-Dependencies'); 
										return deferred.promise;
									});
								})),
								Q.all(_.map(successorGrids, function(grid){ //dont edit it's successor userStory 
									var successorToKeep = grid.getSelectionModel().getSelection()[0],
										successorsToDelete = _.filter(grid.store.getRange(), function(item){ return item.id != successorToKeep.id; });		
									return Q.all(_.map(successorsToDelete, function(successorRecord){
										var deferred = Q.defer();
										/** this is about as fine grained as I want to get with 1 queue. otherwise we might end up with deadlock */
										me._enqueue(function(unlockFunc){
											me._getOldAndNewUserStoryRecords(successorRecord.data, me.UserStoriesInRelease).then(function(records){
												var oldUserStoryRecord = records[0],
													realSuccessorData = me._getRealDependencyData(
														oldUserStoryRecord, successorRecord.data.DependencyID, 'Successors');		
												if(!realSuccessorData) return;
												return me._removeSuccessor(oldUserStoryRecord, realSuccessorData, me.ProjectRecord, me.DependenciesParsedData);
											})
											.then(function(){ deferred.resolve(); })
											.fail(function(reason){ deferred.reject(reason); })
											.then(function(){ unlockFunc(); })
											.done();
										}, 'Queue-Dependencies'); 
										return deferred.promise;
									}));
								}))
							]).then(function(){
								modal.destroy();
								deferred.resolve();
							})
							.fail(function(reason){ 
								modal.destroy();
								deferred.reject(reason); 
							})
							.done();
						}
					}])
				});
			setTimeout(function(){ modal.show(); }, 10);
			return deferred.promise;
		},
		
		/**___________________________________ RENDER GRIDS ___________________________________*/	
		_loadTeamCommitsGrid: function(){
			var me = this;	
			
			me._TeamCommitsCountHash = {};
			me._TeamCommitsEstimateHash = {};
			
			var customTeamCommitsRecords = _.map(_.sortBy(me.PortfolioItemStore.getRecords(), 
				function(portfolioItemRecord){ return portfolioItemRecord.data.DragAndDropRank; }),
				function(portfolioItemRecord, index){
					var teamCommit = me._getTeamCommit(portfolioItemRecord);
					return {
						PortfolioItemObjectID: portfolioItemRecord.data.ObjectID,
						PortfolioItemRank: index + 1,
						PortfolioItemName: portfolioItemRecord.data.Name,
						PortfolioItemFormattedID: portfolioItemRecord.data.FormattedID,
						PortfolioItemPlannedEnd: new Date(portfolioItemRecord.data.PlannedEndDate)*1,
						TopPortfolioItemName: me.PortfolioItemMap[portfolioItemRecord.data.ObjectID],
						Commitment: teamCommit.Commitment || 'Undecided',
						Objective: teamCommit.Objective || '',
						Expected: teamCommit.Expected || false
					};
				});
				
			me.CustomTeamCommitsStore = Ext.create('Intel.data.FastStore', {
				data: customTeamCommitsRecords,
				model:'IntelTeamCommits',
				autoSync:true,
				limit:Infinity,
				proxy: {
					type:'fastsessionproxy',
					id:'TeamCommitsProxy' + Math.random()
				},
				intelUpdate: function(){
					var teamCommitsStore = me.CustomTeamCommitsStore;
					teamCommitsStore.suspendEvents(true);
					_.each(teamCommitsStore.getRange(), function(teamCommitsRecord){
						var portfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(portfolioItem){
							return portfolioItem.data.ObjectID == teamCommitsRecord.data.PortfolioItemObjectID;
						});
						if(portfolioItemRecord) {
							var newVal = me._getTeamCommit(portfolioItemRecord);
							if(teamCommitsRecord.data.Commitment != newVal.Commitment)
								teamCommitsRecord.set('Commitment', newVal.Commitment || 'Undecided');
							if(teamCommitsRecord.data.Objective != (newVal.Objective || ''))
								teamCommitsRecord.set('Objective', newVal.Objective || '');
							if(teamCommitsRecord.data.Expected != newVal.Expected)
								teamCommitsRecord.set('Expected', newVal.Expected);
						}
					});
					teamCommitsStore.resumeEvents();
				}
			});
					
			var filterTopPortfolioItem = null, filterCommitment = null, filterEndDate = null;
			function teamCommitsFilter(teamCommitsRecord){
				if(filterTopPortfolioItem &&  teamCommitsRecord.data.TopPortfolioItemName != filterTopPortfolioItem) return false;
				if(filterCommitment && teamCommitsRecord.data.Commitment != filterCommitment) return false;
				if(filterEndDate && me._roundDateDownToWeekStart(teamCommitsRecord.data.PortfolioItemPlannedEnd)*1 != filterEndDate) return false;
				return true;
			}		
			function filterTeamCommitsRowsByFn(fn){
				/** NOTE: using the CSS program-board-hidden-grid-row for display requires us to make fixed grid heights */
				_.each(me.CustomTeamCommitsStore.getRange(), function(item, index){
					if(fn(item)) me.TeamCommitsGrid.view.removeRowCls(index, 'program-board-hidden-grid-row '); 
					else me.TeamCommitsGrid.view.addRowCls(index, 'program-board-hidden-grid-row ');
				});
			}
						
			var columnCfgs = [{
				text:'#',
				dataIndex:'PortfolioItemRank',
				width:30,
				editor:false,
				sortable:true,
				draggable:false,
				resizable:false,
				tooltip: me.PortfolioItemTypes[0] + ' Rank',
				tooltipType:'title'
			},{
				text:'ID', 
				dataIndex:'PortfolioItemFormattedID',
				width:60,
				editor:false,
				sortable:true,
				draggable:false,
				resizable:false,
				renderer:function(portfolioItemFormattedID, meta, teamCommitsRecord){
					var portfolioItem = me.PortfolioItemStore.findExactRecord('FormattedID', portfolioItemFormattedID);
					if(teamCommitsRecord.data.Expected) meta.tdCls += ' manager-expected-cell';
					if(portfolioItem.data.Project){
						return '<a href="https://rally1.rallydev.com/#/' + portfolioItem.data.Project.ObjectID + 
							'd/detail/portfolioitem/' + me.PortfolioItemTypes[0] + '/' + 
								portfolioItem.data.ObjectID + '" target="_blank">' + portfolioItemFormattedID + '</a>';
					}
					else return portfolioItemFormattedID;
				}
			},{
				text: me.PortfolioItemTypes[0],
				dataIndex:'PortfolioItemName',
				flex:1,
				editor:false,
				draggable:false,
				resizable:false
			},{
				text: me.PortfolioItemTypes[me.PortfolioItemTypes.length - 1], 
				dataIndex:'TopPortfolioItemName',
				width:90,
				editor:false,
				draggable:false,
				resizable:false,
				layout:'hbox',
				items:[{
					id:'team-commits-top-portfolio-item-filter',
					xtype:'intelfixedcombo',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['TopPortfolioItemName'],
						data: [{TopPortfolioItemName:'All'}].concat(_.map(_.sortBy(_.union(_.values(me.PortfolioItemMap)), 
							function(topPortfolioItemName){ return topPortfolioItemName; }), 
							function(topPortfolioItemName){ return {TopPortfolioItemName: topPortfolioItemName}; }))
					}),
					displayField: 'TopPortfolioItemName',
					value:'All',
					listeners:{
						focus: function(combo) { combo.expand(); },
						select: function(combo, selected){
							if(selected[0].data.TopPortfolioItemName == 'All') filterTopPortfolioItem = null; 
							else filterTopPortfolioItem = selected[0].data.TopPortfolioItemName;
							filterTeamCommitsRowsByFn(teamCommitsFilter);
						}
					}
				}, {xtype:'container', width:5}]
			},{
				text:'Stories', 
				dataIndex:'PortfolioItemObjectID',
				sortable:true, 
				editor:false,
				draggable:false,
				resizable:false,
				doSort: function(direction){
					this.up('grid').getStore().sort({
						sorterFn: function(item1, item2){
							var diff = me._getStoryCount(item1.data.PortfolioItemObjectID) - me._getStoryCount(item2.data.PortfolioItemObjectID);
							if(diff === 0) return 0;
							return (direction=='ASC' ? 1 : -1) * (diff > 0 ? 1 : -1);
						}
					});
				},
				width:70,
				renderer:function(oid){ return me._getStoryCount(oid); }
			},{
				text:'Plan Estimate', 
				dataIndex:'PortfolioItemObjectID',
				sortable:true, 
				editor:false,
				draggable:false,
				resizable:false,
				doSort: function(direction){
					var ds = this.up('grid').getStore();
					var field = this.getSortParam();
					ds.sort({
						sorterFn: function(item1, item2){ //sort by stories for this team in each portfolioItem
							var diff = me._getStoriesEstimate(item1.data.PortfolioItemObjectID) - me._getStoriesEstimate(item2.data.PortfolioItemObjectID);
							if(diff === 0) return 0;
							return (direction=='ASC' ? 1 : -1) * (diff > 0 ? 1 : -1);
						}
					});
				},
				width:70,
				renderer:function(oid){ return me._getStoriesEstimate(oid); }
			},{
				text:'Planned End',
				dataIndex:'PortfolioItemPlannedEnd',
				sortable:true, 
				editor:false,
				draggable:false,
				resizable:false,
				width:100,
				renderer: function(ed){ return (ed ? 'ww' + me._getWorkweek(new Date(ed)) : '-'); },
				layout:'hbox',
				items: [{	
					id:'team-commits-end-filter',
					xtype:'intelfixedcombo',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						model:'WorkweekDropdown',
						data: [{DateVal:0, Workweek:'All'}].concat(_.map(_.sortBy(_.union(_.map(me.PortfolioItemStore.getRange(),
							function(portfolioItem){ return me._roundDateDownToWeekStart(portfolioItem.data.PlannedEndDate)*1; })),
							function(date){ return date; }),
							function(date){ return {DateVal:date, Workweek:'ww' + me._getWorkweek(date)}; }))
					}),
					displayField: 'Workweek',
					valueField: 'DateVal',
					value:'All',
					listeners:{
						focus: function(combo) { combo.expand(); },
						select: function(combo, selected){
							if(selected[0].data.DateVal === 0) filterEndDate = null; 
							else filterEndDate = selected[0].data.DateVal;
							filterTeamCommitsRowsByFn(teamCommitsFilter);
						}
					}
				}, {xtype:'container', width:5}]
			},{
				dataIndex:'Commitment',
				text:'Commitment',	
				width:100,
				tdCls: 'intel-editor-cell',	
				sortable:true, 
				draggable:false,
				resizable:false,
				editor:{
					xtype:'intelfixedcombo',
					store: Ext.create('Ext.data.Store', {
						fields: ['Commitment'],
						data:[
							{Commitment:'Undecided'},
							{Commitment:'N/A'},
							{Commitment:'Committed'},
							{Commitment:'Not Committed'}
						]
					}),
					displayField: 'Commitment'
				},	
				layout:'hbox',
				items: [{	
					id:'team-commits-commitment-filter',
					xtype:'intelfixedcombo',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['Commitment'],
						data: [
							{Commitment: 'All'},
							{Commitment:'Undecided'},
							{Commitment:'N/A'},
							{Commitment:'Committed'},
							{Commitment:'Not Committed'}
						]
					}),
					displayField: 'Commitment',
					value:'All',
					listeners:{
						focus: function(combo) { combo.expand(); },
						select: function(combo, selected){
							if(selected[0].data.Commitment == 'All') filterCommitment = null; 
							else filterCommitment = selected[0].data.Commitment;
							filterTeamCommitsRowsByFn(teamCommitsFilter);
						}
					}
				}, {xtype:'container', width:5}]	
			},{
				text:'Objective', 
				dataIndex:'Objective',
				flex:1,
				tdCls: 'intel-editor-cell',	
				editor: 'inteltextarea',
				draggable:false,
				resizable:false,
				sortable:false,
				renderer: function(val){ return val || '-'; }
			}];

			me.TeamCommitsGrid = me.down('#tcVelBoxLeft').add({
				xtype: 'rallygrid',
				cls: 'program-board-grid team-commits-grid rally-grid',
				header: {
					layout: 'hbox',
					items: [{
						xtype:'text',
						cls:'program-board-grid-header-text',
						width:200,
						text:"TEAM COMMITS"
					},{
						xtype:'container',
						flex:1000,
						layout:{
							type:'hbox',
							pack:'end'
						},
						items:[{
							xtype:'button',
							text:'Remove Filters',
							width:110,
							listeners:{
								click: function(){
									filterTopPortfolioItem = null;
									filterCommitment = null;
									filterEndDate = null; 
									filterTeamCommitsRowsByFn(function(){ return true; });
									Ext.getCmp('team-commits-top-portfolio-item-filter').setValue('All');
									Ext.getCmp('team-commits-commitment-filter').setValue('All');
									Ext.getCmp('team-commits-end-filter').setValue('All');
								}
							}
						}]
					}]
				},
				height:410,
				scroll:'vertical',
				columnCfgs: columnCfgs,
				disableSelection: true,
				plugins: [ 'fastcellediting' ],
				viewConfig:{
					xtype:'scrolltableview',
					stripeRows:true,
					preserveScrollOnRefresh:true,
					getRowClass: function(teamCommitsRecord, index, rowParams, store){
						var val = teamCommitsRecord.data.Commitment || 'Undecided',
							outputClasses = teamCommitsFilter(teamCommitsRecord) ? '' : ' program-board-hidden-grid-row ';
						if(val == 'N/A') return outputClasses + ' team-commits-grey-row ';
						else if(val == 'Committed') return outputClasses + ' team-commits-green-row ';
						else if(val == 'Not Committed') return outputClasses + ' team-commits-red-row ';
						else return outputClasses;
					}
				},
				listeners: {
					sortchange: function(){ filterTeamCommitsRowsByFn(teamCommitsFilter); },
					beforeedit: function(){ me._isEditingTeamCommits = true; },
					canceledit: function(){ me._isEditingTeamCommits = false; },
					edit: function(editor, e){
						var grid = e.grid, teamCommitsRecord = e.record,
							field = e.field, value = e.value, originalValue = e.originalValue;						
						if(value === originalValue) {
							me._isEditingTeamCommits = false;
							return; 
						}
						else if(field != 'Objective' && !value){ 
							teamCommitsRecord.set(field, originalValue); 
							me._isEditingTeamCommits = false;
							return; 
						}
						else if(field==='Objective'){
							value = me._htmlEscape(value);			
							teamCommitsRecord.set(field, value);
						}
						var tc = {
							Commitment: teamCommitsRecord.data.Commitment, 
							Objective: teamCommitsRecord.data.Objective 
						};	
						me.TeamCommitsGrid.setLoading("Saving");
						me._enqueue(function(unlockFunc){
							me._loadPortfolioItemByOrdinal(teamCommitsRecord.data.PortfolioItemObjectID, 0).then(function(realPortfolioItem){
								if(realPortfolioItem) return me._setTeamCommit(realPortfolioItem, tc);
							})
							.fail(function(reason){ me._alert('ERROR', reason || ''); })
							.then(function(){ 
								unlockFunc();
								me.TeamCommitsGrid.setLoading(false);
								me._isEditingTeamCommits = false;
							})
							.done();
						}, 'Queue-Main');
					}
				},
				showRowActionsColumn:false,
				showPagingToolbar:false,
				enableEditing:false,
				store: me.CustomTeamCommitsStore
			});	
		},		
		_loadVelocityGrid: function() {
			var me = this,
				iterationGroups = _.groupBy(me.UserStoryStore.getRecords(), function(us) { 
					return us.data.Iteration ? us.data.Iteration.Name : '__DELETE__' ; 
				});
			delete iterationGroups.__DELETE__; //ignore those not in an iteration
			
			var iterationGroupTotals = _.sortBy(_.map(me.IterationStore.getRecords(), function(iteration) {
				var iName = iteration.data.Name;
				return {    
					Name:iName, 
					PlannedVelocity: iteration.data.PlannedVelocity || 0,
					RealVelocity:_.reduce((iterationGroups[iName] || []), function(sum, us) { return sum + us.data.PlanEstimate; }, 0)
				};
			}), 'Name');
			
			me.CustomVelocityStore = Ext.create('Intel.data.FastStore', {
				data: iterationGroupTotals,
				model:'IntelVelocity',
				autoSync:true,
				limit:Infinity,
				proxy: {
					type:'fastsessionproxy',
					id:'VelocityProxy' + Math.random()
				},
				intelUpdate: function(){
					var velocityStore = me.CustomVelocityStore;
					velocityStore.suspendEvents(true);
					_.each(velocityStore.getRange(), function(velocityRecord){
						var iterationName = velocityRecord.data.Name,
							iteration = me.IterationStore.findExactRecord('Name', iterationName),
							newVal = iteration.data.PlannedVelocity || 0;
						if(newVal != velocityRecord.data.PlannedVelocity){
							velocityRecord.set('PlannedVelocity', iteration.data.PlannedVelocity || 0);
						}
					});
					velocityStore.resumeEvents();
				}
			});
			
			var columnCfgs = [{	
				text: 'Iteration',
				dataIndex: 'Name', 
				flex: 1,
				editor:false,
				draggable:false,
				resizable:false,
				sortable:true,
				renderer:function(iterationName, meta, velocityRecord){
					var iteration = me.IterationStore.findExactRecord('Name', iterationName);
					if(iteration.data.Project) {
						return '<a href="https://rally1.rallydev.com/#/' + iteration.data.Project.ObjectID + 'd/detail/iteration/' + 
								iteration.data.ObjectID + '" target="_blank">' + iterationName + '</a>';
					}
					else return iterationName;
				}
			},{
				text: 'Target Capacity',
				dataIndex: 'PlannedVelocity',
				width:80,
				tdCls: 'intel-editor-cell',
				editor:'textfield',
				draggable:false,
				resizable:false,
				sortable:true,
				tooltip:'(Planned Velocity)',
				tooltipType:'title',
				renderer:function(val, meta, record){
					meta.tdCls += (val*1===0 ? ' velocity-grid-error-cell ' : '');
					return val;
				}
			},{
				text: 'Actual Load',
				dataIndex: 'RealVelocity',
				width:80,
				editor:false,
				draggable:false,
				resizable:false,
				sortable:true,
				tooltip:'(Plan Estimate)',
				tooltipType:'title',
				renderer:function(realVel, meta, record){
					meta.tdCls += ((realVel*1 < record.data.PlannedVelocity*0.9) ? ' velocity-grid-warning-cell ' : '');
					meta.tdCls += ((realVel*1 === 0 || realVel*1 > record.data.PlannedVelocity*1) ? ' velocity-grid-error-cell ' : '');
					return realVel;
				}
			}];		
			var totalsColumnCfgs = [{	
				flex: 1,
				editor:false,
				draggable:false,
				resizable:false,
				renderer:function(name, meta, velocityRecord){ return '<b>TOTAL</b>'; }
			},{
				width:80,
				editor:false,
				draggable:false,
				resizable:false,
				renderer:function(){
					return _.reduce(me.IterationStore.getRecords(), function(sum, i){ return sum + (i.data.PlannedVelocity || 0); }, 0);
				}
			},{
				width:80,
				editor:false,
				draggable:false,
				resizable:false,
				renderer:function(value, meta){
					var planned = _.reduce(me.IterationStore.getRecords(), function(sum, i){ return sum + (i.data.PlannedVelocity || 0); }, 0),
						real = _.reduce(me.IterationStore.getRecords(), function(bigSum, iteration){
							return bigSum + _.reduce((iterationGroups[iteration.data.Name] || []), function(sum, us) {
								return sum + us.data.PlanEstimate;
							}, 0);
						}, 0);
					meta.tdCls += ((real < planned*0.9) ? ' velocity-grid-warning-cell ' : '');
					meta.tdCls += ((real*1 === 0 || real*1 > planned) ? ' velocity-grid-error-cell ' : '');
					return real;
				}
			}];
			
			me.VelocityGrid = me.down('#tcVelBoxRight').add({
				xtype: 'rallygrid',
				cls: 'program-board-grid velociy-grid rally-grid',
				title: "Velocity",
				viewConfig: {
					stripeRows: true,
					preserveScrollOnRefresh:true
				},
				plugins: ['fastcellediting'],
				listeners: {
					beforeedit: function(editor, e){
						me._isEditingVelocity = true;
						return true;
					},
					canceledit: function(){ me._isEditingVelocity = false; },
					edit: function(editor, e){
						var grid = e.grid,
							velocityRecord = e.record,
							value = e.value,
							originalValue = e.originalValue;
						
						if(value.length===0 || isNaN(value) || (value*1<0) || (value*1 === originalValue*1)) { 
							velocityRecord.set('PlannedVelocity', originalValue);
							me._isEditingVelocity = false; 
							return; 
						}
						value = value*1 || 0; //value*1 || null to remove the 0's from teams
						var iterationName = velocityRecord.data.Name,
							iteration = me.IterationStore.findExactRecord('Name', iterationName); //we don't need the most recent iteration here
						iteration.set('PlannedVelocity', value);
						me.VelocityGrid.setLoading("Saving");
						me._enqueue(function(unlockFunc){
							iteration.save({ 
								callback: function(record, operation, success){
									if(!success){
										me._alert('ERROR', 'Could not modify Iteration');
										velocityRecord.set('PlannedVelocity', originalValue);
									} 
									else velocityRecord.set('PlannedVelocity', value);
									me._isEditingVelocity = false;
									me.VelocityGrid.setLoading(false);
									me.VelocityTotalsGrid.view.refreshNode(0);
									unlockFunc();
								} 
							});
						}, 'Queue-Main');
					}
				},
				enableEditing:false,
				showPagingToolbar: false,
				showRowActionsColumn:false,
				disableSelection: true,
				columnCfgs: columnCfgs,
				store: me.CustomVelocityStore
			});
			me.VelocityTotalsGrid = me.down('#tcVelBoxRight').add({
				xtype: 'rallygrid',
				cls: 'program-board-grid velociy-grid rally-grid',
				showPagingToolbar: false,
				showRowActionsColumn:false,
				hideHeaders:true,
				disableSelection: true,
				viewConfig: {
					stripeRows: false,
					preserveScrollOnRefresh:true
				},
				enableEditing:false,
				columnCfgs:totalsColumnCfgs,
				store: Ext.create('Ext.data.Store', {
					model:'IntelVelocity',
					data: [{Name:'', PlannedVelocity:0, RealVelocity:0}]
				})
			});
		},
		_loadSanityGrid: function(){
			var me=this,
				columnCfgs = [{
					dataIndex:'title',
					flex:1,
					renderer:function(val, meta){ 
						meta.tdCls += ' mini-sanity-name-cell';
						if(val == 'Unsized Stories') meta.tdCls += ' green-bg-cell';
						if(val == 'Improperly Sized Stories') meta.tdCls += ' aqua-bg-cell';
						if(val == 'Stories in Release without Iteration') meta.tdCls += ' silver-bg-cell';
						if(val == 'Stories in Iteration not attached to Release') meta.tdCls += ' orange-bg-cell';
						if(val == 'Stories with End Date past ' + me.PortfolioItemTypes[0] + ' End Date') meta.tdCls += ' lime-bg-cell';
						return val; 
					}
				},{
					dataIndex:'userStories',
					width:30,
					renderer:function(val, meta){ 
						meta.tdCls += 'mini-sanity-num-cell';
						if(val.length === 0) meta.tdCls += ' mini-sanity-green-cell';
						else meta.tdCls += ' mini-sanity-red-cell';
						return val.length; 
					}
				}];
			
			me.SanityGrid = me.down('#tcVelBoxRight').add({
				xtype: 'rallygrid',
				cls: 'program-board-grid mini-sanity-grid rally-grid',
				header: {
					items: [{
						xtype:'container',
						html: me.SanityDashboardObjectID ? 
							('<a class="mini-sanity-header" href="https://rally1.rallydev.com/#/' + me.ProjectRecord.data.ObjectID + 
								'ud/custom/' + me.SanityDashboardObjectID + '" target="_blank">DATA INTEGRITY</a>') :
							'<span class="mini-sanity-header">DATA INTEGRITY</a>'
					}]
				},
				viewConfig: {
					stripeRows: false,
					preserveScrollOnRefresh:true
				},
				columnCfgs:columnCfgs,
				store: Ext.create('Ext.data.Store', {
					fields:[
						{name: 'title', type: 'string'},
						{name: 'userStories', type: 'auto'}
					],
					data: me._getSanityStoreData()
				}),
				enableEditing:false,
				showPagingToolbar: false,
				showRowActionsColumn:false,
				hideHeaders:true,
				disableSelection: true
			});
		},
		_loadRisksGrid: function(){
			var me = this,
				defaultRenderer = function(val){ return val || '-'; };		
			
			/****************************** STORES FOR THE DROPDOWNS  ***********************************************/	
			me.PortfolioItemFIDStore = Ext.create('Ext.data.Store', {
				fields: ['FormattedID'],
				data: _.map(me.PortfolioItemStore.getRange(), function(item){ return {'FormattedID': item.data.FormattedID}; }),
				sorters: { property: 'FormattedID' }
			});	
			me.PortfolioItemNameStore = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(me.PortfolioItemStore.getRange(), function(item){ return {'Name': item.data.Name }; }),
				sorters: { property: 'Name' }
			});
			
			/****************************** RISKS STUFF  ***********************************************/		
			me.CustomRisksStore = Ext.create('Intel.data.FastStore', { 
				data: Ext.clone(me.RisksParsedData),
				autoSync:true,
				model:'IntelRisk',
				limit:Infinity,
				proxy: {
					type:'fastsessionproxy',
					id:'RiskProxy' + Math.random()
				},
				sorters: [function riskSorter(o1, o2){ return o1.data.RiskID > o2.data.RiskID ? -1 : 1; }],
				intelUpdate: function(){
					var riskStore = me.CustomRisksStore, 
						riskRecords = riskStore.getRange(),
						realRisksData = me.RisksParsedData.slice(), //'real' risks list
						remoteChanged = false; //if someone else updated this while it was idle on our screen	
					riskStore.suspendEvents(true); //batch
					_.each(riskRecords, function(riskRecord){
						var realRiskData = me._spliceRiskFromList(riskRecord.data.RiskID, realRisksData),
							dirtyType = me._getDirtyType(riskRecord, realRiskData);
						if(dirtyType === 'New' || dirtyType === 'Edited'){} //we don't want to remove any pending changes on a record							
						else if(dirtyType == 'Deleted') // the riskRecord was deleted by someone else, and we arent editing it
							riskStore.remove(riskRecord);
						else { //we are not editing it and it still exists and it was edited somewhere else, so update current copy
							_.each(realRiskData, function(value, field){
								if(!_.isEqual(riskRecord.data[field], value)) remoteChanged = true;
							});
							if(remoteChanged){
								riskRecord.beginEdit();
								_.each(realRiskData, function(value, field){ riskRecord.set(field, realRiskData[field]); });
								riskRecord.endEdit();
							}
						}
					});
					_.each(realRisksData, function(realRiskData){ //add all the new risks that other people have added since first load
						riskStore.add(Ext.create('IntelRisk', Ext.clone(realRiskData)));
					});
					riskStore.resumeEvents();
				}
			});
			
			var filterFID = null, 
				filterName = null, 
				filterStatus = null, 
				filterCheckpoint = null;
			function riskGridFilter(riskRecord){
				if(filterFID && riskRecord.data.PortfolioItemFormattedID != filterFID) return false;
				if(filterName && riskRecord.data.PortfolioItemName != filterName) return false;
				if(filterStatus && riskRecord.data.Status != filterStatus) return false;
				if(filterCheckpoint && me._roundDateDownToWeekStart(riskRecord.data.Checkpoint)*1 != filterCheckpoint) return false;
				return true;
			}		
			function filterRisksRowsByFn(fn){
				_.each(me.CustomRisksStore.getRange(), function(item, index){
					if(fn(item)) me.RisksGrid.view.removeRowCls(index, 'program-board-hidden-grid-row');
					else me.RisksGrid.view.addRowCls(index, 'program-board-hidden-grid-row');
				});
			}
			function removeFilters(){
				filterFID = null;
				filterName = null;
				filterStatus = null;
				filterCheckpoint = null; 
				filterRisksRowsByFn(function(){ return true; });
				Ext.getCmp('risk-fid-filter').setValue('All');
				Ext.getCmp('risk-name-filter').setValue('All');
				Ext.getCmp('risk-status-filter').setValue('All');
				Ext.getCmp('risk-checkpoint-filter').setValue('All');
			}
			
			function getFIDfilterOptions(){
				return [{FormattedID: 'All'}].concat(_.map(_.sortBy(_.union(_.map(me.CustomRisksStore.getRange(), 
					function(r){ return r.data.PortfolioItemFormattedID; })), 
					function(f){ return f; }), 
					function(f){ return {FormattedID:f}; }));
			}
			function getNameFilterOptions(){
				return [{Name: 'All'}].concat(_.map(_.sortBy(_.union(_.map(me.CustomRisksStore.getRange(), 
					function(r){ return r.data.PortfolioItemName; })), 
					function(f){ return f; }), 
					function(n){ return {Name:n}; }));
			}
			function getCheckpointFilterOptions(){
				return [{DateVal:0, Workweek:'All'}].concat(_.map(_.sortBy(_.union(_.map(me.CustomRisksStore.getRange(),
					function(risk){ return me._roundDateDownToWeekStart(risk.data.Checkpoint)*1; })),
					function(date){ return date; }),
					function(date){ return {DateVal:date, Workweek:'ww' + me._getWorkweek(date)}; }));
			}
			function updateFilterOptions(){
				var fidStore = Ext.getCmp('risk-fid-filter').getStore(),
					nameStore = Ext.getCmp('risk-name-filter').getStore(),
					checkpointStore = Ext.getCmp('risk-checkpoint-filter').getStore();
				fidStore.removeAll();
				fidStore.add(getFIDfilterOptions());
				nameStore.removeAll();
				nameStore.add(getNameFilterOptions());
				checkpointStore.removeAll();
				checkpointStore.add(getCheckpointFilterOptions());
			}
			
			var columnCfgs = [{
				text:'#',
				dataIndex:'PortfolioItemFormattedID',
				tdCls: 'intel-editor-cell',	
				width:80,
				editor:{
					xtype:'intelcombobox',
					width:80,
					store: me.PortfolioItemFIDStore,
					displayField: 'FormattedID'
				},			
				resizable:false,
				draggable:false,
				sortable:true,
				renderer:defaultRenderer,
				layout:'hbox',
				items:[{	
					id:'risk-fid-filter',
					xtype:'intelcombobox',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['FormattedID'],
						data: getFIDfilterOptions()
					}),
					displayField: 'FormattedID',
					value:'All',
					listeners:{
						select: function(combo, selected){
							if(selected[0].data.FormattedID == 'All') filterFID = null; 
							else filterFID = selected[0].data.FormattedID;
							filterRisksRowsByFn(riskGridFilter);
						}
					}
				}, {xtype:'container', width:5}]
			},{
				text: me.PortfolioItemTypes[0], 
				dataIndex:'PortfolioItemName',
				tdCls: 'intel-editor-cell',	
				flex:1,
				editor:{
					xtype:'intelcombobox',
					store: me.PortfolioItemNameStore,
					displayField: 'Name'
				},
				resizable:false,
				draggable:false,
				sortable:true,
				renderer:defaultRenderer,
				layout:'hbox',
				items:[{	
					id:'risk-name-filter',
					xtype:'intelcombobox',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['Name'],
						data: getNameFilterOptions()
					}),
					displayField: 'Name',
					value:'All',
					listeners:{
						select: function(combo, selected){
							if(selected[0].data.Name == 'All') filterName = null; 
							else filterName = selected[0].data.Name;
							filterRisksRowsByFn(riskGridFilter);
						}
					}
				}, {xtype:'container', width:5}]		
			},{
				text:'Risk Description (If This...)', 
				dataIndex:'Description',
				tdCls: 'intel-editor-cell',	
				flex:1,
				editor: 'inteltextarea',
				resizable:false,
				draggable:false,
				sortable:false,
				renderer:defaultRenderer	
			},{
				text:'Impact (Then this...)', 
				dataIndex:'Impact',
				tdCls: 'intel-editor-cell',	
				flex:1,
				resizable:false,
				draggable:false,
				sortable:false,
				editor: 'inteltextarea',
				renderer:defaultRenderer
			},{
				text:'Mitigation Plan', 
				dataIndex:'MitigationPlan',
				tdCls: 'intel-editor-cell',	
				flex:1,
				resizable:false,
				draggable:false,
				sortable:false,
				editor: 'inteltextarea',
				renderer:defaultRenderer
			},{
				text:'Status',
				dataIndex:'Status',
				tdCls: 'intel-editor-cell',	
				width:100,		
				tooltip:'(ROAM)',
				tooltipType:'title',		
				editor:{
					xtype:'intelfixedcombo',
					store: Ext.create('Ext.data.Store', {
						fields: ['Status'],
						data:[
							{Status:'Undefined'},
							{Status:'Resolved'},
							{Status:'Owned'},
							{Status:'Accepted'},
							{Status:'Mitigated'}
						]
					}),
					displayField:'Status'
				},
				resizable:false,
				draggable:false,
				sortable:true,
				renderer:function(val, meta){
					meta.tdCls += (val==='Undefined' ? ' risks-grid-error-cell' : '');
					return val || '-';
				},	
				layout:'hbox',
				items: [{	
					id:'risk-status-filter',
					xtype:'intelfixedcombo',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['Status'],
						data: [
							{Status: 'All'},
							{Status:'Undefined'},
							{Status:'Resolved'},
							{Status:'Owned'},
							{Status:'Accepted'},
							{Status:'Mitigated'}
						]
					}),
					displayField: 'Status',
					value:'All',
					listeners:{
						focus: function(combo) { combo.expand(); },
						select: function(combo, selected){
							if(selected[0].data.Status == 'All') filterStatus = null; 
							else filterStatus = selected[0].data.Status;
							filterRisksRowsByFn(riskGridFilter);
						}
					}
				}, {xtype:'container', width:5}]		
			},{
				text:'Contact', 
				dataIndex:'Contact',
				tdCls: 'intel-editor-cell',	
				flex:1,
				editor: 'inteltextarea',
				sortable:false,
				resizable:false,
				draggable:false,
				renderer:defaultRenderer		
			},{
				text:'Checkpoint',	
				dataIndex:'Checkpoint',
				tdCls: 'intel-editor-cell',	
				width:90,
				resizable:false,	
				draggable:false,			
				editor:{
					xtype:'intelfixedcombo',
					width:80,
					store: Ext.create('Ext.data.Store', {
						model:'WorkweekDropdown',
						data: me.WorkweekData
					}),
					displayField: 'Workweek',
					valueField: 'DateVal'
				},
				sortable:true,
				renderer:function(date){ return date ? 'ww' + me._getWorkweek(date) : '-'; },	
				layout:'hbox',
				items: [{	
					id:'risk-checkpoint-filter',
					xtype:'intelfixedcombo',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						model:'WorkweekDropdown',
						data: getCheckpointFilterOptions()
					}),
					displayField: 'Workweek',
					valueField: 'DateVal',
					value:'All',
					listeners:{
						focus: function(combo) { combo.expand(); },
						select: function(combo, selected){
							if(selected[0].data.DateVal === 0) filterCheckpoint = null; 
							else filterCheckpoint = selected[0].data.DateVal;
							filterRisksRowsByFn(riskGridFilter);
						}
					}
				}, {xtype:'container', width:5}]		
			},{
				text:'',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, riskRecord, row, col){
					var realRiskData = me._spliceRiskFromList(riskRecord.data.RiskID, me.RisksParsedData.slice()),
						dirtyType = me._getDirtyType(riskRecord, realRiskData),
						clickFnName = 'Click' + riskRecord.id.replace(/\-/g, 'z') + 'Fn' + col;
					if(dirtyType !== 'Edited') return;
					meta.tdAttr = 'title="Undo"';
					window[clickFnName] = function(){
						var realRiskData = me._spliceRiskFromList(riskRecord.data.RiskID, me.RisksParsedData.slice());
						riskRecord.beginEdit();
						_.each(realRiskData, function(value, field){ riskRecord.set(field, value); });
						riskRecord.endEdit();
						updateFilterOptions();
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-undo"></i></div>';
				}
			},{
				text:'',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, riskRecord, row, col){
					var realRiskData = me._spliceRiskFromList(riskRecord.data.RiskID, me.RisksParsedData.slice()),
						dirtyType = me._getDirtyType(riskRecord, realRiskData),
						clickFnName = 'Click' + riskRecord.id.replace(/\-/g, 'z') + 'Fn' + col;
					if(dirtyType !== 'New' && dirtyType !== 'Edited') return;
					meta.tdAttr = 'title="Save Risk"';
					window[clickFnName] = function(){
						if(!riskRecord.data.PortfolioItemFormattedID || !riskRecord.data.PortfolioItemName){
							me._alert('ERROR', 'You must set the ' + me.PortfolioItemTypes[0] + ' affected by this Risk'); return; } 
						else if(!riskRecord.data.Checkpoint){
							me._alert('ERROR', 'You must set the Checkpoint for this Risk'); return; }
						else if(!riskRecord.data.Description){
							me._alert('ERROR', 'You must set the Description for this Risk'); return; }
						else if(!riskRecord.data.Impact){
							me._alert('ERROR', 'You must set the Impact for this Risk'); return; }
						else if(!riskRecord.data.Status){
							me._alert('ERROR', 'You must set the Status for this Risk'); return; }
						else if(!riskRecord.data.Contact){
							me._alert('ERROR', 'You must set the Contact for this Risk'); return; }
						
						me.RisksGrid.setLoading("Saving Risk");
						me._enqueue(function(unlockFunc){
							var portfolioItemFormattedID = riskRecord.data.PortfolioItemFormattedID,
								newPortfolioItemRecord = me.PortfolioItemStore.findExactRecord('FormattedID', portfolioItemFormattedID);
							Q((newPortfolioItemRecord.data.ObjectID != riskRecord.data.PortfolioItemObjectID) ?
								me._loadPortfolioItemByOrdinal(newPortfolioItemRecord.data.ObjectID, 0).then(function(portfolioItemRecord){ 
									newPortfolioItemRecord = portfolioItemRecord; 
								}) :
								null
							)
							.then(function(){ 
								return riskRecord.data.PortfolioItemObjectID ? 
									me._loadPortfolioItemByOrdinal(riskRecord.data.PortfolioItemObjectID, 0) : null;
							})
							.then(function(oldPortfolioItemRecord){							
								newPortfolioItemRecord = newPortfolioItemRecord || oldPortfolioItemRecord;
								var oldRealRiskData = me._getRealRiskData(oldPortfolioItemRecord, riskRecord.data.RiskID);
								if(oldRealRiskData && (oldPortfolioItemRecord.data.ObjectID !== newPortfolioItemRecord.data.ObjectID))
									return me._removeRisk(oldPortfolioItemRecord, oldRealRiskData, me.ProjectRecord, me.RisksParsedData);
							})
							.then(function(){ return me._addRisk(newPortfolioItemRecord, riskRecord.data, me.ProjectRecord, me.RisksParsedData); })
							.then(function(){
								riskRecord.beginEdit();
								riskRecord.set('Edited', false);
								riskRecord.set('PortfolioItemObjectID', newPortfolioItemRecord.data.ObjectID);
								riskRecord.endEdit();
							})
							.fail(function(reason){ me._alert('ERROR:', reason  || ''); })
							.then(function(){ 
								unlockFunc();
								me.RisksGrid.setLoading(false);
								updateFilterOptions();
							})
							.done();
						}, 'Queue-Main');
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-floppy-o"></i></div>';
				}
			},{
				text:'',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, riskRecord, row, col){
					var clickFnName = 'Click' + riskRecord.id.replace(/\-/g, 'z') + 'Fn' + col;
					meta.tdAttr = 'title="Delete Risk"';
					window[clickFnName] = function(){
						me._confirm('Confirm', 'Delete Risk?', function(msg){
							if(msg.toLowerCase() !== 'yes') return;
							me.RisksGrid.setLoading("Deleting Risk");
							me._enqueue(function(unlockFunc){
								Q(riskRecord.data.PortfolioItemObjectID ? 
									me._loadPortfolioItemByOrdinal(riskRecord.data.PortfolioItemObjectID, 0) : 
									null)
								.then(function(oldPortfolioItemRecord){					
									var oldRealRiskData = me._getRealRiskData(oldPortfolioItemRecord, riskRecord.data.RiskID);
									if(oldRealRiskData) return me._removeRisk(oldPortfolioItemRecord, oldRealRiskData, me.ProjectRecord, me.RisksParsedData);
								})
								.fail(function(reason){ me._alert('ERROR:', reason || ''); })
								.then(function(){
									unlockFunc();
									me.CustomRisksStore.remove(riskRecord);
									me.RisksGrid.setLoading(false);
									updateFilterOptions();
								})
								.done();
							}, 'Queue-Main');
						});
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-trash"></i></div>';
				}
			}];

			me.RisksGrid = me.add({
				xtype: 'rallygrid',
				cls: 'program-board-grid risks-grid rally-grid',
				header: {
					layout: 'hbox',
					items: [{
						xtype:'text',
						cls:'program-board-grid-header-text',
						width:200,
						text:"RISKS"
					},{
						xtype:'container',
						flex:1000,
						layout:{
							type:'hbox',
							pack:'end'
						},
						items:[{
							xtype:'button',
							text:'+ Add Risk',
							id: 'addRiskButton',
							width:80,
							listeners:{
								click: function(){
									if(!me.PortfolioItemStore.first()) me._alert('ERROR', 'No ' + me.PortfolioItemTypes[0] + 's for this Release!');
									else if(me.CustomRisksStore) {
										removeFilters();
										var model = Ext.create('IntelRisk', {
											RiskID: "RI" + (new Date() * 1) + '' + (Math.random() * 100 >> 0),
											PortfolioItemObjectID: '',
											PortfolioItemFormattedID: '',
											PortfolioItemName: '',
											Description: '',
											Impact: '',
											MitigationPlan: '',
											Urgency: '',
											Status: '',
											Contact: '',
											Checkpoint: '',
											Edited:true
										});
										me.CustomRisksStore.insert(0, [model]);
										me.RisksGrid.view.getEl().setScrollTop(0);
										me.RisksGrid.getSelectionModel().select(model);
									}
								}
							}
						},{
							xtype:'button',
							text:'Remove Filters',
							width:110,
							listeners:{ click: removeFilters }
						}]
					}]
				},
				height:360,
				scroll:'vertical',
				columnCfgs: columnCfgs,
				plugins: [ 'fastcellediting' ],
				viewConfig:{
					xtype:'scrolltableview',
					stripeRows:true,
					preserveScrollOnRefresh:true,
					getRowClass: function(item){ return riskGridFilter(item) ? '' : 'program-board-hidden-grid-row'; 
					}
				},
				listeners: {
					sortchange: function(){ filterRisksRowsByFn(riskGridFilter); },
					edit: function(editor, e){			
						var grid = e.grid,
							risksRecord = e.record,
							field = e.field,
							value = e.value,
							originalValue = e.originalValue;
							
						if(value === originalValue) return; 
						else if(!value && field != 'MitigationPlan') { risksRecord.set(field, originalValue); return; }
						else if(['Description', 'Impact', 'Contact', 'MitigationPlan'].indexOf(field)>-1) {
							value = me._htmlEscape(value);			
							risksRecord.set(field, value);
						}

						var previousEdit = risksRecord.data.Edited;
						risksRecord.set('Edited', true);
						
						var portfolioItemRecord;
						if(field === 'PortfolioItemName'){
							portfolioItemRecord = me.PortfolioItemStore.findExactRecord('Name', value);
							if(!portfolioItemRecord){
								risksRecord.set('PortfolioItemName', originalValue);
								risksRecord.set('Edited', previousEdit);
							} else risksRecord.set('PortfolioItemFormattedID', portfolioItemRecord.data.FormattedID);
						} else if(field === 'PortfolioItemFormattedID'){
							portfolioItemRecord = me.PortfolioItemStore.findExactRecord('FormattedID', value);
							if(!portfolioItemRecord) {
								risksRecord.set('PortfolioItemFormattedID', originalValue);
								risksRecord.set('Edited', previousEdit); 
							} else risksRecord.set('PortfolioItemName', portfolioItemRecord.data.Name);
						} 
						updateFilterOptions();
					}
				},
				disableSelection: true,
				showRowActionsColumn:false,
				showPagingToolbar:false,
				enableEditing:false,
				store: me.CustomRisksStore
			});	
		},	
		_loadDependenciesGrids: function(){
			var me = this,
				defaultRenderer = function(val){ return val || '-'; };
			
			function dependencySorter(o1, o2){ return o1.data.DependencyID > o2.data.DependencyID ? -1 : 1; } //new come first
			function predecessorItemSorter(o1, o2){ return o1.data.PredecessorItemID > o2.data.PredecessorItemID ? -1 : 1; } //new come first
			
			/****************************** STORES FOR THE DROPDOWNS  ***********************************************/	
			me.UserStoryFIDStore = Ext.create('Ext.data.Store', {
				fields: ['FormattedID'],
				data: _.map(me.UserStoriesInRelease, function(usr){ return {'FormattedID': usr.data.FormattedID}; }),
				sorters: { property: 'FormattedID' }
			});
			me.UserStoryNameStore = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(me.UserStoriesInRelease, function(usr){ return {'Name': usr.data.Name }; }),
				sorters: { property: 'Name' }
			});
			
			/****************************** PREDECESSORS STUFF ***********************************************/				
			me.PrececessorItemStores = {};
			me.PredecessorItemGrids = {};
			
			me.CustomPredecessorStore = Ext.create('Intel.data.FastStore', { 
				data: Ext.clone(me.DependenciesParsedData.Predecessors),
				autoSync:true,
				model:'IntelPredecessorDependency',
				limit:Infinity,
				proxy: {
					type:'fastsessionproxy',
					id:'IntelPredecessorDependencyProxy' + Math.random()
				},
				sorters:[dependencySorter],
				intelUpdate: function(){ 
					var predecessorStore = me.CustomPredecessorStore, 
						realPredecessorsData = me.DependenciesParsedData.Predecessors.slice(); 
					predecessorStore.suspendEvents(true);
					_.each(predecessorStore.getRange(), function(predecessorRecord){
						var dependencyID = predecessorRecord.data.DependencyID,
							realPredecessorData = me._spliceDependencyFromList(dependencyID, realPredecessorsData),	
							dirtyType = me._getDirtyType(predecessorRecord, realPredecessorData),
							predecessorItemStore = me.PrececessorItemStores[dependencyID],
							predecessorItemGrid = me.PredecessorItemGrids[dependencyID],
							remoteChanged = false;
						if(dirtyType === 'New' || dirtyType === 'Edited'){} //we don't want to remove any pending changes			
						else if(dirtyType == 'Deleted'){ //predecessor was deleted by someone else, and we aren't editing it
							predecessorStore.remove(predecessorRecord);
							if(predecessorItemStore) me.PrececessorItemStores[dependencyID] = undefined;
							if(predecessorItemGrid) me.PredecessorItemGrids[dependencyID] = undefined;
						} else {
							if(!_.isEqual(predecessorRecord.data.PredecessorItems, realPredecessorData.PredecessorItems)){ 
								/** faster to delete and re-add if predecessorItems are different */
								if(predecessorItemGrid) {
									me.PredecessorItemGrids[dependencyID].destroy();
									delete me.PredecessorItemGrids[dependencyID];
								}
								predecessorStore.remove(predecessorRecord);
								predecessorStore.add(Ext.create('IntelPredecessorDependency', Ext.clone(realPredecessorData)));
								if(predecessorItemStore) predecessorItemStore.intelUpdate(); 
							}
							else {	
								_.each(realPredecessorData, function(value, field){
									if(field!=='PredecessorItems' && !_.isEqual(predecessorRecord.data[field], value)) remoteChanged = true;
								});
								if(remoteChanged){
									predecessorRecord.beginEdit();
									_.each(realPredecessorData, function(value, field){ 
										if(field!=='PredecessorItems') predecessorRecord.set(field, value); 
									});
									predecessorRecord.endEdit();
								}
							}
						}				
						if(!predecessorRecord.data.PredecessorItems.length) {
							//DO NOT SET EDITED==true, because it is already true! only new or edited will ever have preds.length==0
							predecessorRecord.set('PredecessorItems', [me._newPredecessorItem()]); 
							if(predecessorItemStore) predecessorItemStore.intelUpdate();
						}
					});
					
					_.each(realPredecessorsData, function(realPredecessorData){
						/** add all the new dependencies that other people have added since the last load */
						predecessorStore.add(Ext.create('IntelPredecessorDependency', Ext.clone(realPredecessorData)));					
						var dependencyID = realPredecessorData.DependencyID,
							predecessorItemStore = me.PrececessorItemStores[dependencyID];
						if(predecessorItemStore) predecessorItemStore.intelUpdate(); 
					});
					predecessorStore.resumeEvents();
				}
			});

			var filterPredUserStoryFormattedID = null, 
				filterPredUserStoryName = null, 
				filterPredNeededBy = null;
			function predecessorGridFilter(predecessorRecord){
				if(filterPredUserStoryFormattedID && predecessorRecord.data.UserStoryFormattedID != filterPredUserStoryFormattedID) return false;
				if(filterPredUserStoryName && predecessorRecord.data.UserStoryName != filterPredUserStoryName) return false;
				if(filterPredNeededBy && me._roundDateDownToWeekStart(predecessorRecord.data.NeededBy)*1 != filterPredNeededBy) return false;
				return true;
			}
			function filterPredecessorRowsByFn(fn){
				_.each(me.CustomPredecessorStore.getRange(), function(item, index){
					if(fn(item)) me.PredecessorGrid.view.removeRowCls(index, 'program-board-hidden-grid-row');
					else me.PredecessorGrid.view.addRowCls(index, 'program-board-hidden-grid-row');
				});
			}
			function removePredecessorFilters(){
				filterPredUserStoryFormattedID = null;
				filterPredUserStoryName = null;
				filterPredNeededBy = null; 
				filterPredecessorRowsByFn(function(){ return true; });
				Ext.getCmp('predecessor-us-formattedid-filter').setValue('All');
				Ext.getCmp('predecessor-us-name-filter').setValue('All');
				Ext.getCmp('predecessor-needed-by-filter').setValue('All');
			}
			
			function getPredecessorFormattedIDFilterOptions(){
				return [{FormattedID: 'All'}].concat(_.map(_.sortBy(_.union(_.map(me.CustomPredecessorStore.getRange(), 
					function(r){ return r.data.UserStoryFormattedID; })), 
					function(f){ return f; }), 
					function(f){ return {FormattedID:f}; }));
			}
			function getPredecessorNameFilterOptions(){
				return [{Name: 'All'}].concat(_.map(_.sortBy(_.union(_.map(me.CustomPredecessorStore.getRange(), 
					function(r){ return r.data.UserStoryName; })), 
					function(f){ return f; }), 
					function(n){ return {Name:n}; }));
			}
			function getPredecessorNeededByFilterOptions(){
				return [{DateVal:0, Workweek:'All'}].concat(_.map(_.sortBy(_.union(_.map(me.CustomPredecessorStore.getRange(),
					function(r){ return me._roundDateDownToWeekStart(r.data.NeededBy)*1; })),
					function(date){ return date; }),
					function(date){ return {DateVal:date, Workweek:'ww' + me._getWorkweek(date)}; }));
			}
			function updatePredecessorFilterOptions(){
				var fidStore = Ext.getCmp('predecessor-us-formattedid-filter').getStore(),
					nameStore = Ext.getCmp('predecessor-us-name-filter').getStore(),
					cpStore = Ext.getCmp('predecessor-needed-by-filter').getStore();
				fidStore.removeAll();
				fidStore.add(getPredecessorFormattedIDFilterOptions());
				nameStore.removeAll();
				nameStore.add(getPredecessorNameFilterOptions());
				cpStore.removeAll();
				cpStore.add(getPredecessorNeededByFilterOptions());
			}
			
			var predecessorColumnCfgs = [{
				text:'#', 
				dataIndex:'UserStoryFormattedID',
				width:90,
				resizable:false,
				draggable:false,
				sortable:true,
				tdCls: 'intel-editor-cell',
				editor:{
					xtype:'intelcombobox',
					width:80,
					store: me.UserStoryFIDStore,
					displayField: 'FormattedID'
				},
				renderer: defaultRenderer,
				layout:'hbox',
				items:[{
					id:'predecessor-us-formattedid-filter',
					xtype:'intelcombobox',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['FormattedID'],
						data: getPredecessorFormattedIDFilterOptions()
					}),
					displayField: 'FormattedID',
					value:'All',
					listeners:{
						select: function(combo, selected){
							if(selected[0].data.FormattedID == 'All') filterPredUserStoryFormattedID = null; 
							else filterPredUserStoryFormattedID = selected[0].data.FormattedID;
							filterPredecessorRowsByFn(predecessorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]
			},{
				text:'UserStory', 
				dataIndex:'UserStoryName',
				flex:1,
				resizable:false,
				draggable:false,			
				sortable:true,
				tdCls: 'intel-editor-cell',
				editor:{
					xtype:'intelcombobox',
					store: me.UserStoryNameStore,
					displayField: 'Name'
				},
				renderer: defaultRenderer,
				layout:'hbox',
				items:[{
					id:'predecessor-us-name-filter',
					xtype:'intelcombobox',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['Name'],
						data: getPredecessorNameFilterOptions()
					}),
					displayField: 'Name',
					value:'All',
					listeners:{
						select: function(combo, selected){
							if(selected[0].data.Name == 'All') filterPredUserStoryName = null; 
							else filterPredUserStoryName = selected[0].data.Name;
							filterPredecessorRowsByFn(predecessorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]	
			},{
				text:'Dependency Description', 
				dataIndex:'Description',
				flex:1,
				resizable:false,	
				draggable:false,		
				sortable:false,
				tdCls: 'intel-editor-cell',
				editor: 'inteltextarea',
				renderer: defaultRenderer			
			},{
				text:'Needed By',			
				dataIndex:'NeededBy',
				width:90,
				resizable:false,
				draggable:false,
				sortable:true,
				tdCls: 'intel-editor-cell',		
				editor:{
					xtype:'intelfixedcombo',
					width:80,
					store: Ext.create('Ext.data.Store', {
						model:'WorkweekDropdown',
						data: me.WorkweekData
					}),
					displayField: 'Workweek',
					valueField: 'DateVal'
				},
				renderer: function(date){ return (date ? 'ww' + me._getWorkweek(date) : '-');},
				layout:'hbox',
				items:[{
					id:'predecessor-needed-by-filter',
					xtype:'intelfixedcombo',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						model:'WorkweekDropdown',
						data: getPredecessorNeededByFilterOptions()
					}),
					displayField: 'Workweek',
					valueField: 'DateVal',
					value:'All',
					listeners:{
						focus: function(combo) { combo.expand(); },
						select: function(combo, selected){
							if(selected[0].data.DateVal === 0) filterPredNeededBy = null; 
							else filterPredNeededBy = selected[0].data.DateVal;
							filterPredecessorRowsByFn(predecessorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]
			},{
				text:'',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, predecessorRecord, row, col){
					var dependencyID = predecessorRecord.data.DependencyID,
						clickFnName = 'Click' + predecessorRecord.id.replace(/\-/g, 'z') + 'Fn' + col;
					meta.tdAttr = 'title="Add Team"';
					window[clickFnName] = function(){
						if(me.PrececessorItemStores[dependencyID]) {
							var predecessorStore = me.CustomPredecessorStore,
								predecessorRecord = predecessorStore.getAt(predecessorStore.findExact('DependencyID', dependencyID)),
								newItem = me._newPredecessorItem();
							me.PrececessorItemStores[dependencyID].insert(0, [Ext.create('IntelPredecessorItem', newItem)]);
							predecessorRecord.set('PredecessorItems', predecessorRecord.data.PredecessorItems.concat([newItem]));
							predecessorRecord.set('Edited', true);	
						}
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-plus"></i></div>';
				}
			},{
				text:'Teams Depended On',
				dataIndex:'DependencyID',
				xtype:'fastgridcolumn',
				html:	'<div class="predecessor-items-grid-header" style="width:10px !important;"></div>' +
						'<div class="predecessor-items-grid-header" style="width:110px !important;">Team Name</div>' +
						'<div class="predecessor-items-grid-header" style="width:95px  !important;">Supported</div>' +
						'<div class="predecessor-items-grid-header" style="width:70px  !important;">#</div>' +
						'<div class="predecessor-items-grid-header" style="width:130px !important;">User Story</div>',
				width:450,
				resizable:false,
				draggable:false,
				sortable:false,
				renderer: function(dependencyID){
					var predecessorStore = me.CustomPredecessorStore,
						predecessorRecord = predecessorStore.getAt(predecessorStore.findExact('DependencyID', dependencyID)),
						predecessorItems = predecessorRecord.data.PredecessorItems;
					if(!me.PrececessorItemStores[dependencyID]){
						me.PrececessorItemStores[dependencyID] = Ext.create('Intel.data.FastStore', { 
							model:'IntelPredecessorItem',
							data: predecessorItems,
							autoSync:true,
							limit:Infinity,
							proxy: {
								type:'fastsessionproxy',
								id:'PredecessorItem-' + dependencyID + '-proxy' + Math.random()
							},
							sorters:[predecessorItemSorter],
							intelUpdate: function(){
								var predecessorStore = me.CustomPredecessorStore,
									predecessorItemStore = me.PrececessorItemStores[dependencyID],
									predecessorItems = predecessorItemStore.getRange(),
									predecessorRecord = predecessorStore.getAt(predecessorStore.findExact('DependencyID', dependencyID)),
									realPredecessorItemsData = predecessorRecord.data.PredecessorItems.slice();
								predecessorItemStore.suspendEvents(true);
								_.each(predecessorItems, function(predecessorItem){
									var realPredecessorItemData = _.find(realPredecessorItemsData, function(realPredecessorItemData){
										return realPredecessorItemData.PredecessorItemID === predecessorItem.data.PredecessorItemID;
									});
									if(realPredecessorItemData){
										realPredecessorItemsData = _.filter(realPredecessorItemsData, function(realPredecessorItemData2){
											return realPredecessorItemData.PredecessorItemID !== realPredecessorItemData2.PredecessorItemID;
										});
										_.each(realPredecessorItemData, function(value, field){
											if(!_.isEqual(predecessorItem.data[field], value)){ 
												predecessorItemStore.remove(predecessorItem);
												predecessorItemStore.add(Ext.create('IntelPredecessorItem', Ext.clone(realPredecessorItemData)));
												return false;
											}
										});
									}
									else predecessorItemStore.remove(predecessorItem);
								});
								_.each(realPredecessorItemsData, function(realPredecessorItemData){
									predecessorItemStore.add(Ext.create('IntelPredecessorItem', realPredecessorItemData));
								});	
								
								if(predecessorItemStore.getRange().length===0) {
									var newItem = me._newPredecessorItem();
									predecessorItemStore.add(Ext.create('IntelPredecessorItem', newItem));
									predecessorRecord.data.PredecessorItems.push(newItem);
								}
								predecessorItemStore.resumeEvents();
							}
						});	
					}
					
					if(me.PredecessorItemGrids[dependencyID]) return me.PredecessorItemGrids[dependencyID];
						
					var swallowEventHandler = {
						element: 'el',
						fn: function(a){ a.stopPropagation(); }
					};
					
					var predecessorItemColumnCfgs = [{
						dataIndex:'PredecessorProjectObjectID',
						width:115,
						resizable:false,
						renderer: function(val, meta){
							var projectRecord = me.ProjectsWithTeamMembers[val];
							if(val && projectRecord) return projectRecord.data.Name;
							else {
								meta.tdCls += 'intel-editor-cell';
								return '-';
							}
						},
						editor: {
							xtype:'intelcombobox', 
							store: Ext.create('Ext.data.Store', {
								fields: ['Name'],
								data: me.ProjectNames,
								sorters: { property: 'Name' }
							}),
							displayField: 'Name'
						}
					},{
						dataIndex:'Supported',
						width:80,
						resizable:false,
						editor: false,
						renderer: function(val, meta){
							if(val == 'No') meta.tdCls = 'predecessor-item-not-supported-cell';
							else if(val == 'Yes') meta.tdCls = 'predecessor-item-supported-cell';
							return val;
						}
					},{
						dataIndex:'PredecessorUserStoryObjectID',
						width:75,
						resizable:false,
						editor: false,
						renderer: function(userStoryObjectID, meta, predecessorItemRecord){
							if(predecessorItemRecord.data.Assigned){
								var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
								if(userStory) return userStory.data.FormattedID;
								else return '?';
							}
							else return '-';
						}
					},{
						dataIndex:'PredecessorUserStoryObjectID',
						width:140,
						resizable:false,
						editor: false,
						renderer: function(userStoryObjectID, meta, predecessorItemRecord){
							if(predecessorItemRecord.data.Assigned){
								var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
								if(userStory) return userStory.data.Name;
								else return '?';
							}
							else return '-';
						}				
					},{
						resizable:false,
						width:24,
						renderer: function(value, meta, predecessorItemRecord, row, col){
							var clickFnName = 'Click' + predecessorItemRecord.id.replace(/\-/g, 'z') + 'Fn' + col;
							meta.tdAttr = 'title="Delete Team"';
							window[clickFnName] = function(){
								var predecessorStore = me.CustomPredecessorStore,
									predecessorRecord = predecessorStore.getAt(predecessorStore.findExact('DependencyID', dependencyID)),
									realPredecessorItems = predecessorRecord.data.PredecessorItems.slice(),
									predecessorItemStore = me.PrececessorItemStores[dependencyID];	
									
								predecessorItemStore.suspendEvents(true);
								realPredecessorItems = _.filter(realPredecessorItems, function(realPredecessorItem){
									return realPredecessorItem.PredecessorItemID !== predecessorItemRecord.data.PredecessorItemID;
								});
								predecessorItemStore.remove(predecessorItemRecord);							
								if(!realPredecessorItems.length){
									var newItem = me._newPredecessorItem();
									predecessorItemStore.add(Ext.create('IntelPredecessorItem', newItem));
									realPredecessorItems.push(newItem);
								}
								predecessorRecord.set('Edited', true);
								predecessorRecord.set('PredecessorItems', realPredecessorItems);
								predecessorItemStore.resumeEvents();
							};
							return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-minus"></i></div>';
						}
					}];
					
					return {
						xtype: 'rallygrid',
						cls:'program-board-grid predecessor-items-grid rally-grid',
						plugins: [ 'fastcellediting' ],
						viewConfig: { stripeRows:false },
						width:450,
						manageHeight:false,
						columnCfgs: predecessorItemColumnCfgs,
						listeners: {
							mousedown: swallowEventHandler,
							mousemove: swallowEventHandler,
							mouseout: swallowEventHandler,
							mouseover: swallowEventHandler,
							mouseup: swallowEventHandler,
							mousewheel: swallowEventHandler,
							scroll: swallowEventHandler,
							click: swallowEventHandler,
							dblclick: swallowEventHandler,
							contextmenu: swallowEventHandler,
							render: function(){ me.PredecessorItemGrids[dependencyID] = this; },
							beforeedit: function(editor, e){ if(!!e.value) return false; },
							edit: function(editor, e){			
								var predecessorItemRecord = e.record,
									field = e.field,
									value = e.value,
									originalValue = e.originalValue,
									predecessorStore = me.CustomPredecessorStore,
									predecessorRecord = predecessorStore.getAt(predecessorStore.findExact('DependencyID', dependencyID)),
									realPredecessorItems = predecessorRecord.data.PredecessorItems;
								if(value === originalValue) return;										
								if(field === 'PredecessorProjectObjectID'){
									var projectRecord = _.find(me.ProjectsWithTeamMembers, function(vp){ return vp.data.Name === value; });
									if(!projectRecord){
										predecessorItemRecord.set('PredecessorProjectObjectID', originalValue);
										return;
									} else {
										var realPredecessorItem = _.find(realPredecessorItems, function(realPredecessorItem){
											return realPredecessorItem.PredecessorProjectObjectID == projectRecord.data.ObjectID;
										});
										if(realPredecessorItem){
											me._alert('ERROR', value + ' already included in this dependency');
											predecessorItemRecord.set('PredecessorProjectObjectID', originalValue);
											return;
										}
										if(projectRecord.data.ObjectID === me.ProjectRecord.data.ObjectID){
											me._alert('ERROR', 'You cannot depend on yourself');
											predecessorItemRecord.set('PredecessorProjectObjectID', originalValue);
											return;
										}
										predecessorItemRecord.set('PredecessorProjectObjectID', projectRecord.data.ObjectID);
									}
								}
								
								_.each(realPredecessorItems, function(realPredecessorItem){
									if(realPredecessorItem.PredecessorItemID === predecessorItemRecord.data.PredecessorItemID){
										realPredecessorItem.PredecessorProjectObjectID = predecessorItemRecord.data.PredecessorProjectObjectID; 
									}
								});
								predecessorRecord.set('Edited', true);
							},
							selectionchange: function(){ this.getSelectionModel().deselectAll(); }
						},
						rowLines:false,
						disableSelection: true,
						scroll:false,
						hideHeaders:true,
						showRowActionsColumn:false,
						showPagingToolbar:false,
						enableEditing:false,
						store: me.PrececessorItemStores[dependencyID]
					};
				}
			},{
				text:'',
				dataIndex:'Edited',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, predecessorRecord, row, col){
					var dependencyID = predecessorRecord.data.DependencyID,
						realPredecessorData = me._spliceDependencyFromList(dependencyID, me.DependenciesParsedData.Predecessors.slice()),
						dirtyType = me._getDirtyType(predecessorRecord, realPredecessorData),
						clickFnName = 'Click' + predecessorRecord.id.replace(/\-/g, 'z') + 'Fn' + col;
					if(dirtyType !== 'Edited') return ''; 
					meta.tdAttr = 'title="Undo"';
					window[clickFnName] = function(){
						var realPredecessorData = me._spliceDependencyFromList(dependencyID, me.DependenciesParsedData.Predecessors.slice());
						predecessorRecord.beginEdit();
						_.each(realPredecessorData, function(value, field){
							if(field === 'PredecessorItems') predecessorRecord.set(field, value || [me._newPredecessorItem()]);
							else predecessorRecord.set(field, value);
						});
						predecessorRecord.endEdit();
						me.PrececessorItemStores[dependencyID].intelUpdate();
						updatePredecessorFilterOptions();
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-undo"></i></div>';
				}
			},{
				text:'',
				dataIndex:'Edited',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, predecessorRecord, row, col){
					var dependencyID = predecessorRecord.data.DependencyID,
						realPredecessorData = me._spliceDependencyFromList(dependencyID, me.DependenciesParsedData.Predecessors.slice()),
						dirtyType = me._getDirtyType(predecessorRecord, realPredecessorData),
						clickFnName = 'Click' + predecessorRecord.id.replace(/\-/g, 'z') + 'Fn' + col;
					if(dirtyType === 'New') dirtyType = 'Save';
					else if(dirtyType === 'Edited') dirtyType = 'Save';
					else return ''; //don't render it!
					meta.tdAttr = 'title="' + dirtyType + ' Dependency"';
					window[clickFnName] = function(){
						//validate fields first
						if(!predecessorRecord.data.UserStoryFormattedID || !predecessorRecord.data.UserStoryName){
							me._alert('ERROR', 'A UserStory is not selected'); return; }
						if(!predecessorRecord.data.Description){
							me._alert('ERROR', 'The description is empty'); return; }
						if(!predecessorRecord.data.NeededBy){
							me._alert('ERROR', 'Select When the dependency is needed by'); return; }
						var predecessorItems = predecessorRecord.data.PredecessorItems;
						if(!predecessorItems.length){
							me._alert('ERROR', 'You must specify a team you depend on'); return; }
						if(_.find(predecessorItems, function(p){ return !p.PredecessorProjectObjectID; })){
							me._alert('ERROR', 'All Team Names must be valid'); return; }
						
						me.PredecessorGrid.setLoading("Saving Dependency");						
						me._enqueue(function(unlockFunc){
							var localPredecessorData = Ext.clone(predecessorRecord.data);
							/** NOTE ON ERROR HANDLING: we do NOT proceed at all if permissions are insufficient to edit a project, 
									or a project has no user stories to attach to. We first edit all the successors fields and collections 
									for the teams we depend upon, and then we edit the predecessor field on THIS user story.
									If a collection sync fails, it retries 4 times, and then it gives up. */
							me._getOldAndNewUserStoryRecords(localPredecessorData, me.UserStoriesInRelease).then(function(records){
								var oldUserStoryRecord = records[0], 
									newUserStoryRecord = records[1],
									realPredecessorData = me._getRealDependencyData(oldUserStoryRecord, localPredecessorData.DependencyID, 'Predecessors'),
									predecessorItemsArrays = me._getPredecessorItemArrays(localPredecessorData, realPredecessorData);
									
								/** checking and setting this here because the successors NEED the objectID of this userStory */
								if(!newUserStoryRecord){
									return Q.reject('User Story ' + localPredecessorData.UserStoryFormattedID + ' does not exist');
								}
								localPredecessorData.UserStoryObjectID = newUserStoryRecord.data.ObjectID;
								
								return me._getAddedPredecessorItemCallbacks(
									predecessorItemsArrays.added, 
									localPredecessorData,
									me.ProjectRecord,
									me.ProjectsWithTeamMembers,
									me.ProjectRecord,
									me.DependenciesParsedData)
								.then(function(addedCallbacks){	
									return me._getUpdatedPredecessorItemCallbacks(
											predecessorItemsArrays.updated, 
											localPredecessorData,
											me.ProjectRecord,
											me.ProjectsWithTeamMembers,
											me.ProjectRecord,
											me.DependenciesParsedData).then(function(updatedCallbacks){
										return me._getRemovedPredecessorItemCallbacks(
												predecessorItemsArrays.removed, 
												localPredecessorData,
												me.ProjectRecord,
												me.ProjectsWithTeamMembers,
												me.ProjectRecord,
												me.DependenciesParsedData).then(function(removedCallbacks){
											var promise = Q();
											_.each(removedCallbacks, function(callback){ promise = promise.then(callback); });
											_.each(addedCallbacks, function(callback){ promise = promise.then(callback); });
											_.each(updatedCallbacks, function(callback){ promise = promise.then(callback); });
											
											promise = promise.then(function(){
												var newPredecessorItems = predecessorItemsArrays.added.concat(predecessorItemsArrays.updated);
												predecessorRecord.beginEdit();
												predecessorRecord.set('UserStoryObjectID', newUserStoryRecord.data.ObjectID);
												/** NOTE: added and updated predecessorItemsArrays DO GET MUTATED before here! */
												predecessorRecord.set('PredecessorItems', newPredecessorItems);
											});
											
											if(realPredecessorData && (oldUserStoryRecord.data.ObjectID !== newUserStoryRecord.data.ObjectID)){
												promise = promise.then(function(){
													return me._removePredecessor(oldUserStoryRecord, realPredecessorData, me.ProjectRecord, me.DependenciesParsedData);
												});
											}
											return promise
												.then(function(){ 
													return me._addPredecessor(newUserStoryRecord, localPredecessorData, me.ProjectRecord, me.DependenciesParsedData); 
												})
												.then(function(){ predecessorRecord.set('Edited', false); })
												.fail(function(reason){ me._alert('ERROR:', reason || ''); })
												.then(function(){	predecessorRecord.endEdit(); });
										});
									});
								});
							})
							.fail(function(reason){ me._alert('ERROR:', reason || ''); })
							.then(function(){
								unlockFunc();
								updatePredecessorFilterOptions();
								me.PredecessorGrid.setLoading(false);
							})
							.done();
						}, 'Queue-Main');
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-floppy-o"></i></div>';
				}
			},{
				text:'',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, predecessorRecord, row, col){
					var clickFnName = 'Click' + predecessorRecord.id.replace(/\-/g, 'z') + 'Fn' + col;	
					meta.tdAttr = 'title="Delete Dependency"';
					window[clickFnName] = function(){
						me._confirm('Confirm', 'Delete Dependency?', function(msg){
							if(msg.toLowerCase() !== 'yes') return;		
							me.PredecessorGrid.setLoading("Deleting Dependency");							
							me._enqueue(function(unlockFunc){
								var localPredecessorData = predecessorRecord.data;
								me._getOldAndNewUserStoryRecords(localPredecessorData, me.UserStoriesInRelease).then(function(records){
									var oldUserStoryRecord = records[0],
										realPredecessorData = me._getRealDependencyData(oldUserStoryRecord, localPredecessorData.DependencyID, 'Predecessors'),
										predecessorItemsArrays = me._getPredecessorItemArrays(localPredecessorData, realPredecessorData), 
										itemsToRemove = predecessorItemsArrays.removed.concat(predecessorItemsArrays.updated);
									return me._getRemovedPredecessorItemCallbacks(
											itemsToRemove, 
											localPredecessorData,
											me.ProjectRecord,
											me.ProjectsWithTeamMembers,
											me.ProjectRecord,
											me.DependenciesParsedData).then(function(removedCallbacks){
										var promise = Q();
										_.each(removedCallbacks, function(callback){ promise = promise.then(callback); });													
										if(realPredecessorData){
											promise = promise.then(function(){
												return me._removePredecessor(oldUserStoryRecord, realPredecessorData, me.ProjectRecord, me.DependenciesParsedData);
											});
										}
									});
								})
								.then(function(){ me.CustomPredecessorStore.remove(predecessorRecord); })
								.fail(function(reason){ me._alert('ERROR', reason || ''); })
								.then(function(){
									unlockFunc();
									updatePredecessorFilterOptions();
									me.PredecessorGrid.setLoading(false);
								})
								.done();
							}, 'Queue-Main');
						});
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-trash"></i></div>';
				}
			}];

			me.PredecessorGrid = me.add({
				xtype: 'rallygrid',
				cls: 'program-board-grid predecessors-grid rally-grid',
				header: {
					layout: 'hbox',
					items: [{
						xtype:'text',
						cls:'program-board-grid-header-text',
						width:400,
						text:"DEPENDENCIES WE HAVE ON OTHER TEAMS"
					},{
						xtype:'container',
						flex:1000,
						layout:{
							type:'hbox',
							pack:'end'
						},
						items:[{
							xtype:'button',
							text:'+ Add Dependency',
							id: 'addDependencyButton',
							listeners:{
								click: function(){
									if(!me.UserStoriesInRelease.length) me._alert('ERROR', 'No User Stories for this Release!');
									else if(me.CustomPredecessorStore) {
										removePredecessorFilters();
										var model = Ext.create('IntelPredecessorDependency', {
											DependencyID: 'DP' + (new Date() * 1) + '' + (Math.random() * 100 >> 0),
											UserStoryObjectID:'',
											UserStoryFormattedID: '',
											UserStoryName: '',
											Description: '',
											NeededBy: '',
											Status: '',
											PredecessorItems:[me._newPredecessorItem()],
											Edited:true
										});
										me.CustomPredecessorStore.insert(0, [model]);	
										me.PredecessorGrid.view.getEl().setScrollTop(0);
									}
								}
							}
						},{
							xtype:'button',
							text:'Remove Filters',
							width:110,
							listeners:{ click: removePredecessorFilters }
						}]
					}]
				},
				height:400,
				scroll:'vertical',
				columnCfgs: predecessorColumnCfgs,
				plugins: [ 'fastcellediting' ],
				viewConfig:{
					xtype:'scrolltableview',
					stripeRows:true,
					preserveScrollOnRefresh:true,
					getRowClass: function(predecessorRecord){ 
						if(!predecessorGridFilter(predecessorRecord)) return 'program-board-hidden-grid-row'; 
					}
				},
				listeners: {
					sortchange: function(){ filterPredecessorRowsByFn(predecessorGridFilter); },
					edit: function(editor, e){		
						/** NOTE: none of the record.set() operations will get reflected until the proxy calls 'record.endEdit()',
							to improve performance.**/			
						var predecessorRecord = e.record,
							field = e.field,
							value = e.value,
							originalValue = e.originalValue;
						
						if(value === originalValue) return; 
						else if(!value) { predecessorRecord.set(field, originalValue); return; }
						if(field === 'Description') {
							value = me._htmlEscape(value);			
							predecessorRecord.set(field, value);
						}

						var previousEdit = predecessorRecord.data.Edited; 
						predecessorRecord.set('Edited', true);
						
						var userStoryRecord;
						if(field === 'UserStoryName'){
							userStoryRecord = _.find(me.UserStoriesInRelease, function(us){ return us.data.Name === value; });
							if(!userStoryRecord){
								predecessorRecord.set('UserStoryName', originalValue);
								predecessorRecord.set('Edited', previousEdit);
							} else predecessorRecord.set('UserStoryFormattedID', userStoryRecord.data.FormattedID);
						} else if(field === 'UserStoryFormattedID'){
							userStoryRecord = _.find(me.UserStoriesInRelease, function(us){ return us.data.FormattedID === value; });
							if(!userStoryRecord) {
								predecessorRecord.set('UserStoryFormattedID', originalValue);
								predecessorRecord.set('Edited', previousEdit);
							} else predecessorRecord.set('UserStoryName', userStoryRecord.data.Name);
						}
						updatePredecessorFilterOptions();
					}
				},
				disableSelection: true,
				showRowActionsColumn:false,
				showPagingToolbar:false,
				enableEditing:false,
				store: me.CustomPredecessorStore
			});	
		
		/**************************************************** SUCCESSORS STUFF *******************************************************************/	
			me.CustomSuccessorStore = Ext.create('Intel.data.FastStore', { 
				data: Ext.clone(me.DependenciesParsedData.Successors),
				autoSync:true,
				model:'IntelSuccessorDependency',
				proxy: {
					type: 'fastsessionproxy',
					id:'IntelSuccessorProxy' + Math.random()
				},
				limit:Infinity,
				sorters:[dependencySorter],
				intelUpdate: function(){
					var successorStore = me.CustomSuccessorStore,
						realSuccessorsData = me.DependenciesParsedData.Successors.slice(),
						remoteChanged = false; //if someone else updated this while it was idle on our screen
					successorStore.suspendEvents(true);
					_.each(successorStore.getRange(), function(successorRecord){
						var realSuccessorData = me._spliceDependencyFromList(successorRecord.data.DependencyID, realSuccessorsData),
							dirtyType = me._getDirtyType(successorRecord, realSuccessorData);
						if(dirtyType === 'Edited'){} //we don't want to remove any pending changes								
						else if(dirtyType === 'Deleted' || dirtyType === 'New') successorStore.remove(successorRecord);
						else {
							_.each(realSuccessorData, function(value, field){
								if(!_.isEqual(successorRecord.data[field], value)) remoteChanged = true;
							});
							if(remoteChanged){
								successorRecord.beginEdit();
								_.each(realSuccessorData, function(value, field){ successorRecord.set(field, value); });
								successorRecord.endEdit();
							}
						}
					});
					_.each(realSuccessorsData, function(realSuccessorData){
						successorStore.add(Ext.create('IntelSuccessorDependency', Ext.clone(realSuccessorData)));
					});
					successorStore.resumeEvents();
				}
			});
			
			var filterSuccReqTeamName = null, 
				filterSuccReqUserStoryFormattedID = null, 
				filterSuccReqUserStoryName = null, 
				filterSuccNeededBy = null,
				filterSuccSupported = null, 
				filterSuccUserStoryFormattedID = null, 
				filterSuccUserStoryName = null;
			function successorGridFilter(r){
				var successorUserStory = me.DependenciesHydratedUserStories[r.data.SuccessorUserStoryObjectID] || {data:{}};
				if(filterSuccReqTeamName && me.ProjectsWithTeamMembers[r.data.SuccessorProjectObjectID].data.Name != filterSuccReqTeamName) return false;
				if(filterSuccReqUserStoryFormattedID && successorUserStory.data.FormattedID != filterSuccReqUserStoryFormattedID) return false;
				if(filterSuccReqUserStoryName && successorUserStory.data.Name != filterSuccReqUserStoryName) return false;
				if(filterSuccNeededBy && me._roundDateDownToWeekStart(r.data.NeededBy)*1 != filterSuccNeededBy) return false;
				if(filterSuccSupported && r.data.Supported != filterSuccSupported) return false;
				if(filterSuccUserStoryFormattedID && (!r.data.Supported || r.data.UserStoryFormattedID != filterSuccUserStoryFormattedID)) return false;
				if(filterSuccUserStoryName && (!r.data.Supported || r.data.UserStoryName != filterSuccUserStoryName)) return false;
				return true;
			}
			function filterSuccessorRowsByFn(fn){
				_.each(me.CustomSuccessorStore.getRange(), function(item, index){
					if(fn(item)) me.SuccessorGrid.view.removeRowCls(index, 'program-board-hidden-grid-row');
					else me.SuccessorGrid.view.addRowCls(index, 'program-board-hidden-grid-row');
				});
			}
			function removeSuccessorFilter(){
				filterSuccReqTeamName = null;
				filterSuccReqUserStoryFormattedID = null;
				filterSuccReqUserStoryName = null;
				filterSuccNeededBy = null; 
				filterSuccSupported = null;
				filterSuccUserStoryFormattedID = null;
				filterSuccUserStoryName = null;
				filterSuccessorRowsByFn(function(){ return true; });
				Ext.getCmp('successor-requestor-team-name-filter').setValue('All');
				Ext.getCmp('successor-requestor-userstory-formattedid-filter').setValue('All');
				Ext.getCmp('successor-requestor-userstory-name-filter').setValue('All');
				Ext.getCmp('successor-needed-by-filter').setValue('All');
				Ext.getCmp('successor-supported-filter').setValue('All');
				Ext.getCmp('successor-us-formattedid-filter').setValue('All');
				Ext.getCmp('successor-us-name-filter').setValue('All');
			}
			
			function getSuccessorRequestorTeamNameOptions(){
				return [{TeamName: 'All'}].concat(_.map(_.sortBy(_.union(_.map(me.CustomSuccessorStore.getRange(), 
					function(r){ return me.ProjectsWithTeamMembers[r.data.SuccessorProjectObjectID].data.Name; })),
					function(teamName){ return teamName; }), 
					function(teamName){ return {TeamName:teamName}; }));
			}		
			function getSuccessorRequestorUserStoryFormattedIDFilterOptions(){
				return [{FormattedID: 'All'}].concat(_.map(_.sortBy(_.union(_.map(_.filter(me.CustomSuccessorStore.getRange(), 
					function(r){ return me.DependenciesHydratedUserStories[r.data.SuccessorUserStoryObjectID]; }),
					function(r){ return me.DependenciesHydratedUserStories[r.data.SuccessorUserStoryObjectID].data.FormattedID; })),
					function(f){ return f; }), 
					function(f){ return {FormattedID:f}; }));
			}
			function getSuccessorRequestorUserStoryNameFilterOptions(){
				return [{Name: 'All'}].concat(_.map(_.sortBy(_.union(_.map(_.filter(me.CustomSuccessorStore.getRange(), 
					function(r){ return me.DependenciesHydratedUserStories[r.data.SuccessorUserStoryObjectID]; }),
					function(r){ return me.DependenciesHydratedUserStories[r.data.SuccessorUserStoryObjectID].data.Name; })),
					function(n){ return n; }), 
					function(n){ return {Name:n}; }));
			}
			function getSuccessorNeededByFilterOptions(){
				return [{DateVal:0, Workweek:'All'}].concat(_.map(_.sortBy(_.union(_.map(me.CustomSuccessorStore.getRange(),
					function(r){ return me._roundDateDownToWeekStart(r.data.NeededBy)*1; })),
					function(date){ return date; }),
					function(date){ return {DateVal:date, Workweek:'ww' + me._getWorkweek(date)}; }));
			}
			function getSuccessorFormattedIDFilterOptions(){
				return [{FormattedID: 'All'}].concat(_.map(_.sortBy(_.filter(_.union(_.map(me.CustomSuccessorStore.getRange(), 
					function(r){ return r.data.Supported == 'Yes' ? r.data.UserStoryFormattedID : ''; })), 
					function(f){ return f !== ''; }),
					function(f){ return f; }), 
					function(f){ return {FormattedID:f}; }));
			}
			function getSuccessorNameFilterOptions(){
				return [{Name: 'All'}].concat(_.map(_.sortBy(_.filter(_.union(_.map(me.CustomSuccessorStore.getRange(), 
					function(r){ return r.data.Supported == 'Yes' ? r.data.UserStoryName : ''; })), 
					function(f){ return f !== ''; }),
					function(f){ return f; }), 
					function(n){ return {Name:n}; }));
			}
			function updateSuccessorFilterOptions(){
				var teamStore = Ext.getCmp('successor-requestor-team-name-filter').getStore(),
					reqFidStore = Ext.getCmp('successor-requestor-userstory-formattedid-filter').getStore(),
					reqNameStore = Ext.getCmp('successor-requestor-userstory-name-filter').getStore(),
					neededByStore = Ext.getCmp('successor-needed-by-filter').getStore(),
					fidStore = Ext.getCmp('successor-us-formattedid-filter').getStore(),
					nameStore = Ext.getCmp('successor-us-name-filter').getStore();
				teamStore.removeAll();
				teamStore.add(getSuccessorRequestorTeamNameOptions());
				reqFidStore.removeAll();
				reqFidStore.add(getSuccessorRequestorUserStoryFormattedIDFilterOptions());
				reqNameStore.removeAll();
				reqNameStore.add(getSuccessorRequestorUserStoryNameFilterOptions());
				neededByStore.removeAll();
				neededByStore.add(getSuccessorNeededByFilterOptions());
				fidStore.removeAll();
				fidStore.add(getSuccessorFormattedIDFilterOptions());
				nameStore.removeAll();
				nameStore.add(getSuccessorNameFilterOptions());
			}
			
			var successorColumnCfgs = [{
				text:'Requested By',
				dataIndex:'SuccessorProjectObjectID',
				width:160,
				resizable:false,
				draggable:false,
				sortable:true,
				renderer: function(projectOID){ return me.ProjectsWithTeamMembers[projectOID].data.Name; },
				layout:'hbox',
				items:[{
					id:'successor-requestor-team-name-filter',
					xtype:'intelcombobox',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['TeamName'],
						data: getSuccessorRequestorTeamNameOptions()
					}),
					displayField: 'TeamName',
					value:'All',
					listeners:{
						select: function(combo, selected){
							if(selected[0].data.TeamName == 'All') filterSuccReqTeamName = null; 
							else filterSuccReqTeamName = selected[0].data.TeamName;
							filterSuccessorRowsByFn(successorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]
			},{
				text:'Req #',
				dataIndex:'SuccessorUserStoryObjectID',
				width:90,
				resizable:false,
				draggable:false,
				sortable:true,
				renderer: function(userStoryObjectID){
					var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
					if(userStory){
						return '<a href="https://rally1.rallydev.com/#/' + userStory.data.Project.ObjectID + 'ud/detail/userstory/' + 
							userStory.data.ObjectID + '" target="_blank">' + userStory.data.FormattedID + '</a>';
					} else return '?';
				},
				layout:'hbox',
				items:[{
					id:'successor-requestor-userstory-formattedid-filter',
					xtype:'intelcombobox',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['FormattedID'],
						data: getSuccessorRequestorUserStoryFormattedIDFilterOptions()
					}),
					displayField: 'FormattedID',
					value:'All',
					listeners:{
						select: function(combo, selected){
							if(selected[0].data.FormattedID == 'All') filterSuccReqUserStoryFormattedID = null; 
							else filterSuccReqUserStoryFormattedID = selected[0].data.FormattedID;
							filterSuccessorRowsByFn(successorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]
			},{
				text:'Req UserStory',
				dataIndex:'SuccessorUserStoryObjectID',
				flex:1,
				resizable:false,
				draggable:false,
				sortable:true,
				renderer: function(userStoryObjectID){
					var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
					if(userStory) return userStory.data.Name;
					else return '?';
				},
				layout:'hbox',
				items:[{
					id:'successor-requestor-userstory-name-filter',
					xtype:'intelcombobox',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['Name'],
						data: getSuccessorRequestorUserStoryNameFilterOptions()
					}),
					displayField: 'Name',
					value:'All',
					listeners:{
						select: function(combo, selected){
							if(selected[0].data.Name == 'All') filterSuccReqUserStoryName = null; 
							else filterSuccReqUserStoryName = selected[0].data.Name;
							filterSuccessorRowsByFn(successorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]	
			},{
				text:'Dependency Description', 
				dataIndex:'Description',
				flex:1,
				resizable:false,
				draggable:false,
				editor: false,
				sortable:false					
			},{
				text:'Needed By',
				dataIndex:'NeededBy',
				width:80,
				resizable:false,
				draggable:false,
				editor: false,
				sortable:true,
				renderer: function(date){ return (date ? 'ww' + me._getWorkweek(date) : '-');},
				layout:'hbox',
				items:[{
					id:'successor-needed-by-filter',
					xtype:'intelfixedcombo',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						model:'WorkweekDropdown',
						data: getSuccessorNeededByFilterOptions()
					}),
					displayField: 'Workweek',
					valueField: 'DateVal',
					value:'All',
					listeners:{
						focus: function(combo) { combo.expand(); },
						select: function(combo, selected){
							if(selected[0].data.DateVal === 0) filterSuccNeededBy = null; 
							else filterSuccNeededBy = selected[0].data.DateVal;
							filterSuccessorRowsByFn(successorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]			
			},{
				text:'Supported',					
				dataIndex:'Supported',
				width:90,
				resizable:false,
				draggable:false,
				tdCls: 'intel-editor-cell',
				editor:{
					xtype:'intelfixedcombo',
					width:80,
					store: Ext.create('Ext.data.Store', {
						fields: ['Sup'],
						data: [
							{Sup:'Undefined'},
							{Sup:'Yes'},
							{Sup:'No'}
						]
					}),
					displayField: 'Sup'
				},
				renderer: function(val, meta){
					if(val == 'No') meta.tdCls = 'successor-not-supported-cell';
					else if(val == 'Yes') meta.tdCls = 'successor-supported-cell';
					return val;
				},
				sortable:true,
				layout:'hbox',
				items:[{
					id:'successor-supported-filter',
					xtype:'intelfixedcombo',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['Sup'],
						data: [
							{Sup: 'All'},
							{Sup: 'Yes'}, 
							{Sup: 'No'}, 
							{Sup: 'Undefined'}
						]
					}),
					displayField: 'Sup',
					value:'All',
					listeners:{
						focus: function(combo) { combo.expand(); },
						select: function(combo, selected){
							if(selected[0].data.Sup === 'All') filterSuccSupported = null; 
							else filterSuccSupported = selected[0].data.Sup;
							filterSuccessorRowsByFn(successorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]
			},{
				text:'Sup #', 
				dataIndex:'UserStoryFormattedID',
				width:90,
				resizable:false,
				draggable:false,
				editor:{
					xtype:'intelcombobox',
					width:120,
					store: me.UserStoryFIDStore,
					displayField: 'FormattedID'
				},
				sortable:true,
				renderer:function(val, meta, record){ 
					if(record.data.Supported == 'Yes') meta.tdCls += ' intel-editor-cell';
					return val || '-'; 
				},	
				layout:'hbox',
				items:[{
					id:'successor-us-formattedid-filter',
					xtype:'intelcombobox',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['FormattedID'],
						data: getSuccessorFormattedIDFilterOptions()
					}),
					displayField: 'FormattedID',
					value:'All',
					listeners:{
						select: function(combo, selected){
							if(selected[0].data.FormattedID == 'All') filterSuccUserStoryFormattedID = null; 
							else filterSuccUserStoryFormattedID = selected[0].data.FormattedID;
							filterSuccessorRowsByFn(successorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]
			},{
				text:'Sup UserStory', 
				dataIndex:'UserStoryName',
				flex:1,
				resizable:false,
				draggable:false,
				editor:{
					xtype:'intelcombobox',
					store: me.UserStoryNameStore,
					displayField: 'Name'
				},
				sortable: true,
				renderer:function(val, meta, record){ 
					if(record.data.Supported == 'Yes') meta.tdCls += ' intel-editor-cell';
					return val || '-'; 
				},	
				layout:'hbox',
				items:[{
					id:'successor-us-name-filter',
					xtype:'intelcombobox',
					flex:1,
					store: Ext.create('Ext.data.Store', {
						fields:['Name'],
						data: getSuccessorNameFilterOptions()
					}),
					displayField: 'Name',
					value:'All',
					listeners:{
						select: function(combo, selected){
							if(selected[0].data.Name == 'All') filterSuccUserStoryName = null; 
							else filterSuccUserStoryName = selected[0].data.Name;
							filterSuccessorRowsByFn(successorGridFilter);
						}
					}
				}, {xtype:'container', width:5}]	
			},{
				text:'',
				dataIndex:'Edited',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, successorRecord, row, col){		
					var clickFnName = 'Click' + successorRecord.id.replace(/\-/g, 'z') + 'Fn' + col;	
					if(!successorRecord.data.UserStoryFormattedID) return '';
					meta.tdAttr = 'title="' + 'Remove User Story' + '"';
					window[clickFnName] = function(){
						successorRecord.beginEdit(true);
						successorRecord.set('Edited', true);
						successorRecord.set('Assigned', false);
						successorRecord.set('UserStoryFormattedID', '');
						successorRecord.set('UserStoryName', '');
						successorRecord.endEdit();
						updateSuccessorFilterOptions();
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-minus"></i></div>';
				}
			},{
				text:'',
				dataIndex:'Edited',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, successorRecord, row, col){	
					var dependencyID = successorRecord.data.DependencyID,
						realSuccessorData = me._spliceDependencyFromList(dependencyID, me.DependenciesParsedData.Successors.slice()),
						dirtyType = me._getDirtyType(successorRecord, realSuccessorData),
						clickFnName = 'Click' + successorRecord.id.replace(/\-/g, 'z') + 'Fn' + col;
					if(dirtyType !== 'Edited') return '';
					meta.tdAttr = 'title="Undo"';
					window[clickFnName] = function(){
						var realSuccessorData = me._spliceDependencyFromList(dependencyID, me.DependenciesParsedData.Successors.slice());	
						successorRecord.beginEdit(true);
						_.each(realSuccessorData, function(value, field){ successorRecord.set(field, value); });
						successorRecord.endEdit();
						updateSuccessorFilterOptions();
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-undo"></i></div>';
				}
			},{
				text:'',
				dataIndex:'Edited',
				width:24,
				resizable:false,
				draggable:false,
				renderer: function(value, meta, successorRecord, row, col){
					var dependencyID = successorRecord.data.DependencyID,
						realSuccessorData = me._spliceDependencyFromList(dependencyID, me.DependenciesParsedData.Successors.slice()),
						dirtyType = me._getDirtyType(successorRecord, realSuccessorData),
						clickFnName = 'Click' + successorRecord.id.replace(/\-/g, 'z') + 'Fn' + col;
					if(dirtyType !== 'Edited') return '';
					meta.tdAttr = 'title="Save Dependency"';
					window[clickFnName] = function(){
						if(!successorRecord.data.Supported){
							me._alert('ERROR', 'You must set the Supported field.'); return; }
						me.SuccessorGrid.setLoading("Saving Dependency");						
						me._enqueue(function(unlockFunc){
							var successorData = successorRecord.data, 
								oldUserStoryRecord, 
								newUserStoryRecord,
								realSuccessorData;
							me._getOldAndNewUserStoryRecords(successorData, me.UserStoryStore.getRange()).then(function(records){
								oldUserStoryRecord = records[0];
								newUserStoryRecord = records[1];
								
								realSuccessorData = me._getRealDependencyData(oldUserStoryRecord, successorData.DependencyID, 'Successors');
								if(!realSuccessorData) return Q.reject({SuccessorDeletedDependency:true, message:'Successor removed this dependency'});
								
								successorData.UserStoryObjectID = newUserStoryRecord.data.ObjectID;	
								successorData.SuccessorUserStoryObjectID = realSuccessorData.SuccessorUserStoryObjectID;
								
								return me._updateSuccessor(
										newUserStoryRecord, 
										successorData, 
										me.ProjectRecord,
										me.ProjectsWithTeamMembers, 
										me.ProjectRecord, 
										me.DependenciesParsedData)
								.then(function(){							
									if(oldUserStoryRecord.data.ObjectID !== newUserStoryRecord.data.ObjectID)
										return me._removeSuccessor(oldUserStoryRecord, realSuccessorData, me.ProjectRecord, me.DependenciesParsedData);
								})
								.then(function(){ return me._addSuccessor(newUserStoryRecord, successorData, me.ProjectRecord, me.DependenciesParsedData); })
								.then(function(){ successorRecord.set('Edited', false); });
							})
							.fail(function(reason){
								if(reason.SuccessorDeletedDependency){
									me._alert('ERROR', reason.message + '. Deleting this dependency now');
									if(realSuccessorData){
										me._removeSuccessor(oldUserStoryRecord, realSuccessorData, me.ProjectRecord, me.DependenciesParsedData)
											.then(function(){ me.CustomSuccessorStore.remove(successorRecord); })
											.fail(function(reason){ me._alert('ERROR', reason || ''); })
											.done();
									}
									else me.CustomSuccessorStore.remove(successorRecord);
								}
								else me._alert('ERROR', reason || '');
							})
							.then(function(){
								unlockFunc();
								updateSuccessorFilterOptions();
								me.SuccessorGrid.setLoading(false);
							})
							.done();
						}, 'Queue-Main');
					};
					return '<div class="intel-editor-cell" onclick="' + clickFnName + '()"><i class="fa fa-md fa-floppy-o"></i></div>';
				}
			}];
			
			me.SuccessorGrid = me.add({
				xtype: 'rallygrid',
				cls: 'program-board-grid successors-grid rally-grid',
				header: {
					layout: 'hbox',
					items: [{
						xtype:'text',
						cls:'program-board-grid-header-text',
						width:400,
						text:"DEPENDENCIES OTHER TEAMS HAVE ON US"
					},{
						xtype:'container',
						flex:1000,
						layout:{
							type:'hbox',
							pack:'end'
						},
						items:[{
							xtype:'button',
							text:'Remove Filters',
							width:110,
							listeners:{ click: removeSuccessorFilter }
						}]
					}]
				},
				height:400,
				scroll:'vertical',
				columnCfgs: successorColumnCfgs,
				plugins: [ 'fastcellediting' ],
				viewConfig:{
					xtype:'scrolltableview',
					stripeRows:true,
					preserveScrollOnRefresh:true,
					getRowClass: function(successorRecord){ 
						if(!successorGridFilter(successorRecord)) return 'program-board-hidden-grid-row'; 
					}
				},
				listeners: {
					sortchange: function(){ filterSuccessorRowsByFn(successorGridFilter); },
					beforeedit: function(editor, e){
						var successorRecord = e.record;
						if(successorRecord.data.Supported != 'Yes' && e.field != 'Supported') 
							return false; //don't edit user story stuff if not supported
					},
					edit: function(editor, e){					
						var grid = e.grid,
							successorRecord = e.record,
							field = e.field,
							value = e.value,
							originalValue = e.originalValue;	
							
						if(value == originalValue) return;
						else if(!value) { successorRecord.set(field, originalValue); return; }
						var previousEdit = successorRecord.data.Edited;
						successorRecord.set('Edited', true);
						
						if((field === 'UserStoryName' || field == 'UserStoryFormattedID') && successorRecord.data.Supported != 'Yes'){
							successorRecord.set(field, originalValue); 
							return; 
						}
						
						var userStoryRecord;
						if(field === 'UserStoryName'){
							userStoryRecord = _.find(me.UserStoriesInRelease, function(us){ return us.data.Name === value; });
							if(!userStoryRecord){
								successorRecord.set('UserStoryName', originalValue);
								successorRecord.set('Edited', previousEdit); 
							} else {
								successorRecord.set('UserStoryFormattedID', userStoryRecord.data.FormattedID);	
								successorRecord.set('Assigned', true);
							}
						} else if(field === 'UserStoryFormattedID'){
							userStoryRecord = _.find(me.UserStoriesInRelease, function(us){ return us.data.FormattedID === value; });
							if(!userStoryRecord) {
								successorRecord.set('UserStoryFormattedID', originalValue);
								successorRecord.set('Edited', previousEdit); 
							} else {
								successorRecord.set('UserStoryName', userStoryRecord.data.Name);	
								successorRecord.set('Assigned', true);
							}
						}
						else if(field === 'Supported'){ //cant be non-supported with a user story!
							if(value != 'Yes'){
								successorRecord.set('Assigned', false);
								successorRecord.set('UserStoryFormattedID', '');
								successorRecord.set('UserStoryName', '');
							}
						}
						updateSuccessorFilterOptions();
					}
				},
				disableSelection: true,
				showRowActionsColumn:false,
				showPagingToolbar:false,
				enableEditing:false,
				store: me.CustomSuccessorStore
			});	
		}	
	});
}());

            Rally.launchApp('ProgramBoard', {
                name:"Program Board",
	            parentRepos:""
            });

        });
    </script>


    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"/>

    <style type="text/css">
        .x-grid-cell.intel-editor-cell *,
.x4-grid-cell.intel-editor-cell *,
.intel-editor-cell {
  cursor: pointer !important;
}
.fa.fa-md {
  font-size: 1.05rem;
  line-height: .75em;
  vertical-align: -15%;
}

    </style>

    <style type="text/css">
        /************************************************ RISKS GRID *****************************************/
.x-grid-body .x-grid-row .risks-grid-error-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
/*red*/
/************************************************ DEPENDENCIES GRIDS *****************************************/
.predecessor-items-grid .x-grid-body {
  background-color: rgba(0, 0, 0, 0) !important;
  border-top: 0 !important;
}
.predecessor-items-grid-header {
  display: inline-block !important;
  line-height: 100% !important;
  font-weight: 500 !important;
}
.x-grid-body .x-grid-row .predecessor-item-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .predecessor-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .successor-not-supported-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
.x-grid-body .x-grid-row-selected .predecessor-item-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .predecessor-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .successor-not-supported-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.25) !important;
}
.x-grid-body .x-grid-row .predecessor-item-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .predecessor-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .successor-supported-cell.x-grid-cell {
  background-color: rgba(0, 255, 0, 0.15) !important;
}
.x-grid-body .x-grid-row-selected .predecessor-item-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .predecessor-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .successor-supported-cell.x-grid-cell {
  background-color: rgba(0, 255, 0, 0.25) !important;
}
/************************************************ DUPLICATE RESOLVING MODAL *****************************************/
.duplicates-modal .grid-group-header {
  text-decoration: underline;
  padding-left: 10px;
  font-size: 1.25rem;
}
.duplicates-modal .done-button {
  margin: 10px 0 10px 10px;
}
.duplicates-modal .x-grid-row-selected .x-grid-cell,
.duplicates-modal .x-grid-row-over .x-grid-cell {
  background-color: rgba(0, 0, 0, 0) !important;
}
.duplicates-modal .duplicate-risks-grid,
.duplicates-modal .duplicate-predecessors-grid,
.duplicates-modal .duplicate-successors-grid {
  margin: 10px 20px 10px 20px;
}
.duplicates-modal .x-grid-row-checker {
  background-image: url(https://rally1.rallydev.com/apps/2.0rc3/rui/resources/css/images/form/radio.gif) !important;
}

    </style>

    <style type="text/css">
        .x-grid-cell.manager-expected-cell {
  background-image: -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 30px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-cell-small {
  background-image: -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-RED,
.x-grid-row-over .x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREEN,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(183, 183, 183, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREY,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(183, 183, 183, 0.7) !important;
}

    </style>

    <style type="text/css">
        .program-board-grid-header-text {
  font-size: 13px !important;
}
.program-board-hidden-grid-row {
  display: none !important;
}
/************************************************ NAVBAR/CONTAINERS *****************************************/
#navbar {
  padding: 0 10px 0 10px;
}
#releasePicker {
  margin: 4px 0 0 0;
}
#manualRefreshButton {
  margin: 5px 0 0 5px;
}
#tcVelBox {
  padding: 0 10px 0 10px;
}
/************************************************ TEAM COMMITS GRID *****************************************/
.team-commits-grid {
  padding: 0 20px 0 0;
}
.team-commits-grey-row .x-grid-cell {
  background-color: rgba(224, 224, 224, 0.15) !important;
}
.team-commits-grey-row.x-grid-row-selected .x-grid-cell {
  background-color: rgba(224, 224, 224, 0.25) !important;
}
.team-commits-red-row .x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
.team-commits-red-row.x-grid-row-selected .x-grid-cell {
  background-color: rgba(255, 0, 0, 0.25) !important;
}
.team-commits-green-row .x-grid-cell {
  background-color: rgba(0, 255, 0, 0.15) !important;
}
.team-commits-green-row.x-grid-row-selected .x-grid-cell {
  background-color: rgba(0, 255, 0, 0.25) !important;
}
/************************************************ VELOCITY GRID *****************************************/
.x-grid-row .velocity-grid-error-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
/*red*/
.x-grid-row-selected .velocity-grid-error-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.25) !important;
}
.x-grid-row .velocity-grid-warning-cell.x-grid-cell {
  background-color: rgba(230, 230, 0, 0.15) !important;
}
/*yellow*/
.x-grid-row-selected .velocity-grid-warning-cell.x-grid-cell {
  background-color: rgba(230, 230, 0, 0.25) !important;
}
/************************************************ MINI SANITY GRID *****************************************/
.mini-sanity-grid {
  margin: 30px 0 0 0;
}
.mini-sanity-name-cell {
  border-left: 1px solid black;
  border-top: 1px solid black;
  border-bottom: 1px solid black;
  border-bottom-left-radius: 5px;
  border-top-left-radius: 5px;
}
.green-bg-cell {
  background-color: #2ECC40 !important;
}
.aqua-bg-cell {
  background-color: #7FDBFF !important;
}
.silver-bg-cell {
  background-color: #DDDDDD !important;
}
.orange-bg-cell {
  background-color: #FF851B !important;
}
.lime-bg-cell {
  background-color: #01FF70 !important;
}
.mini-sanity-num-cell {
  text-align: center;
  border: 1px solid black;
}
.mini-sanity-header {
  font-size: 13px;
}
.x-grid-row .mini-sanity-red-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
.x-grid-row .mini-sanity-green-cell.x-grid-cell {
  background-color: rgba(0, 255, 0, 0.15) !important;
}
/************************************************ RISKS GRID *****************************************/
.risks-grid {
  margin: 40px 10px 0px 10px;
}
#addRiskButton {
  margin: 0 10px 0 0;
}
/************************************************ DEPENDENCIES GRIDS *****************************************/
.predecessors-grid {
  margin: 40px 10px 0px 10px;
}
.successors-grid {
  margin: 40px 10px 40px 10px;
}
#addDependencyButton {
  margin: 0 10px 0 0;
}

    </style>
</head>
<body>
</body>
</html>
