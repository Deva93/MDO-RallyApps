<!DOCTYPE html>
<html>
<head>
    <title>Portfolio Hierarchy</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** this extends Rally.app.app. if you want to use it's utility functions, just
		extend IntelRallyApp instead of Rally.app.App
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('IntelRallyApp', {
		alias: 'widget.intelrallyapp',
		extend: 'Rally.app.App',
		
		_TrainConfigPrefName: 'intel-train-config', //preference to store train config for workspace
		
		_projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
		_portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'c_TeamCommits', 'c_MoSCoW', 'Release',
			'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal'],
		_userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
			'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
		_releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
		
		/********************************************** APP CONFIGURATION **************************************/
		_loadScheduleStates: function(){ 
			var me=this, deferred = Q.defer();
			Rally.data.ModelFactory.getModel({
				type: 'UserStory',
				success: function(model) {
					model.getField('ScheduleState').getAllowedValueStore().load({
						callback: function(records, operation, success) {
							me.ScheduleStates = _.map(records, function(r){ return r.data.StringValue; });
							deferred.resolve();
						}
					});
				}
			});
			return deferred.promise;
		},
		_loadPortfolioItemStatesForEachType: function(){ 
			var me=this;
			me.PortfolioItemTypeStates = [];
			return Q.all(_.map(me.PortfolioItemTypes, function(portfolioType, ordinal){
				var store = Ext.create('Rally.data.wsapi.Store', {
					model: 'State',
					autoLoad:false,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Name', 'Enabled', 'OrderIndex'],
					filters: [{
						property: 'TypeDef.Name',
						value: portfolioType
					},{
						property: 'Enabled',
						value: true
					}]
				});
				return me._reloadStore(store).then(function(store){
					me.PortfolioItemTypeStates[ordinal] = store.getRange();
				});
			}));
		},
		_loadPortfolioItemTypes: function(){ 
			/** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
			var me=this,
				deferred = Q.defer(),
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'TypeDefinition',
					autoLoad:true,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					listeners:{
						load:function(portfolioTypeStore){
							me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(), 
								function(item){ return {Name: item.data.Name, Ordinal: item.data.Ordinal}; }),
								function(item){ return item.Ordinal; }),
								function(item){ return item.Name; });
							deferred.resolve();
						}
					}
				});
			return deferred.promise;
		},
		_loadModels: function(){ 
			/** loads models for project, userstories, and all the portfolio items */
			var me=this, 
				promises = [],
				models = {
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					PortfolioItem: 'PortfolioItem'
				};
			_.each(me.PortfolioItemTypes, function(name){ models[name] = 'PortfolioItem/' + name; });
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},
		_loadTrainConfig: function(){
			/** me.TrainConfig is an array of these objects: 
				{
					TrainProjectOID: configItem.TrainProjectOID || 0,
					TrainName: configItem.TrainName || '',
					TrainAndPortfolioLocationTheSame: configItem.TrainAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._TrainConfigPrefName,
				success: function(prefs) {
					var workspaceConfigString = prefs[me._TrainConfigPrefName], trainConfig;
					try{ trainConfig = JSON.parse(workspaceConfigString); }
					catch(e){ trainConfig = []; }
					me.TrainConfig = trainConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveTrainConfig: function(trainConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[me._TrainConfigPrefName] = JSON.stringify(trainConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._TrainConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_configureIntelRallyApp: function(){
			var me=this;
			return Q.all([
				me._loadPortfolioItemTypes().then(function(){ 
					return Q.all([
						me._loadModels(),
						me._loadPortfolioItemStatesForEachType()
					]);
				}),
				me._loadTrainConfig(),
				me._loadScheduleStates()
			]);
		},
				
		/**************************** Generic store loading with Q wrapper, returns promise *************************************/		
		_reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		},
		
		/********************************************** LOADING SINGLE MODELS **************************************/	
		_loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LP');
			else if(!me.Project) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.Project.load(oid, {
					fetch: me._projectFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadUserStory: function(oid, projectRecord){
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LUS');
			else if(!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.UserStory.load(oid, {
					fetch: me._userStoryFields,
					context: {
						workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
						project: projectRecord ? projectRecord.data._ref : null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByType: function(oid, type){
			var me = this, deferred = Q.defer();
			if(!oid || !type) return Q.reject('Invalid arguments: LPIBT');
			else {
				me[type].load(oid, {
					fetch: me._portfolioItemFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
						
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByOrdinal: function(oid, ordinal){
			var me = this, deferred = Q.defer(),
				type = me.PortfolioItemTypes[ordinal];
			return me._loadPortfolioItemByType(oid, type);
		},	
		
		/**************************************** Train Funcs ***************************************************/
		_projectInWhichTrain: function(projectRecord){ 
			/** returns train the projectRecord is in, otherwise null. */
			if(!projectRecord) return Q();
			else {
				var me=this,
					foundTrainConfig = _.find(me.TrainConfig, function(trainConfig){ 
						return trainConfig.TrainProjectOID == projectRecord.data.ObjectID; 
					});
				if(foundTrainConfig) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q();
					else {
						return me._loadProject(parent.ObjectID).then(function(parentRecord){
							return me._projectInWhichTrain(parentRecord);
						});
					}
				}
			}
		},
		_loadTrainPortfolioProject: function(trainRecord){
			if(!trainRecord) return Q.reject('Invalid arguments: ltpp');
			var me=this,
				foundTrainConfig = _.find(me.TrainConfig, function(trainConfig){ 
					return trainConfig.TrainProjectOID == trainRecord.data.ObjectID; 
				});
			if(!foundTrainConfig) return Q.reject('Project ' + trainRecord.data.Name + ' is not a train!');
			if(foundTrainConfig.TrainAndPortfolioLocationTheSame) return Q(trainRecord);
			else return me._loadProject(foundTrainConfig.PortfolioProjectOID);
		},
		_getTrainName: function(trainRecord){
			if(!trainRecord) throw 'Invalid arguments: gtn';
			var me=this,
				foundTrainConfig = _.find(me.TrainConfig, function(trainConfig){ 
					return trainConfig.TrainProjectOID == trainRecord.data.ObjectID; 
				});
			if(!foundTrainConfig) throw 'Project ' + trainRecord.data.Name + ' is not a train!';
			if(foundTrainConfig.TrainName) return foundTrainConfig.TrainName;
			else return trainRecord.data.Name;
		},
		_loadAllTrains: function(){
			var me=this,
				filter = _.reduce(me.TrainConfig, function(filter, item){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', { property:'ObjectID', value: item.TrainProjectOID });
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			if(!filter) return Q([]);
			else {
				var store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._projectFields,
					filters:[filter],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
				return me._reloadStore(store).then(function(store){ return store.getRange(); });
			}
		},
		
		/**************************************** UserStory Funcs ************************************************/
		__getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ 
			/** only pull look at PortfolioItem Release if US.Release == null */
			var me=this,
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property:'PortfolioItem.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property:'PortfolioItem.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		_loadRandomUserStory: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: LRUS');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: false,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters:[{ 
						property:'Project.ObjectID', 
						value: projectRecord.data.ObjectID 
					}]
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadRandomUserStoryFromReleaseTimeframe: function(projectRecord, releaseRecord){
			if(!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: LRUSFR');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					disableMetaChangeEvent: true,
					fetch: me._userStoryFields,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project.ObjectID', value: projectRecord.data.ObjectID }).and(
						me.__getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me._reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		_loadUserStoryByFID: function(formattedID, projectRecord){
			if(!formattedID || !projectRecord) return Q.reject('Invalid arguments: LUSBFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		
		/**************************************** PortfolioItem Funcs ************************************************/
		_loadPortfolioItemsOfType: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: OPIOT');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					disableMetaChangeEvent: true,
					remoteSort:false,
					fetch: me._portfolioItemFields,
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store);
		},		
		_loadPortfolioItemsOfOrdinal: function(portfolioProject, ordinal){
			if(!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: LPIOO');
			var me=this, type = me.PortfolioItemTypes[ordinal];
			if(type) return me._loadPortfolioItemsOfType(portfolioProject, type);
			else return Q.reject('Invalid PortfolioItem ordinal');
		},
		_portfolioItemTypeToOrdinal: function(type){
			return this.PortfolioItemTypes.indexOf(type);
		},
		_getPortfolioItemTypeStateByOrdinal: function(ordinal, stateName){
			return _.find(this.PortfolioItemTypeStates[ordinal], function(state){ return state.data.Name == stateName; });
		},
		_getPortfolioItemTypeStateByName: function(portfolioType, stateName){
			return this._getPortfolioItemTypeStateByOrdinal(this._portfolioItemTypeToOrdinal(portfolioType), stateName);
		},
		
		/********************************************** Project Funcs ********************************************/	
		__storeItemsToProjTree: function(projects){
			var me=this, projTree = {};
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			return projTree;
		},
		_loadAllProjects: function(){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				var map = _.reduce(store.getRange(), function(map, project){
					map[project.data.ObjectID] = project;
					return map;
				}, {});
				return map;
			});	
		},
		__addProjectsWithTeamMembersToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
			}
		},	
		_loadProjectsWithTeamMembers: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				projectsWithTeamMembers = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
					return projectsWithTeamMembers;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.TeamMembers.Count > 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},	
		__allChildProjectToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_loadAllChildrenProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				childrenProjects = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
					return childrenProjects;
				} else {
					return _.reduce(store.getRange(), function(map, project){
						map[project.data.ObjectID] = project;
						return map;
					}, {});
				}
			});
		},	
		__allLeafProjectsToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		_loadAllLeafProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				leafProjects = {}, 
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
					return leafProjects;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.Children.Count === 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},
		_loadProjectByName: function(projectName){
			if(!projectName) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [{
						property:'Name',
						value:projectName
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** Release loading ********************************************/	
		_loadAllReleases: function(projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesBeforeGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					disableMetaChangeEvent: true,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'<=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesInTheFuture: function(projectRecord){
			return this._loadReleasesAfterGivenDate(projectRecord, new Date());
		},
		_loadReleasesByNameUnderProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					}],
					context:{
						project:projectRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleaseByNameForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						operator:'contains',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_getScopedRelease: function(releaseRecords, projectOID, appPrefs){			
			/** gets the most likely release to scope to base on the following order:
				1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
								to use preferences for this one)
				2) if we are currently in one of the releases
				3) the closest release planning date to the current date
			*/
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate), d2 = new Date(r.data.ReleaseStartDate), now = new Date();
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
		/************************* MODEL FOR WORKWEEK DROPDOWNS *********************************************/
	Ext.define('WorkweekDropdown', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Workweek', type:'string'},
			{name: 'DateVal', type:'number'}
		]
	});
		
	/************************* USED FOR WORKSPACE TRAIN CONFIG *********************************************/
	Ext.define('TrainConfigItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'TrainProjectOID', type: 'number'},
			{name: 'TrainName', type: 'string'},
			{name: 'TrainAndPortfolioLocationTheSame', type:'boolean'},
			{name: 'PortfolioProjectOID', type:'number'}
		]
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/**  
		THIS IS ONLY USEFUL AS A RALLYAPP MIXIN 
		gives a window-centered alert or confirm dialog box that isn't ugly. 
	*/
	Ext.define('PrettyAlert', {

		__getMessageBoxY: function(){ 
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.parent.getWindowHeight(), 
				ps = window.parent.getScrollY(), 
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},
		
		_alert: function(title, message){
			var me=this;
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<1) return;
			if(arguments.length===1){
				message = title;
				title = '';
			}
			Ext.MessageBox.alert(title, message).setY(me.__getMessageBoxY());
			setTimeout(function(){ //give some time to give the 'ok' or 'yes' button focus
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 50);
		},
		
		_confirm: function(title, message, fn){
			var me=this;
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = message;
				message = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			Ext.MessageBox.confirm(title, message, fn).setY(me.__getMessageBoxY());
			setTimeout(function(){
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 20);
		}
	});
}());
                /** this is pretty much like a mutex implementation. you call enqueue and then when its your function's turn
	you do stuff and then you call the callback passed to you so the next function can execute */
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	//given named queues, only allows one function at a time in each queue to execute. 
	Ext.define('AsyncQueue', {
		
		QueueOfFuncs: {},
		
		_dequeue: function(queueName){
			var me=this;
			queueName = queueName || 'undefined'; //to be clear
			if(me.QueueOfFuncs[queueName]){
				me.QueueOfFuncs[queueName].shift();
				if(!me.QueueOfFuncs[queueName].length) return;
				else me.QueueOfFuncs[queueName][0].call(me, me._dequeue.bind(me, queueName));
			}
		},
		
		//callback(done)...make sure you call done when you are finished
		_enqueue: function(callback, queueName){
			var me=this;
			queueName = queueName || 'undefined'; //to be clear
			if(typeof callback !== 'function') throw 'ERROR: not a function';
			if(!me.QueueOfFuncs[queueName] || !me.QueueOfFuncs[queueName].length){
				me.QueueOfFuncs[queueName] = [callback];
				callback.call(me, me._dequeue.bind(me, queueName));
			}
			else me.QueueOfFuncs[queueName].push(callback);
		}
	});
}());
                /** This class is used to save user preferences per project, that can follow the user from app to app **/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('UserAppsPreference', {
		
		_userAppsPref: 'intel-user-apps-preference', //preference name can be overridden, unless you want all apps to share prefs
		
		_loadAppsPreference: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				filterByUser:true,
				filterByName:me._userAppsPref,
				success: function(prefs) {
					var appPrefs = prefs[me._userAppsPref];
					try{ appPrefs = JSON.parse(appPrefs); }
					catch(e){ appPrefs = { projs:{}, refresh:0};}
					deferred.resolve(appPrefs);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveAppsPreference: function(prefs){
			var me=this, s = {}, deferred = Q.defer();
			prefs = {projs:prefs.projs, refresh:prefs.refresh};
			s[me._userAppsPref] = JSON.stringify(prefs); 
			Rally.data.PreferenceManager.update({
				filterByUser: true,
				filterByName:me._userAppsPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** this combo has filter-as-you-type and drops down on click. it also lets you navigate with arrow keys
		(although there is some arrow key scrolling bug) 
	*/
	Ext.define('IntelComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelcombo', 'widget.intelcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				enableKeyEvents:true,
				queryMode:'local',
				ignoreNoChange:true,
				allowBlank:true,
				listeners: {
					keyup: function(a,b){
						if(b.keyCode>=37 && b.keyCode <=40) return; //arrow keys
						var combo = this;
						combo.store.clearFilter();
						combo.store.filterBy(function(item){
							return item.data[combo.displayField].match(new RegExp(combo.getRawValue(), 'i')) !== null;
						});
					},
					focus: function(combo) {
						combo.store.clearFilter();
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('IntelFixedComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				editable: false,	
				allowBlank:true,
				queryMode:'local',
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					focus: function(combo) {
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}	
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Rally.apps.portfoliohierarchy.FittedUserStoryTreeItem', {
		extend: 'Rally.ui.tree.UserStoryTreeItem',
		alias: 'widget.fitteduserstorytreeitem',

		config: {
			displayedFields: ['Name', 'Project', 'ScheduleState']
		},

		getContentTpl: function(){
			var me = this;
			return Ext.create('Ext.XTemplate',
				'<tpl if="this.canDrag()"><div class="icon drag"></div></tpl>',
				'{[this.getActionsGear()]}',
				'<div class="textContent ellipses" style="max-width:65%;">',
					'{[this.getFormattedId()]} - ',
					'<span title="{Name}\nProject: {[this.getProjectName()]}">{Name}</span>',
				'</div>',
				'<div class="rightSide">',
					'{[this.getScheduleState()]}',
				'</div>',
			{
				canDrag: function(){
					return me.getCanDrag();
				},
				getProjectName: function() {
					return me.getRecord().data.Project.Name;    
				},
				getActionsGear: function(){
					return me._buildActionsGearHtml();
				},
				getScheduleState: function(){
					return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'ScheduleState');
				},
				getFormattedId: function(){
					return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'FormattedID');
				}
			});
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Rally.apps.portfoliohierarchy.FittedPortfolioItemTreeItem', {
		extend: 'Rally.ui.tree.PortfolioItemTreeItem',
		alias: 'widget.fittedportfolioitemtreeitem',

		config: {
			displayedFields: ['Name', 'Plan']
		},

		getContentTpl: function(){
			var me = this;

			return Ext.create('Ext.XTemplate',
				'<tpl if="this.canDrag()"><div class="icon drag"></div></tpl>',
				'{[this.getActionsGear()]}',
				'<tpl if="this._renderPlanOnLowestLevelPortfolioItem()">',
					'<div class="textContent ellipses" style="max-width: 65%;">',
						'{[this.getFormattedId()]} - ',
						'<span title="{Name}">{Name}</span>',
						'<div class="textContent ellipses">{[this.getPlanData()]}</div>',
					'</div>',
				'<tpl else>',
					'<div class="textContent ellipses" style="max-width: 65%;">',
						'{[this.getFormattedId()]} - ',
						'<span title="{Name}">{Name}</span>',
					'</div>',
				'</tpl>',
				'<div class="rightSide">',
					'{[this.getPercentDone()]}',
				'</div>',
				{
					canDrag: function(){
						return me.getCanDrag();
					},
					getActionsGear: function(){
						return me._buildActionsGearHtml();
					},
					getPercentDone: function(){
						return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'PercentDoneByStoryCount');
					},
					getFormattedId: function(){
						return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'FormattedID');
					},
					getPlanData: function() {
						var plan = me.getRecord().data.Plan;
						var planName = plan && plan.name ? plan.name : "";
						return planName;
					},
					_renderPlanOnLowestLevelPortfolioItem: function() {
						return me.getRecord().self.isLowestLevelPortfolioItem();
					}
				}
			);
		}
	});
}());
                /** this is an app that makes portfolio hierarchies more customizable and stateful for each person **/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	var USER_TOKEN = (__PROJECT_OID__ + '-' + __USER_OID__);
	
	Ext.define('IntelPortfolioHierarchy', {
		extend: 'IntelRallyApp',
		mixins: [
			'Rally.Messageable',
			'PrettyAlert',
			'UserAppsPreference'
		],
		layout: {
			type:'vbox',
			align:'stretch',
			pack:'start'
		},
		items:[{
			xtype:'container',
			id:'headerRelease',
			layout:'hbox'
		},{
			xtype:'container',
			id:'headerProject',
			layout:'hbox'
		},{
			xtype:'container',
			id:'headerComplete',
			layout:'hbox'
		},{
			xtype:'container',
			id:'bodyContainer'
		}],
		
		_userAppsPref: 'intel-portfolio-nav',

		config: {
			defaultSettings: (function(){
				var s = {};
				s['Type' + USER_TOKEN] = ''; 
				s['QueryFilter' + USER_TOKEN] = '';
				s['InferPortfolioLocation' + USER_TOKEN] = true;
				s['PortfolioLocation' + USER_TOKEN] = 0;
				return s;
			}())
		},				
		getSettingsFields: function() {
			return [{
				name: 'Type' + USER_TOKEN,
				xtype:'rallycombobox',
				editable:false,
				queryFilter:true, //<--- this is a hack, but it works
				displayField:'Name',
				valueField:'Name',
				storeConfig:{
					xtype:'rallywsapidatastore',
					model: 'TypeDefinition',
					limit:Infinity,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					sorters: [{
						property: 'Ordinal',
						direction: 'DESC'
					}],
					context:{
						workspace:Rally.environment.getContext().getWorkspace()._ref,
						project:null
					}
				},
				listeners:{
					added: function(field, form){
						if(form.down('rallycombobox').value) field.hide();
						else field.show();
					}
				},
				label: 'Type',
				labelWidth: 120, width:'100%'
			},{
				name: 'QueryFilter' + USER_TOKEN,
				xtype: 'textfield',
				label: 'Query Filter',
				labelWidth: 120, width:'100%'
			},{
				name: 'InferPortfolioLocation' + USER_TOKEN,
				xtype:'rallycheckboxfield',
				label: 'Infer Portfolio Location',
				labelWidth: 120, width:'100%',
				bubbleEvents: ['change'] 
			},{
				name: 'PortfolioLocation' + USER_TOKEN,
				xtype:'rallycombobox',
				editable:false,
				queryFilter:true, //<--- this is a hack, but it works
				displayField:'Name',
				valueField:'ObjectID',
				storeConfig: {
					xtype:'rallywsapidatastore',
					model: 'Project',
					limit:Infinity,
					fetch:['ObjectID', 'Name'],
					sorters: [{
						property: 'Name',
						direction: 'ASC'
					}],
					context:{
						workspace:Rally.environment.getContext().getWorkspace()._ref,
						project:null
					}
				},
				label: 'Portfolio Location',
				labelWidth: 120, width:'100%',
				listeners:{
					added: function(field, form){
						if(form.down('rallycheckboxfield').value) field.hide();
						else{
							field.show();
							setTimeout(function(){
								var fieldVal = Rally.getApp().getSetting(field.name);
								if(fieldVal) field.setValue(fieldVal);
							}, 50);
						}
					}
				},
				handlesEvents: {
					change: function(checkbox, isChecked) {
						var field=this;
						if(isChecked) field.hide();
						else{
							field.show();
							setTimeout(function(){
								var fieldVal = Rally.getApp().getSetting(field.name);
								if(fieldVal) field.setValue(fieldVal);
							}, 50);
						}
					}
				}
			}];
		},
		
		/********************************************** Refreshing Data ***************************************************/
		_refreshTree: function() {
			var me=this;
			me.down('#bodyContainer').removeAll();
			me._buildPortfolioTree();
		},	
		_reloadEverything: function(){
			var me=this;
			me.setLoading(false);
			me._buildFilterOnRelease();
			me._buildReleasePicker();
			me._buildFilterOnProject();
			me._buildFilterOnComplete();
			me._buildPortfolioTree();
		},
		
		/************************************************** Launch ***************************************************/	
		launch: function() {
			var me=this;
			me.setLoading('Loading Configuration');
			me._configureIntelRallyApp()
				.then(function(){
					var scopeProject = me.getContext().getGlobalContext().getProject();
					return me._loadProject(scopeProject.ObjectID);
				})
				.then(function(scopeProjectRecord){
					me.ProjectRecord = scopeProjectRecord;
					return Q.all([
						me._projectInWhichTrain(me.ProjectRecord) /********* 1 ************/
							.then(function(trainRecord){
								if(trainRecord){
									me.TrainRecord = trainRecord;
									return me._loadTrainPortfolioProject(me.TrainRecord)
										.then(function(trainPortfolioProject){
											me.TrainPortfolioProject = trainPortfolioProject;
										});
								} 
							}),
						me._loadAppsPreference() /********* 2 ************/
							.then(function(appsPref){
								me.AppsPref = appsPref;
								var twelveWeeks = 1000*60*60*24*7*12;
								return me._loadReleasesAfterGivenDate(me.ProjectRecord, (new Date()*1 - twelveWeeks));
							})
							.then(function(releaseRecords){		
								me.ReleaseRecords = releaseRecords;
								me.ReleaseNames = [];
								for(var i=0,len=releaseRecords.length; i<len; ++i){
									me.ReleaseNames.push({ Name: releaseRecords[i].data.Name });
								}
							}),
						me._loadAllProjects() /********* 3 ************/
							.then(function(projects){
								me.AllProjects = projects;
							}),
						me._loadRandomUserStory(me.ProjectRecord) /********* 4 ************/
							.then(function(userStory){
								me.HasUserStories = !!userStory;
							})
					]);
				})
				.then(function(){
					var pid = me.ProjectRecord.data.ObjectID, 
						prefs = me.AppsPref.projs[pid] || {};
					me.PIType = me.getSetting('Type' + USER_TOKEN);
					if(!me.PIType){
						me.PIType = me.PortfolioItemTypes[0];
						var newSettings = {};
						newSettings['Type' + USER_TOKEN] = me.PIType;
						me.updateSettingsValues({settings:newSettings});
					}
					me.QueryFilter = me.getSetting('QueryFilter' + USER_TOKEN);
					me.InferPortfolioLocation = me.getSetting('InferPortfolioLocation' + USER_TOKEN);
					me.PortfolioLocation = me.getSetting('PortfolioLocation' + USER_TOKEN);
					me.FilterOnRelease = prefs.FilterOnRelease || false;
					me.FilterReleaseName = prefs.FilterReleaseName || (me.ReleaseNames.length ? me.ReleaseNames[0].Name : null);
					me.FilterOnProject = prefs.FilterOnProject || false;
					me.FilterOnComplete = prefs.FilterOnComplete || false;
					if(me.InferPortfolioLocation){
						if(me.TrainPortfolioProject) me.PortfolioLocation = me.TrainPortfolioProject;
						else me.PortfolioLocation = me.ProjectRecord;
					}
					else {
						if(me.PortfolioLocation){ //if ObjectID is set manually
							me.PortfolioLocation = _.find(me.AllProjects, function(p){ 
								return p.data.ObjectID === me.PortfolioLocation; 
							});
						}
						if(!me.PortfolioLocation){
							return Q.reject('Inferring Portfolio Location. You must set the ' + 
								'project that the portfolio resides in!');
						}
					}
					me._reloadEverything();
				})
				.fail(function(reason){
					me.setLoading(false);
					me._alert('ERROR', reason || '');
				})
				.done();
		},

		/*************************************************** HEADER ITEMS *********************************************/	
		_onPreferenceChanged: function(field, newValue){
			var me=this,
				pid = me.ProjectRecord.data.ObjectID;
			if(me[field] === newValue) return Q();
			else me[field] = newValue;
			if(typeof me.AppsPref.projs[pid] !== 'object') me.AppsPref.projs[pid] = {};
			me.AppsPref.projs[pid][field] = newValue;
			return me._saveAppsPreference(me.AppsPref);
		},
		_onReleaseSelected: function(combo, records){
			var me=this;
			me._onPreferenceChanged('FilterReleaseName', records[0].data.Name)
				.then(function(){ if(me.FilterOnRelease) me._refreshTree(); })
				.fail(function(reason){ me._alert('ERROR:', reason); })
				.done();
		},				
		_buildReleasePicker: function(){
			var me=this;
			Ext.getCmp('headerRelease').add({
				xtype:'intelfixedcombo',
				store: Ext.create('Ext.data.Store', {
					fields: ['Name'],
					sorters: [function(o1, o2){ return o1.data.Name > o2.data.Name ? -1 : 1; }],
					data: me.ReleaseNames
				}),
				hidden: !me.FilterOnRelease,
				displayField: 'Name',
				value: me.FilterReleaseName,
				listeners: { select: me._onReleaseSelected.bind(me) }
			});
		},		
		_onFilterOnReleaseChanged: function(checkBox){
			var me=this,
				value = checkBox.getValue(),
				box = Ext.getCmp('headerRelease').down('intelfixedcombo');
			if(value) box.show(); else box.hide();
			me._onPreferenceChanged('FilterOnRelease', value)
				.then(function(){ me._refreshTree(); })
				.fail(function(reason){ me._alert('ERROR:', reason); })
				.done();
		},
		_buildFilterOnRelease: function(){
			var me=this;
			Ext.getCmp('headerRelease').add({
				xtype: 'rallycheckboxfield',
				boxLabel: 'Filter ' + me.PortfolioItemTypes[0] + 's in Release',
				id: 'filterOnReleaseCheckbox',
				value: me.FilterOnRelease,
				listeners: { change: me._onFilterOnReleaseChanged.bind(me) }
			});
		},		
		_onFilterOnProjectChanged: function(checkBox){
			var me=this;
			me._onPreferenceChanged('FilterOnProject', checkBox.getValue())
				.then(function(){ me._refreshTree(); })
				.fail(function(reason){ me._alert('ERROR:', reason); })
				.done();
		},
		_buildFilterOnProject: function(){
			var me=this;
			Ext.getCmp('headerProject').add({
				xtype: 'rallycheckboxfield',
				boxLabel: 'Filter User Stories in Current Project',
				id: 'filterOnProjectCheckbox',
				hidden: !me.HasUserStories,
				value: me.FilterOnProject,
				listeners: { change: me._onFilterOnProjectChanged.bind(me) }
			});
		},			
		_onFilterOnCompleteChanged: function(checkBox){
			var me=this;
			me._onPreferenceChanged('FilterOnComplete', checkBox.getValue())
				.then(function(){ me._refreshTree(); })
				.fail(function(reason){ me._alert('ERROR:', reason); })
				.done();
		},
		_buildFilterOnComplete: function(){
			var me=this;
			Ext.getCmp('headerComplete').add({
				xtype: 'rallycheckboxfield',
				boxLabel: 'Hide Completed Items',
				labelWidth: 170,
				value: me.FilterOnComplete,
				listeners: { change: me._onFilterOnCompleteChanged.bind(me) }
			});
		},

		/******************************************************* GRID ITEMS *********************************************/
		_onTreeItemSelected: function(treeItem){
			if(treeItem.xtype === 'fittedportfolioitemtreeitem'){
				this.publish('portfoliotreeitemselected', treeItem);
			}
		},	
		_getDummyWsapiFilter: function(){
			return Ext.create('Rally.data.wsapi.Filter', {
				property: 'ObjectID',
				operator: '!=',
				value: 0
			});
		},
		_getFilterOnCompleteFilter: function(ordinal){
			//the best we can do is filter if state 'Done' or 'Complete(d)' exists
			var me=this,
				completeState = me._getPortfolioItemTypeStateByOrdinal(ordinal, 'Done') || 
					me._getPortfolioItemTypeStateByOrdinal(ordinal, 'Complete') || 
					me._getPortfolioItemTypeStateByOrdinal(ordinal, 'Completed');
			if(completeState){
				return Ext.create('Rally.data.wsapi.Filter', {
					property:'State.OrderIndex',
					operator:'<',
					value: completeState.data.Ordinal
				}).or(Ext.create('Rally.data.wsapi.Filter', {
					property:'State',
					value: null
				}));
			}
			else return me._getDummyWsapiFilter();
		},
		_getFilterOnReleaseFilter: function(){
			var me=this;
			return Ext.create('Rally.data.wsapi.Filter', {
				property: 'Release.Name',
				value: me.FilterReleaseName 
			});
		},
		_getFilterOnQueryFilter: function(){
			try { return Rally.data.QueryFilter.fromQueryString(this.QueryFilter); }
			catch(e){ return this._getDummyWsapiFilter(); }
		},	
		_getParentRecordFilter: function(parentRecord, ordinal){
			return Ext.create('Rally.data.wsapi.Filter', {
				property: (ordinal === 0 ? 'PortfolioItem' : 'Parent') + '.ObjectID', //only uses right under lowest PI have issue
				value: parentRecord.data.ObjectID
			});
		},	
		_getTopLevelStoreConfig: function(ordinal){ //ordinal of this level
			var me=this, 
				filters = [];
			if(me.FilterOnComplete) filters.push(me._getFilterOnCompleteFilter(ordinal));
			if(me.FilterOnRelease && ordinal === 0) filters.push(me._getFilterOnReleaseFilter());
			if(me.QueryFilter) filters.push(me._getFilterOnQueryFilter());
			return {
				limit:Infinity,
				filters: filters,
				context: {
					project: me.PortfolioLocation.data._ref,
					projectScopeDown: true,
					projectScopeUp: false
				}
			};
		},
		_getChildLevelStoreConfig: function(tree, parentRecord, isPI, ordinal){ //ordinal and isPI of PARENT item
			var me=this,
				context= {
					project: me.PortfolioLocation.data._ref,
					projectScopeDown: true,
					projectScopeUp: false
				},
				filters = [ me._getParentRecordFilter(parentRecord, ordinal)];
			if(me.FilterOnComplete && isPI && ordinal > 0) filters.push(me._getFilterOnCompleteFilter(ordinal));
			if(!isPI || ordinal === 0) {
				if(me.FilterOnProject){ //we want only this project's stories
					context.project = me.ProjectRecord.data._ref;
					context.projectScopeDown = false;
				}
				else { //we want ALL user stories
					context.project = null;
					context.projectScopeDown = false;
				}
			} 
			if(me.FilterOnRelease && isPI && ordinal === 1) filters.push(me._getFilterOnReleaseFilter());
			if(me.QueryFilter) filters.push(me._getFilterOnQueryFilter());
			return {
				limit:Infinity,
				fetch: tree._getDefaultTopLevelFetchFields().concat(['Parent', 'Project', 'State']),
				context: context,
				filters:filters
			};
		},	
		_buildPortfolioTree: function(){
			var me = this,
				modelName ='PortfolioItem/' + me.PIType,
				ordinal = me._portfolioItemTypeToOrdinal(me.PIType);

			me.down('#bodyContainer').add({
				xtype: 'rallyportfoliotree',
				stateful: true,
				stateId: me.getAppId() + 'rallyportfoliotree',
				topLevelModel: modelName,
				topLevelStoreConfig: me._getTopLevelStoreConfig(ordinal),
				listeners: {
					itemselected: me._onTreeItemSelected.bind(me)
				},
				childItemsStoreConfigForParentRecordFn: function(parentRecord) {
					var tree = this,
						isPI = tree._isPortfolioItem(parentRecord),
						ordinal = parentRecord.self.ordinal;
					return me._getChildLevelStoreConfig(tree, parentRecord, isPI, ordinal);
				},
				treeItemConfigForRecordFn: function(record){
					var tree = this,
						config = Rally.ui.tree.PortfolioTree.prototype.treeItemConfigForRecordFn.call(tree, record);
					if(tree._isPortfolioItem(record)) config.xtype = 'fittedportfolioitemtreeitem'; 
					else config.xtype = 'fitteduserstorytreeitem'; 
					return config;
				}
			});
		}
	});
}());

            Rally.launchApp('IntelPortfolioHierarchy', {
                name:"Portfolio Hierarchy",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .portfolio-hierarchy-app {
  width: 100% !important;
}
.portfolio-hierarchy-app .rallytree {
  padding-top: 5px;
  padding-bottom: 20px;
}
.portfolio-hierarchy-app .header {
  border-bottom: 1px dotted #c6c6c6;
}
.portfolio-hierarchy-app .filterInfo {
  float: right;
  padding-right: 1px;
  border-right: 1px solid #CCC;
  margin-right: 5px;
  margin-top: 2px;
  margin-bottom: 2px;
}
.portfolio-hierarchy-app .rally-help-icon {
  float: right;
}
.portfolio-hierarchy-app .current-project-only-float {
  float: left;
}
.portfolio-hierarchy-app .filter-on-release-float {
  float: left;
  margin-left: 10px;
  margin-right: 8px;
}
#filterOnReleaseCheckbox {
  padding: 0 4px 0 0;
}
#filterOnProjectCheckbox {
  padding: 0 4px 0 0;
}

    </style>
</head>
<body>
</body>
</html>
