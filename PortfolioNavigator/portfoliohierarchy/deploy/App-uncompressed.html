<!DOCTYPE html>
<html>
<head>
    <title>Portfolio Hierarchy</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('IntelRallyApp', {
	alias: 'widget.intelrallyapp',
  extend: 'Rally.app.App',
	
	/** these are the necessary models to load for the apps. you should call this */
	_loadModels: function(){
		var me=this, 
			promises = [],
			models = {
				Project: 'Project',
				UserStory: 'HierarchicalRequirement',
				Feature:'PortfolioItem/Feature',
				Milestone:'PortfolioItem/Milestone'
			};
		_.each(models, function(modelType, modelName){
			var deferred = Q.defer();
			Rally.data.WsapiModelFactory.getModel({ //load project
				type:modelType, 
				success: function(loadedModel){ 
					me[modelName] = loadedModel;
					deferred.resolve();
				}
			});
			promises.push(deferred.promise);
		});
		return Q.all(promises);
	},
	
	_loadProject: function(oid){ 
		var me = this, deferred = Q.defer();
		if(!oid) return Q.resolve();
		else if(!me.Project){ 
			return me._loadModels().then(function(){ 
				return me._loadProject(oid); 
			});
		}
		else {
			me.Project.load(oid, {
				fetch: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name'],
				context: {
					workspace: me.getContext().getWorkspace()._ref,
					project: null
				},
				callback: deferred.resolve
			});
			return deferred.promise;
		}
	},
	
	_loadFeature: function(oid, projectRef){ //projectRef is optional
		var me = this, deferred = Q.defer();
		if(!oid) return Q.resolve();
		else if(!me.Feature){ 
			return me._loadModels().then(function(){ 
				return me._loadFeature(oid, projectRef); 
			});
		}
		else {
			me.Feature.load(oid, {
				fetch: ['Name', 'ObjectID', 'FormattedID', 'c_TeamCommits', 'c_Risks', 'Project', 'PlannedEndDate', 'Parent'],
				context: {
					workspace: me.getContext().getWorkspace()._ref,
					project: projectRef
				},
				callback: deferred.resolve
			});
			return deferred.promise;
		}
	},
	
	_loadUserStory: function(oid, projectRef){ 
		var me = this, deferred = Q.defer();
		if(!oid) return Q.resolve();
		else if(!me.UserStory){ 
			return me._loadModels().then(function(){ 
				return me._loadUserStory(oid, projectRef); 
			});
		}
		else {
			me.UserStory.load(oid, {
				fetch: ['Name', 'ObjectID', 'Release', 'Project', 'Feature',
					'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
				context: {
					workspace: me.getContext().getWorkspace()._ref,
					project: projectRef
				},
				callback: deferred.resolve
			});
			return deferred.promise;
		}
	},
	
	_loadMilestone: function(oid, projectRef){ 
		var me = this, deferred = Q.defer();
		if(!oid) return Q.resolve();
		else if(!me.Milestone){ 
			return me._loadModels().then(function(){ 
				return me._loadMilestone(oid); 
			});
		}
		else {
			me.Milestone.load(oid, {
				fetch: ['ObjectID', 'Parent', 'Name'],
				context: {
					workspace: me.getContext().getWorkspace()._ref,
					project: projectRef
				},
				callback: deferred.resolve
			});
			return deferred.promise;
		}
	},
	
	/**************************************** SOME UTIL FUNCS ***************************************************/
	_loadRootProject: function(projectRecord){
		if(!projectRecord) return Q.reject('Invalid arguments: LRP');
		var me=this, 
			n = projectRecord.data.Name;
		if(n === 'All Scrums' || n === 'All Scrums Sandbox') return Q(projectRecord);
		else if(!projectRecord.data.Parent) return Q.reject('Please Scope to a valid team for Release Planning');
		else {
			return me._loadProject(projectRecord.data.Parent.ObjectID).then(function(parentRecord){
				return me._loadRootProject(parentRecord);
			});
		}
	},
	
	_projectInWhichTrain: function(projectRecord){ // returns train the projectRecord is in, otherwise null.
		if(!projectRecord) return Q.reject('Invalid arguments: PIWT');
		else {
			var me=this, split = projectRecord.data.Name.split(' ART');
			if(split.length>1) return Q(projectRecord);
			else { 
				var parent = projectRecord.data.Parent;
				if(!parent) return Q.reject('Project not in a train');
				else {
					return me._loadProject(parent.ObjectID).then(function(parentRecord){
						return me._projectInWhichTrain(parentRecord);
					});
				}
			}
		}
	},
	
	_loadAllTrains: function(rootProjectRecord){
		if(!rootProjectRecord) return Q.reject('Invalid arguments: LAT');
		var me=this,
			store = Ext.create('Rally.data.wsapi.Store',{
				model: 'Project',
				remoteSort:false,
				limit:Infinity,
				fetch: ['Name', 'ObjectID'],
				context:{
					workspace: me.getContext().getWorkspace()._ref,
					project: null
				},
				filters:[{
						property:'Name',
						operator: 'contains',
						value: ' ART'
					},{
						property: 'Name',
						operator: (rootProjectRecord.data.Name === 'All Scrums Sandbox' ? 'contains' : '!contains'),
						value: 'Test'
					}
				]
			});
		return me._reloadStore(store).then(function(store){
			console.log('AllTrainRecords loaded', store.data.items);
			return Q(store);
		});
	},
			
	_loadRandomUserStory: function(projectRef){ //get the most recent 5 in the project!!
		if(!projectRef) return Q.reject('Invalid arguments: LRUS');
		var me=this,
			store = Ext.create('Rally.data.wsapi.Store',{
				model: 'HierarchicalRequirement',
				limit:5,
				pageSize:5,
				fetch: ['Name', 'CreationDate', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
				context:{
					workspace: me.getContext().getWorkspace()._ref,
					project: undefined
				},
				sorters: [{
					property: 'CreationDate', 
					direction:'DESC'
				}],
				filters:[{
					property:'Project',
					value: projectRef
				}]
			});
		return me._reloadStore(store).then(function(store){
			var records = store.data.items;
			if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
			else return Q(undefined);
		});
	},
	
	_loadUserStoryByFID: function(formattedID, projectRef){ //must supply both argument
		if(!formattedID || !projectRef) return Q.reject('Invalid arguments: LUSBFID');
		var me=this,
			store = Ext.create('Rally.data.wsapi.Store',{
				model: 'HierarchicalRequirement',
				limit:1,
				pageSize:1,
				fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
				context:{
					workspace: me.getContext().getWorkspace()._ref,
					project: undefined
				},
				filters: [{
					property:'FormattedID',
					value:formattedID
				},{
					property:'Project._ref',
					value: projectRef
				}]
			});
		return me._reloadStore(store).then(function(store){
			return Q(store.data.items.pop());
		});
	},
	
	_loadProjectByName: function(name){
		if(!name) return Q.reject('Invalid arguments: LPBN');
		var me=this,
			store = Ext.create('Rally.data.wsapi.Store',{
				model: 'Project',
				limit:1,
				pageSize:1,
				fetch: ['Name', 'ObjectID'],
				context:{
					workspace: me.getContext().getWorkspace()._ref,
					project: null
				},
				filters: [
					{
						property:'Name',
						value:name
					}
				]
			});
		return me._reloadStore(store).then(function(store){
			return Q(store.data.items.pop());
		});
	},
	
	/********************************************** FEATURES  ********************************************/
	_getFeatureFilter: function(trainRecord, releaseRecord){
		if(!trainRecord || !releaseRecord) throw 'invalid arguments: GFF';
		var me=this,
			trainName = trainRecord.data.Name.split(' ART')[0];
			coreFilter = Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.Name',
				value: releaseRecord.data.Name
			});
		if(trainRecord.data.Name == 'Test ART (P&E)'){
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Project.Name',
				value: 'Test ART (P&E)'
			}).and(coreFilter);
		}
		else {
			return Ext.create('Rally.data.wsapi.Filter', { //NOTE: they should NOT be in the POWG portfolio level, but we will cover that just in case
				property:'Project.Parent.Name',
				value: trainName + ' POWG Portfolios'
			}).or(Ext.create('Rally.data.wsapi.Filter', {
				property:'Project.Name',
				value: trainName + ' POWG Portfolios'
			})).and(coreFilter);
		}
	},
	
	/*************************************************** Products ********************************************/
	_getProductFilter: function(trainRecord){ //products can be in 2 different levels of the portfolio hierarchy
		if(!trainRecord) throw 'invalid arguments: GPF';
		var me=this,
			trainName = trainRecord.data.Name.split(' ART')[0];
		if(trainName === 'Test'){
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Project.Name',
				value: 'Test ART (P&E)'
			});
		}
		else {
			return Ext.create('Rally.data.wsapi.Filter', {//NOTE: they should NOT be in the POWG portfolio level, but we will cover that just in case
				property:'Project.Parent.Name',
				value: trainName + ' POWG Portfolios'
			}).or(Ext.create('Rally.data.wsapi.Filter', {
				property:'Project.Name',
				value: trainName + ' POWG Portfolios'
			}));
		}
	},
	
	_loadProducts: function(trainRecord){
		if(!trainRecord) return Q.reject('Invalid arguments: LPROD');
		var me=this,
			store = Ext.create('Rally.data.wsapi.Store',{
				model: 'PortfolioItem/Product',
				limit:Infinity,
				remoteSort:false,
				fetch: ['Name'],
				context:{
					workspace: this.getContext().getWorkspace()._ref,
					project: null
				},
				filters:[me._getProductFilter(trainRecord)]
			});
		return me._reloadStore(store).then(function(store){
			console.log('Products loaded', store.data.items);
			return Q(store);
		});
	},
	
	/********************************************** Load Valid Projects ********************************************/
	
	_addValidProjectsToList: function(projTree, hash){
		var me=this, 
			curProj = projTree.ProjectRecord;
		if(curProj.data.TeamMembers.Count >0) 
			hash[curProj.data.ObjectID] = curProj;
		for(var childProjRef in projTree){
			if(childProjRef !== 'ProjectRecord')
				me._addValidProjectsToList(projTree[childProjRef], hash);
		}
	},
	
	_loadValidProjects: function(rootProjectRecord){ //all projects under All Scrums that have team Members
		if(!rootProjectRecord) return Q.reject('Invalid arguments: LVP');
		var me=this,
			validProjects = {}, 
			projTree = {};
		var store = Ext.create('Rally.data.wsapi.Store', {
			model: "Project",
			fetch: ['Name', 'Parent', 'ObjectID', 'TeamMembers'],
			limit:Infinity,
			context: {
				workspace: me.getContext().getWorkspace()._ref,
				project:null
			}
		});
		return me._reloadStore(store).then(function(store){
			var projects = store.data.items;
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			me._addValidProjectsToList(projTree[rootProjectRecord.data.ObjectID], validProjects);
			console.log('valid projects', validProjects);
			return Q(validProjects);
		});	
	},
	
	_allChildProjectToList: function(projTree, hash){
		var me=this, 
			curProj = projTree.ProjectRecord;
		hash[curProj.data.ObjectID] = curProj;
		for(var childProjRef in projTree){
			if(childProjRef !== 'ProjectRecord')
				me._allChildProjectToList(projTree[childProjRef], hash);
		}
	},
	
	_loadAllChildrenProjects: function(rootProjectRecord){
		if(!rootProjectRecord) return Q.reject('Invalid arguments: LACP');
		var me=this,
			childrenProjects = {}, 
			projTree = {};
		var store = Ext.create('Rally.data.wsapi.Store', {
			model: "Project",
			fetch: ['Name', 'Parent', 'ObjectID'],
			limit:Infinity,
			context: {
				workspace: me.getContext().getWorkspace()._ref,
				project:null
			}
		});
		return me._reloadStore(store).then(function(store){
			var projects = store.data.items;
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			me._allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
			console.log('childrenProjects', childrenProjects);
			return Q(childrenProjects);
		});	
	},
	
	
	/********************************************** Generic store loading, returns promise ********************************************/
	
	_reloadStore: function(store){
		var deferred = Q.defer();
		store.load({
			callback: function(records, operation, success){
				if(!success) deferred.reject(operation.getError() || 'Could not load data');
				else deferred.resolve(store);
			}
		});
		return deferred.promise;
	}
});
                /************************* MODEL FOR WORKWEEK DROPDOWNS *********************************************/
Ext.define('WorkweekDropdown', {
	extend: 'Ext.data.Model',
	fields: [
		{name: 'Workweek', type:'string'},
		{name: 'DateVal', type:'number'}
	]
});
                /** this is used if you want to listen to events in the parent window (e.g. useful for rally apps that resize with browser screen
		vertically or things that need to know browser scroll position) 
	You also can artificially fire the events and have the listeners run
*/
Ext.define('WindowListener', {

	__initWindowEventListener: function(eventName){
		var me=this;
		if(!me._windowListeners) me._windowListeners = {};
		me._windowListeners[eventName] = [];
		
		window.parent['on' + eventName] = function(event){ 
			var listeners = me._windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i)
				listeners[i](event);
		};
	},
	
	_addWindowEventListener: function(eventName, fn){
		var me=this;
		if(!me._windowListeners || !me._windowListeners[eventName]) 
			me.__initWindowEventListener(eventName);
		me._windowListeners[eventName].push(fn);
	},
	
	_fireParentWindowEvent: function(eventName){ //eg: resize or scroll
		var me=this;
		if(!me._windowListeners || !me._windowListeners[eventName]) return;
		var listeners = me._windowListeners[eventName];
		for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
	}
});
                /** 
	resizes the iframe to be a little bigger than the inner contents, so theres no ugly double vertical scroll bar 
**/

Ext.define('IframeResize', {
	requires: ['WindowListener'],
	
	/** resizes the iframe to be the height of all the items in it */
	_applyIframeResizeToContents: function(){ 
		var w = window, p = w.parent, pd = w.parent.document, l = w.location,
			iframe = pd.querySelector('iframe[src="' + l.pathname + l.search + '"]'),
			ip1 = iframe.parentNode,
			ip2 = iframe.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode, //this is apparently the one that matters
			height = 0, next = this.down();
		while(next){
			height += next.getHeight() + next.getEl().getMargin('tb')*1 + next.getEl().getPadding('tb')*1;
			next = next.next();
		}
		height += 150;
		ip1.style.height = height + 'px';
		ip2.style.height = height + 'px';
		iframe.style.height = height + 'px';
	},
	
	/** 
		This attaches a listener to the parent window resize event. When the parent window resizes, this resets the iframe height
		to that of the contents! Call this if you want the scrollbar to be on the outsize of the app (the window scrollbar)
	*/
	_initIframeResizeToContents: function(){
		var me=this;
		if(me._addWindowEventListener){
			me._addWindowEventListener('resize', function(){ me._applyIframeResizeToContents(); });
		}
	},
		
	/** 
		resizes the iframe to be the height of the window. its like rally autoheight app but better 
	*/
	_applyIframeResizeToWindow: function(){ 
		var loc = window.location,
			iframe = Ext.get(window.parent.document.querySelector('iframe[src="' + loc.pathname + loc.search + '"]')),
			i = iframe.dom,
			portlet = iframe.up('.x-portlet'),
			portalColumn = portlet.up('.x-portal-column'),
			dashboard = portlet.up('#mydash_portlet');
		height = window.parent.innerHeight - 70;
		height -= 200; //~120 on top and 60 on bottom and
		iframe.style.height = height + 'px';
		ip1.style.height = height + 'px';
		height += 30;
		ip2.style.height = height + 'px';
	},
	
		/** 
		This attaches a listener to the parent window resize event. When the parent window resizes, this resets the iframe height
		to that of the window! Call this if you want the scrollbar to be on the inside of the app (NOT the window scrollbar)
	*/
	_initIframeResizeToWindow: function(){
		var me=this;
		if(me._addWindowEventListener){
			me._addWindowEventListener('resize', function(){ me._applyIframeResizeToWindow(); });
		}
		me._applyIframeResizeToWindow();
	},
	
	/***************** ************* ********* GOOD STUFF BELOW ********************* ************* *********************/
	
	_fixRallyDashboard: function(){ //makes app as large as screen, without the stupid padding/margin
		var me=this,
			loc = window.location,
			iframe = Ext.get(window.parent.document.querySelector('iframe[src="' + loc.pathname + loc.search + '"]')),
			portlet = iframe.up('.x-portlet'), 
			portalColumn = portlet.up('.x-portal-column'), //has huge right margin (we don't explicitly need it here)
			dashboard = portlet.up('#mydash_portlet'), //has huge padding values
			i = iframe.dom,
			innerHeight = window.parent.innerHeight;
		//adjust widths
		while(true){
			i.style.width = (window.parent.innerWidth - 4) + 'px';
			i.style.padding = '0';
			i.style.margin = '0';
			if(i.id === 'mydash_portlet') break;
			i = i.parentNode;
		}
		
		//adjust heights
		dashboard.dom.style.height = (innerHeight - 65) + 'px';
		portlet.dom.style.height = (innerHeight - 105) + 'px';
		iframe.dom.parentNode.style.height = (innerHeight - 135) + 'px';
		iframe.dom.style.height = (innerHeight - 135) + 'px';
		
		//final touches
		dashboard.dom.style.padding = "0 2px 0 2px";
	},
	
	_initFixRallyDashboard: function(){ 
		var me=this;
		if(me._addWindowEventListener){
			me._addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
		}
		me._fixRallyDashboard();
	},

	_disableResizeHandle: function(){ //hides the draggable resize handle from under the app
		var me=this;
		var loc = window.location,
			iframe = Ext.get(window.parent.document.querySelector('iframe[src="' + loc.pathname + loc.search + '"]')),
			portlet = iframe.up('.x-portlet'),
			handle = portlet.down('.x-resizable-handle');
		if(handle){
			handle.hide();
			handle.dom.onshow = function(){
				if(handle) handle.hide();
			};
		}
	},
		
	_initDisableResizeHandle: function(){
		var me=this;
		if(me._addWindowEventListener){
			me._addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
		}
		me._disableResizeHandle();
	}
	
});
                /**  
	THIS IS ONLY USEFUL AS A RALLYAPP MIXIN 
	gives a window-centered alert or confirm dialog box that isn't ugly. 
*/
Ext.define('PrettyAlert', {

	__getMessageBoxY: function(){ 
		var w = window, p = w.parent, pd = w.parent.document, l = w.location,
			iframe = pd.querySelector('iframe[src="' + l.pathname + l.search + '"]');
		
		var ph = p.getWindowHeight(), 
			ps = p.getScrollY(), 
			ofy = ps + iframe.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
			iyOffset = Math.floor(ph/2 - ofy + ps - 50);
		return iyOffset<0 ? 0 : iyOffset;
	},
	
	_alert: function(title, str){		
		if(arguments.length<1) return;
		if(arguments.length===1){
			str = title;
			title = '';
		}
		Ext.MessageBox.alert(title, str).setY(this.__getMessageBoxY());
		setTimeout(function(){ //give some time to give the 'ok' or 'yes' button focus
			var x = Ext.MessageBox.down('button');
			while(x.isHidden()) x = x.nextSibling();
			x.focus();
		}, 20);
	},
	
	_confirm: function(title, str, fn){
		if(arguments.length<2) return;
		if(arguments.length===2){
			fn = str;
			str = title;
			title = '';
		}
		if(typeof fn !== 'function') fn = function(){};
		Ext.MessageBox.confirm(title, str, fn).setY(this.__getMessageBoxY());
		setTimeout(function(){
			var x = Ext.MessageBox.down('button');
			while(x.isHidden()) x = x.nextSibling();
			x.focus();
		}, 20);
	}
});
                /** Mixin functions related to queries, you need to require Q as a dependency in your rally app
	Q can be found here: https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js
	most functions return promises that resolve to stores
*/

Ext.define('ReleaseQuery', {

	_loadAllReleases: function(projectRecord){
		var deferred = Q.defer();
		Ext.create('Rally.data.wsapi.Store',{
			model: 'Release',
			limit:Infinity,
			autoLoad:true,
			fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
			context:{
				workspace: this.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'Project.ObjectID',
					value: projectRecord.data.ObjectID
				}
			],
			listeners: {
				load: {
					fn: function(releaseStore, releaseRecords){
						console.log('releases loaded:', releaseRecords);
						deferred.resolve(releaseStore);
					},
					single:true
				}
			}
		});
		return deferred.promise;
	},
	
	/** gets releases for this project that have release date >= now. returns promise that resolves to the releaseStore */
	_loadReleasesInTheFuture: function(projectRecord){
		var deferred = Q.defer();
		Ext.create('Rally.data.wsapi.Store',{
			model: 'Release',
			limit:Infinity,
			autoLoad:true,
			fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
			context:{
				workspace: this.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'Project.ObjectID',
					value: projectRecord.data.ObjectID
				},{
					property:'ReleaseDate',
					operator:'>=',
					value: new Date().toISOString()
				}
			],
			listeners: {
				load: {
					fn: function(releaseStore, releaseRecords){
						console.log('releases loaded:', releaseRecords);
						deferred.resolve(releaseStore);
					},
					single:true
				}
			}
		});
		return deferred.promise;
	},
	
	/** loads this release for each scrum under this train. returns promise with the release Store 
		the scrums that the releases belong to will have at least 1 team member, and the train's release is not included
		in the results.
	**/
	_loadReleasesWithName: function(releaseName, trainName){ 
		var deferred = Q.defer();
		Ext.create('Rally.data.wsapi.Store',{
			model: 'Release',
			limit:Infinity,
			autoLoad:true,
			fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
			context:{
				workspace: this.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'Name', //match the release
					value: releaseName
				},{
					property:'Project.Name', //is a child of the train
					operator:'contains',
					value:trainName
				},{
					property:'Project.Children.Name', //has teamMembers 
					operator:'=',
					value:''
				},{
					property:'Project.Name', //but not the train release itsself
					operator:'!contains',
					value:' ART'
				}
			],
			listeners: {
				load: {
					fn: function(store, records){
						console.log('releasesWithName loaded:', records);
						deferred.resolve(store);
					},
					single:true
				}
			}
		});
		return deferred.promise;
	},
	
	/** gets the most likely release to scope to base on the following order:
		1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
						to use preferences for this one)
		2) if we are in a release
		3) the closest release planning date to the current date
	*/
	_getScopedRelease: function(releaseRecords, projectOID, appPrefs){
		var me=this,
			d = new Date(),
			rs = releaseRecords,
			prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
		return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
			_.find(rs, function(r){
				return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
			}) ||
			_.reduce(rs, function(best, r){
				if(best===null) return r;
				else {
					var d1 = new Date(best.data.ReleaseStartDate), d2 = new Date(r.data.ReleaseStartDate), now = new Date();
					return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
				}
			}, null);
	}
});
                //given named queues, only allows one function at a time in each queue to execute. 
Ext.define('AsyncQueue', {
	
	QueueOfFuncs: {},
	
	_dequeue: function(queueName){
		var me=this;
		queueName = queueName || 'undefined'; //to be clear
		if(me.QueueOfFuncs[queueName]){
			me.QueueOfFuncs[queueName].shift();
			if(!me.QueueOfFuncs[queueName].length) return;
			else me.QueueOfFuncs[queueName][0].call(me, me._dequeue.bind(me, queueName));
		}
	},
	
	//callback(done)...make sure you call done when you are finished
	_enqueue: function(callback, queueName){
		var me=this;
		queueName = queueName || 'undefined'; //to be clear
		if(typeof callback !== 'function') return console.log('ERR: not a function', callback);
		if(!me.QueueOfFuncs[queueName] || !me.QueueOfFuncs[queueName].length){
			me.QueueOfFuncs[queueName] = [callback];
			callback.call(me, me._dequeue.bind(me, queueName));
		}
		else me.QueueOfFuncs[queueName].push(callback);
	}
});
                /** this combo has filter-as-you-type and drops down on click. it also lets you navigate with arrow keys
	(although there is some arrow key scrolling bug) 
*/
Ext.define('Intel.form.field.ComboBox', {
	extend:'Ext.form.field.ComboBox',
	alias: ['widget.intelcombo', 'widget.intelcombobox'],
	
	constructor: function(options) {
		options = options || {};
		options = Ext.merge({
			enableKeyEvents:true,
			queryMode:'local',
			ignoreNoChange:true,
			allowBlank:false,
			listeners: {
				keyup: function(a,b){
					if(b.keyCode>=37 && b.keyCode <=40) return; //arrow keys
					var combo = this;
					combo.store.clearFilter();
					combo.store.filterBy(function(item){
						return item.data[combo.displayField].match(new RegExp(combo.getRawValue(), 'i')) !== null;
					});
				},
				focus: function(combo) {
					combo.store.clearFilter();
					combo.setValue('');
					combo.expand();
				}
			}
		}, options);
		this.callParent([options]);
	}
});
                Ext.define('Intel.form.field.FixedComboBox', {
	extend:'Ext.form.field.ComboBox',
	alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
	
	constructor: function(options) {
		options = options || {};
		options = Ext.merge({
			editable: false,	
			allowBlank:false,
			listeners: {
				focus: function(combo) {
					combo.setValue('');
					combo.expand();
				}
			}
		}, options);
		this.callParent([options]);
	}	
});
                Ext.define('Intel.form.field.PiProjectComboBox', {
	extend:'Intel.form.field.ComboBox',
	alias: ['widget.intelPIprojectcombo'],
	requires:[
		'IntelRallyApp'
	],
	constructor: function(options) {
		var me = this,
			app= Rally.getApp();
		
		options = options || {};	
		options = Ext.merge({
			displayField:'Name',
			enableKeyEvents:true,
			queryMode:'local',
			ignoreNoChange:true,
			allowBlank:false,
			validator: function(value){
				if(me.isHidden()) return true;
				return !!_.find(me.ChildProjects, function(proj){ return proj.data.Name === value; });
			},
			listeners: {
				keyup: function(a,b){
					if(b.keyCode>=37 && b.keyCode <=40) return; //arrow keys
					var combo = this;
					combo.store.clearFilter();
					combo.store.filterBy(function(item){
						return item.data[combo.displayField].match(new RegExp(combo.getRawValue(), 'i')) !== null;
					});
				},
				focus: function(combo) {
					combo.store.clearFilter();
					combo.expand();
				}
			}
		}, options);
		me.callParent([options]);
		
		app._loadProjectByName('All Releases')
			.then(function(rootProject){
				return app._loadAllChildrenProjects(rootProject);
			})
			.then(function(childProjects){
				var data = [];
				me.ChildProjects = childProjects;
				for(var projOID in childProjects)
					data.push({ Name: childProjects[projOID].data.Name });
				me.bindStore(Ext.create('Ext.data.Store', {
					sorters:[function(o1, o2){ return o1.data.Name < o2.data.Name ? -1 : 1; }],
					fields:['Name'],
					data:data
				}));
				if(typeof me.value === 'number') 
					me.setValue(me.ChildProjects[me.value].data.Name);
			})
			.fail(function(reason){
				app._alert('ERROR', reason || '');
			})
			.done();
	}
});
                Ext.define('Rally.apps.portfoliohierarchy.FittedUserStoryTreeItem', {
	extend: 'Rally.ui.tree.UserStoryTreeItem',
	alias: 'widget.fitteduserstorytreeitem',

	config: {
		displayedFields: ['Name', 'Project', 'ScheduleState']
	},

	getContentTpl: function(){
		var me = this;
		return Ext.create('Ext.XTemplate',
			'<tpl if="this.canDrag()"><div class="icon drag"></div></tpl>',
			'{[this.getActionsGear()]}',
			'<div class="textContent ellipses" style="max-width:65%;">',
				'{[this.getFormattedId()]} - ',
				'<span title="{Name}\nProject: {[this.getProjectName()]}">{Name}</span>',
			'</div>',
			'<div class="rightSide">',
				'{[this.getScheduleState()]}',
			'</div>',
		{
			canDrag: function(){
				return me.getCanDrag();
			},
			getProjectName: function() {
				return me.getRecord().data.Project.Name;    
			},
			getActionsGear: function(){
				return me._buildActionsGearHtml();
			},
			getScheduleState: function(){
				return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'ScheduleState');
			},
			getFormattedId: function(){
				return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'FormattedID');
			}
		});
	}
});
                Ext.define('Rally.apps.portfoliohierarchy.FittedPortfolioItemTreeItem', {
	extend: 'Rally.ui.tree.PortfolioItemTreeItem',
	alias: 'widget.fittedportfolioitemtreeitem',

	config: {
		displayedFields: ['Name', 'Plan']
	},

	getContentTpl: function(){
		var me = this;

		return Ext.create('Ext.XTemplate',
			'<tpl if="this.canDrag()"><div class="icon drag"></div></tpl>',
			'{[this.getActionsGear()]}',
			'<tpl if="this._renderPlanOnLowestLevelPortfolioItem()">',
				'<div class="textContent ellipses" style="max-width: 65%;">',
					'{[this.getFormattedId()]} - ',
					'<span title="{Name}">{Name}</span>',
					'<div class="textContent ellipses">{[this.getPlanData()]}</div>',
				'</div>',
			'<tpl else>',
				'<div class="textContent ellipses" style="max-width: 65%;">',
					'{[this.getFormattedId()]} - ',
					'<span title="{Name}">{Name}</span>',
				'</div>',
			'</tpl>',
			'<div class="rightSide">',
				'{[this.getPercentDone()]}',
			'</div>',
			{
				canDrag: function(){
					return me.getCanDrag();
				},
				getActionsGear: function(){
					return me._buildActionsGearHtml();
				},
				getPercentDone: function(){
					return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'PercentDoneByStoryCount');
				},
				getFormattedId: function(){
					return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'FormattedID');
				},
				getPlanData: function() {
					var plan = me.getRecord().data.Plan;
					var planName = plan && plan.name ? plan.name : "";
					return planName;
				},
				_renderPlanOnLowestLevelPortfolioItem: function() {
					return me.getRecord().self.isLowestLevelPortfolioItem();
				}
			}
		);
	}
});
                Ext.define('Rally.apps.portfoliohierarchy.PortfolioHierarchyApp', {
	extend: 'IntelRallyApp',
	appName: 'Portfolio Hierarchy',
	mixins: [
		'Rally.Messageable',
		'PrettyAlert',
		'ReleaseQuery'
	],
	
	_prefName: 'intel-PortfolioNav',
	_uid: (__PROJECT_OID__ + '-' + __USER_OID__),
	
	layout: {
		type:'vbox',
		align:'stretch',
		pack:'start'
	},
	items:[{
		xtype:'container',
		itemId:'header_release',
		layout:'hbox'
	},{
		xtype:'container',
		itemId:'header_project',
		layout:'hbox'
	},{
		xtype:'container',
		itemId:'header_complete',
		layout:'hbox'
	},{
		xtype:'container',
		itemId:'bodyContainer'
	}],

	config: {
		defaultSettings: (function(){
			var s = {}, str = (__PROJECT_OID__ + '-' + __USER_OID__);
			s['Type' + str] = 'product';
			s['QueryFilter' + str] = '';
			s['InferPortfolioLocation' + str] = true;
			s['PortfolioLocation' + str] = __PROJECT_OID__;
			return s;
		}())
	},
			
	getSettingsFields: function() {
		var str = (__PROJECT_OID__ + '-' + __USER_OID__);
    return [{
			name: 'Type' + str,
			xtype:'combo',
			editable:false,
			label: 'Type',
			store: ['product', 'milestone', 'feature'],
			labelWidth: 120, width:'100%'
		},{
			name: 'QueryFilter' + str,
			xtype: 'textfield',
			label: 'Query Filter',
			labelWidth: 120, width:'100%'
		},{
			name: 'InferPortfolioLocation' + str,
			xtype:'rallycheckboxfield',
			label: 'Infer Portfolio Location',
			labelWidth: 120, width:'100%',
			bubbleEvents: ['change'] 
		},{
			name: 'PortfolioLocation' + str,
			xtype:'intelPIprojectcombo',
			label: 'Portfolio Location',
			labelWidth: 120, width:'100%',
			listeners:{
				added: function(field, form){
					if(form.down('rallycheckboxfield').value) field.hide();
					else field.show();
				}
			},
			handlesEvents: {
				change: function(checkbox, ischecked) {
					if(ischecked) this.hide();
					else this.show();
				}
			}
		}];
	},

	/************************************************** Preferences FUNCTIONS ***************************************************/
	
	_loadPreferences: function(){ //parse all settings too
		var me=this,
			uid = me.getContext().getUser().ObjectID,
			deferred = Q.defer();
		Rally.data.PreferenceManager.load({
			appID: me.getAppId(),
      filterByName: me._prefName + uid,
			success: function(prefs) {
				var appPrefs = prefs[me._prefName + uid];
				try{ appPrefs = JSON.parse(appPrefs); }
				catch(e){ appPrefs = { projs:{}};}
				console.log('loaded prefs', appPrefs);
				deferred.resolve(appPrefs);
			},
			failure: deferred.reject
		});
		return deferred.promise;
	},

	_savePreferences: function(prefs){ 
		var me=this, s = {}, 
			uid = me.getContext().getUser().ObjectID,
			deferred = Q.defer();
		prefs = {projs: prefs.projs};
    s[me._prefName + uid] = JSON.stringify(prefs); 
    console.log('saving prefs', prefs);
		Rally.data.PreferenceManager.update({
			appID: this.getAppId(),
			settings: s,
			success: deferred.resolve,
			failure: deferred.reject
		});
		return deferred.promise;
	},
		
	/************************************************** Refreshing Data ***************************************************/
		
	_refreshTree: function() {
		var me=this;
		me.down('#bodyContainer').removeAll();
		me._loadPortfolioTree();
	},
	
	_reloadEverything: function(){
		var me=this;
		me.setLoading(false);
		me._loadFilterOnRelease();
		me._loadReleaseSelector();
		me._loadFilterOnProject();
		me._loadFilterOnComplete();
		me._loadPortfolioTree();
	},
	
	/************************************************** Launch ***************************************************/
	
	launch: function() {
		var me=this;
		me.setLoading(true);
		me._loadModels()
			.then(function(){
				var scopeProject = me.getContext().getGlobalContext().getProject();
				return me._loadProject(scopeProject.ObjectID);
			})
			.then(function(scopeProjectRecord){
				me.ProjectRecord = scopeProjectRecord;
				return me._loadRandomUserStory(scopeProjectRecord.data._ref);
			})
			.then(function(userStory){
				me.HasUserStories = !!userStory;
				return me._loadProjectByName('All Releases');
			})
			.then(function(rootProject){
				return me._loadAllChildrenProjects(rootProject);
			})
			.then(function(childProjects){
				me.ChildProjects = childProjects;
				return me._projectInWhichTrain(me.ProjectRecord);
			})
			.fail(function(error){
				if(error !== 'Project not in a train') return Q.reject(error); //its ok if its not in a train			
			})
			.then(function(trainRecord){
				me.TrainRecord = trainRecord;
				return me._loadPreferences();
			})
			.then(function(appPrefs){		
				var pid = me.ProjectRecord.data.ObjectID, 
					prefs = appPrefs.projs[pid] || {};
				me.AppPrefs = appPrefs;
				me.PIType = me.getSetting('Type' + me._uid);
				me.QueryFilter = me.getSetting('QueryFilter' + me._uid);
				me.InferPortfolioLocation = me.getSetting('InferPortfolioLocation' + me._uid);
				me.PortfolioLocation = me.getSetting('PortfolioLocation' + me._uid);
				me.FilterOnRelease = prefs.FilterOnRelease || false;
				me.FilterReleaseName = prefs.FilterReleaseName;
				me.FilterOnProject = prefs.FilterOnProject || false;
				me.FilterOnComplete = prefs.FilterOnComplete || false;
				var name = me.ProjectRecord.data.Name,
					field = (typeof me.PortfolioLocation === 'number') ? 'ObjectID' : 'Name';
				if(me.InferPortfolioLocation){
					if(me.TrainRecord) {
						var piName = me.TrainRecord.data.Name.split(' ART')[0] + ' POWG Portfolios';
						me.PortfolioLocation = _.find(me.ChildProjects, function(p){
							return p.data.Name === piName;
						});	
					}
					else me.PortfolioLocation = me.ProjectRecord;
				}
				else {
					me.PortfolioLocation = _.find(me.ChildProjects, function(p){ 
						return p.data[field] === me.PortfolioLocation;
					});
				}
				return me._loadAllReleases(me.ProjectRecord);
			})
			.then(function(releaseStore){		
				me.ReleaseStore = releaseStore;
				me.ReleaseNames = [];
				var recs = releaseStore.data.items;
				for(var i=0,len=recs.length; i<len; ++i){
					me.ReleaseNames.push({ Name: recs[i].data.Name });
				}
				me.FilterReleaseName = me.FilterReleaseName || me.ReleaseNames[0].Name;
				me._reloadEverything();
			})
			.fail(function(reason){
				me.setLoading(false);
				me._alert('ERROR', reason || '');
			})
			.done();
	},

	/******************************************************** HEADER ITEMS *********************************************/
	
	_onPreferenceChanged: function(field, newValue){
		var me=this,
			pid = me.ProjectRecord.data.ObjectID;
		if(me[field] === newValue) return;
		else me[field] = newValue;
		if(typeof me.AppPrefs.projs[pid] !== 'object') me.AppPrefs.projs[pid] = {};
		me.AppPrefs.projs[pid][field] = newValue;
		return me._savePreferences(me.AppPrefs);
	},

	_onReleaseSelected: function(combo, records) {
		var me=this;
		me._onPreferenceChanged('FilterReleaseName', records[0].data.Name)
			.then(function(){ if(me.FilterOnRelease) me._refreshTree(); })
			.fail(function(reason){ me._alert('ERROR:', reason); })
			.done();
	},
				
	_loadReleaseSelector: function(){
		var me=this;
		me.down('#header_release').add({
			xtype:'intelfixedcombo',
			store: Ext.create('Ext.data.Store', {
				fields: ['Name'],
				sorters: [function(o1, o2){ return o1.data.Name < o2.data.Name ? -1 : 1; }],
				data: me.ReleaseNames
			}),
			hidden: !me.FilterOnRelease,
			displayField: 'Name',
			value: me.FilterReleaseName,
			listeners: {
				select: me._onReleaseSelected.bind(me)
			}
		});
	},
		
	_onFilterOnReleaseChanged: function(checkBox) {
		var me=this,
			value = checkBox.getValue(),
			box = me.down('#header_release').down('intelfixedcombo');
		if(value) box.show(); else box.hide();
		me._onPreferenceChanged('FilterOnRelease', value)
			.then(function(){ me._refreshTree(); })
			.fail(function(reason){ me._alert('ERROR:', reason); })
			.done();
	},

	_loadFilterOnRelease: function(){
		var me=this;
		me.down('#header_release').add({
			xtype: 'rallycheckboxfield',
			boxLabel: 'Filter Features in Release',
			padding:'0 4px 0 0',
			value: me.FilterOnRelease,
			listeners: {
				change: me._onFilterOnReleaseChanged.bind(me)
			}
		});
	},	
	
	_onFilterOnProjectChanged: function(checkBox) {
		var me=this;
		me._onPreferenceChanged('FilterOnProject', checkBox.getValue())
			.then(function(){ me._refreshTree(); })
			.fail(function(reason){ me._alert('ERROR:', reason); })
			.done();
	},

	_loadFilterOnProject: function(){
		var me=this;
		me.down('#header_project').add({
			xtype: 'rallycheckboxfield',
			boxLabel: 'Filter User Stories in Current Project',
			padding:'0 4px 0 0',
			hidden: !me.HasUserStories,
			value: me.FilterOnProject,
			listeners: {
				change: me._onFilterOnProjectChanged.bind(me)
			}
		});
	},	
		
	_onFilterOnCompleteChanged: function(checkBox) {
		var me=this;
		me._onPreferenceChanged('FilterOnComplete', checkBox.getValue())
			.then(function(){ me._refreshTree(); })
			.fail(function(reason){ me._alert('ERROR:', reason); })
			.done();
	},

	_loadFilterOnComplete: function(){
		var me=this;
		me.down('#header_complete').add({
			xtype: 'rallycheckboxfield',
			boxLabel: 'Hide Completed Items',
			labelWidth: 170,
			value: me.FilterOnComplete,
			listeners: {
				change: me._onFilterOnCompleteChanged.bind(me)
			}
		});
	},

	/******************************************************** GRID ITEMS *********************************************/

	_onTreeItemSelected: function(treeItem) {
		if(treeItem.xtype === 'fittedportfolioitemtreeitem'){
			this.publish('portfoliotreeitemselected', treeItem);
		}
	},
	
	_getFilterOnCompleteFilter: function(ordinal){
		return Ext.create('Rally.data.wsapi.Filter', {
			property:'State.OrderIndex',
			operator:'<',
			value: (ordinal === 0 ? 11 : 4) //finished features are 11-15, milestone/products are 4
		}).or(Ext.create('Rally.data.wsapi.Filter', {
			property:'State',
			value: null
		}));
	},
	
	_getFilterOnReleaseFilter: function(){
		var me=this;
		return Ext.create('Rally.data.wsapi.Filter', {
			property: 'Release.Name',
			value: me.FilterReleaseName 
		});
	},
	
	_getFilterOnQueryFilter: function(){
		var me=this;
		try { return Rally.data.QueryFilter.fromQueryString(me.QueryFilter); }
		catch(e){ 
			return Ext.create('Rally.data.wsapi.Filter', {
				property: 'ObjectID',
				operator: '!=',
				value: 0
			});
		}
	},
	
	_getParentRecordFilter: function(parentRecord, ordinal){
		return Ext.create('Rally.data.wsapi.Filter', {
			property: (ordinal === 0 ? 'Feature' : 'Parent') + '.ObjectID', //only uses right under feature have issue
			value: parentRecord.data.ObjectID
		});
	},
	
	_getTopLevelStoreConfig: function(ordinal){ 
		var me=this, 
			filters = [];
		if(me.FilterOnComplete) filters.push(me._getFilterOnCompleteFilter(ordinal));
		if(me.FilterOnRelease && ordinal === 0) filters.push(me._getFilterOnReleaseFilter());
		if(me.QueryFilter) filters.push(me._getFilterOnQueryFilter());
		return {
			limit:Infinity,
			filters: filters,
			context: {
				project: me.PortfolioLocation.data._ref,
				projectScopeDown: true,
				projectScopeUp: false
			}
		};
	},

	_getChildLevelStoreConfig: function(tree, parentRecord, isPI, ordinal){ //ordinal/isPI of PARENT item
		var me=this,
			context= {
				project: me.PortfolioLocation.data._ref,
				projectScopeDown: true,
				projectScopeUp: false
			},
			filters = [ me._getParentRecordFilter(parentRecord, ordinal)];
		if(me.FilterOnComplete && isPI && ordinal > 0) filters.push(me._getFilterOnCompleteFilter(ordinal));
		if(!isPI || ordinal === 0) {
			if(me.FilterOnProject){
				context.project = me.ProjectRecord.data._ref;
				context.projectScopeDown = false;
			}
			else {
				context.project = undefined;
				context.projectScopeDown = undefined;
			}
		} 
		if(me.FilterOnRelease && isPI && ordinal === 1) filters.push(me._getFilterOnReleaseFilter());
		if(me.QueryFilter) filters.push(me._getFilterOnQueryFilter());
		return {
			limit:Infinity,
			fetch: tree._getDefaultTopLevelFetchFields().concat(['Parent', 'Project', 'State']),
			context: context,
			filters:filters
		};
	},
	
	_loadPortfolioTree: function(){
		var me = this,
			modelName ='portfolioitem/' + me.PIType,
			ordinal = (me.PIType==='product' ? 2 : (me.PIType==='milestone' ? 1 : 0));

		me.down('#bodyContainer').add({
			xtype: 'rallyportfoliotree',
			stateful: true,
			stateId: me.getAppId() + 'rallyportfoliotree',
			topLevelModel: modelName,
			topLevelStoreConfig: me._getTopLevelStoreConfig(ordinal),
			listeners: {
				itemselected: me._onTreeItemSelected.bind(me)
			},
			childItemsStoreConfigForParentRecordFn: function(parentRecord) {
				var tree = this,
					isPI = tree._isPortfolioItem(parentRecord),
					ordinal = parentRecord.self.ordinal;
				return me._getChildLevelStoreConfig(tree, parentRecord, isPI, ordinal);
			},
			treeItemConfigForRecordFn: function (record) {
				var tree = this,
					config = Rally.ui.tree.PortfolioTree.prototype.treeItemConfigForRecordFn.call(tree, record);
				if(tree._isPortfolioItem(record)) config.xtype = 'fittedportfolioitemtreeitem'; 
				else config.xtype = 'fitteduserstorytreeitem'; 
				return config;
			}
		});
	}
});


            Rally.launchApp('Rally.apps.portfoliohierarchy.PortfolioHierarchyApp', {
                name:"Portfolio Hierarchy",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .portfolio-hierarchy-app {
  width: 100% !important;
}
.portfolio-hierarchy-app .rallytree {
  padding-top: 5px;
  padding-bottom: 20px;
}
.portfolio-hierarchy-app .header {
  border-bottom: 1px dotted #c6c6c6;
}
.portfolio-hierarchy-app .filterInfo {
  float: right;
  padding-right: 1px;
  border-right: 1px solid #CCC;
  margin-right: 5px;
  margin-top: 2px;
  margin-bottom: 2px;
}
.portfolio-hierarchy-app .rally-help-icon {
  float: right;
}
.portfolio-hierarchy-app .current-project-only-float {
  float: left;
}
.portfolio-hierarchy-app .filter-on-release-float {
  float: left;
  margin-left: 10px;
  margin-right: 8px;
}

    </style>
</head>
<body>
</body>
</html>
