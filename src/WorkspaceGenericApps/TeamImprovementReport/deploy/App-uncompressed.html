<!DOCTYPE html>
<html>
<head>
    <title>Continuous Improvement Report</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.js"></script>
    <script type="text/javascript" src="https://code.highcharts.com/highcharts.src.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/sprintf/1.0.1/sprintf.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** 
	SUMMARY:
		This extends Rally.app.app. All Intel Apps should extend from this if they want to use the functionality it provides,
		as well as numerous other lib/* files that require you to extend from this.
		
		If you extend from Intel.lib.IntelRallyApp, you have to call me.configureIntelRallyApp() before anything else in your launch() 
		function. After you call me.configureIntelRallyApp, you will be able to access a lot of things, such as:
			- me.ScheduleStates: possible UserStory schedule States
			- me.PortfolioItemTypes: Ordered Array of PortfolioItem Types. e.g.: ['Feature', 'Milestone', 'Product']
			- me.ScrumGroupConfig: the scrum group portfolio location config for the workspace
			- All the most-used Rally models, such as me.Project, me.UserStory, me.PortfolioItem, etc... 
		
	DEPENDENCIES:
		Q promise library
		
	ISSUES:
		sdk 2.0 does not work with the project function due to a bug in the sdk.
	*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		ScrumGroupConfigPrefName = 'intel-portfolio-locations-config'; //preference to store portfolio locations config for workspace
	
	//increase timeouts to 2 minutes since rally can be slow sometimes
	var timeout = 120000;
	Ext.override(Ext.data.proxy.Ajax, { timeout: timeout });
	Ext.override(Ext.data.proxy.JsonP, { timeout: timeout });
	
	//rally's built-in jsonpproxy does not handle timeouts
	Ext.override(Rally.sdk.data.lookback.JsonPProxy, {
		setException: function(operation, response){
			var error = operation.getError() || {};
			operation.setException(Ext.apply(error, {
				errors:(response || {}).Errors || []
			}));
		}
	});
				
	Ext.define('Intel.lib.IntelRallyApp', {
		extend: 'Rally.app.App',
		minWidth:910, //when Rally adds its own scrollbar anyways
		
		projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
		portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'Release','c_TeamCommits', 'c_MoSCoW', 
			'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal'],
		userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
			'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
		releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
		
		/********************************************** APP CONFIGURATION **************************************/
		_loadScheduleStates: function(){ 
			var me=this, deferred = Q.defer();
			Rally.data.ModelFactory.getModel({
				type: 'UserStory',
				success: function(model) {
					model.getField('ScheduleState').getAllowedValueStore().load({
						callback: function(records, operation, success) {
							me.ScheduleStates = _.map(records, function(r){ return r.data.StringValue; });
							deferred.resolve();
						}
					});
				}
			});
			return deferred.promise;
		},
		_loadPortfolioItemStatesForEachType: function(){ 
			var me=this;
			me.PortfolioItemTypeStates = [];
			return Q.all(_.map(me.PortfolioItemTypes, function(portfolioType, ordinal){
				var store = Ext.create('Rally.data.wsapi.Store', {
					model: 'State',
					autoLoad:false,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Name', 'Enabled', 'OrderIndex'],
					filters: [{
						property: 'TypeDef.Name',
						value: portfolioType
					},{
						property: 'Enabled',
						value: true
					}]
				});
				return me.reloadStore(store).then(function(store){
					me.PortfolioItemTypeStates[ordinal] = store.getRange();
				});
			}));
		},
		_loadPortfolioItemTypes: function(){ 
			/** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
			var me=this,
				deferred = Q.defer(),
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'TypeDefinition',
					autoLoad:true,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					listeners:{
						load:function(portfolioTypeStore){
							me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(), 
								function(item){ return {Name: item.data.Name, Ordinal: item.data.Ordinal}; }),
								function(item){ return item.Ordinal; }),
								function(item){ return item.Name; });
							deferred.resolve();
						}
					}
				});
			return deferred.promise;
		},
		_loadModels: function(){ 
			/** loads models for project, userstories, and all the portfolio items */
			var me=this, 
				promises = [],
				models = {
					User: 'User',
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					PortfolioItem: 'PortfolioItem'
				};
			_.each(me.PortfolioItemTypes, function(name){ models['PortfolioItem/' + name] = 'PortfolioItem/' + name; });
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},
		_loadScrumGroupConfig: function(){
			/** scrum-groups are groups of scrums that share the same portfolio. The group of scrums may or may not be a train */
			/** me.ScrumGroupConfig is an array of these objects: 
				{
					ScrumGroupRootProjectOID: configItem.ScrumGroupRootProjectOID || 0,
					ScrumGroupName: configItem.ScrumGroupName || '',
					ScrumGroupAndPortfolioLocationTheSame: configItem.ScrumGroupAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0,
					IsTrain: configItem.IsTrain ? true : false
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: ScrumGroupConfigPrefName,
				success: function(prefs) {
					var configString = prefs[ScrumGroupConfigPrefName], scrumGroupConfig;
					try{ scrumGroupConfig = JSON.parse(configString); }
					catch(e){ scrumGroupConfig = []; }
					me.ScrumGroupConfig = scrumGroupConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveScrumGroupConfig: function(scrumGroupConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[ScrumGroupConfigPrefName] = JSON.stringify(scrumGroupConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: ScrumGroupConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		configureIntelRallyApp: function(){
			var me=this;
			me.BaseUrl = Rally.environment.getServer().getBaseUrl(); //is "" when in custom app iframe
			return Q.all([
				me._loadPortfolioItemTypes().then(function(){ 
				//HOLY PROGRAM BOARD BUG, BATMAN! (me._isUserStoryInRelease false for those who: (release == null && portfolioItrem.release.name == me.ReleaseRecord.data.Name)).
					me.userStoryFields.push(me.PortfolioItemTypes[0]);  
					return Q.all([
						me._loadModels(),
						me._loadPortfolioItemStatesForEachType()
					]);
				}),
				me._loadScrumGroupConfig(),
				me._loadScheduleStates()
			]);
		},
				
		/**************************** Generic store loading with Q wrapper, returns promise *************************************/		
		reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		},
		
		/********************************************** LOADING SINGLE MODELS **************************************/	
		loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: loadProject');
			else if(!me.Project) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.Project.load(oid, {
					fetch: me.projectFields,
					context: { 
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadUserStory: function(oid, projectRecord){
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LUS');
			else if(!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.UserStory.load(oid, {
					fetch: me.userStoryFields,
					context: {
						workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
						project: projectRecord ? projectRecord.data._ref : null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadPortfolioItemByType: function(oid, type){
			var me = this, deferred = Q.defer();
			if(!oid || !type) return Q.reject('Invalid arguments: LPIBT');
			else {
				type = (type.indexOf('PortfolioItem/') === 0) ? type : ('PortfolioItem/' + type);	
				me[type].load(oid, {
					fetch: me.portfolioItemFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadPortfolioItemByOrdinal: function(oid, ordinal){
			var me = this, deferred = Q.defer(),
				type = me.PortfolioItemTypes[ordinal];
			return me.loadPortfolioItemByType(oid, type);
		},	
		
		/**************************************** ScrumGroup Funcs ***************************************************/
		projectInWhichScrumGroup: function(projectRecord){ 
			/** returns scrumgroup the projectRecord is in, otherwise null. */
			if(!projectRecord) return Q();
			else {
				var me=this,
					foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
						return scrumGroupConfig.ScrumGroupRootProjectOID == projectRecord.data.ObjectID; 
					});
				if(foundScrumGroupConfig) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q();
					else {
						return me.loadProject(parent.ObjectID).then(function(parentRecord){
							return me.projectInWhichScrumGroup(parentRecord);
						});
					}
				}
			}
		},
		loadScrumGroupPortfolioProject: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) return Q.reject('Invalid arguments: _loadScrumGroupPortfolioProject');
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) return Q.reject('Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum group!');
			if(foundScrumGroupConfig.ScrumGroupAndPortfolioLocationTheSame) return Q(scrumGroupRootProjectRecord);
			else return me.loadProject(foundScrumGroupConfig.PortfolioProjectOID);
		},
		getScrumGroupName: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) throw 'Invalid arguments: _getScrumGroupName';
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) throw 'Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum-group!';
			if(foundScrumGroupConfig.ScrumGroupName) return foundScrumGroupConfig.ScrumGroupName;
			else return scrumGroupRootProjectRecord.data.Name;
		},
		loadAllScrumGroups: function(){
			var me=this,
				filter = _.reduce(me.ScrumGroupConfig, function(filter, scrumGroupConfig){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', { property:'ObjectID', value: scrumGroupConfig.ScrumGroupRootProjectOID });
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			if(!filter) return Q([]);
			else {
				var store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.projectFields,
					filters:[filter],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
				return me.reloadStore(store).then(function(store){ return store.getRange(); });
			}
		},
		getScrumGroupPortfolioObjectIDs: function(){
			return _.map(me.ScrumGroupConfig, function(item){
				return item.ScrumGroupAndPortfolioLocationTheSame ? item.ScrumGroupRootProjectOID : item.PortfolioProjectOID;
			});
		},
		getPortfolioOIDForScrumGroupRootProjectRecord: function(scrumGroupRootProjectRecord){
			var configItem = _.find(this.ScrumGroupConfig, function(item){ 
				return item.ScrumGroupRootProjectOID === scrumGroupRootProjectRecord.data.ObjectID; 
			});
			return configItem.ScrumGroupAndPortfolioLocationTheSame ? configItem.ScrumGroupRootProjectOID : configItem.PortfolioProjectOID;
		},
		
		/**************************************** UserStory Funcs ************************************************/
		_getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ 
			/** only pull look at PortfolioItem Release if US.Release == null */
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property: lowestPortfolioItem + '.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property: lowestPortfolioItem + '.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		loadRandomUserStory: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: LRUS');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: false,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{ 
						property:'Project.ObjectID', 
						value: projectRecord.data.ObjectID 
					}]
				});
			return me.reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		loadRandomUserStoryFromReleaseTimeframe: function(projectRecord, releaseRecord){
			if(!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: LRUSFR');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					disableMetaChangeEvent: true,
					fetch: me.userStoryFields,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project.ObjectID', value: projectRecord.data.ObjectID }).and(
						me._getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me.reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		loadUserStoryByFID: function(formattedID, projectRecord){
			if(!formattedID || !projectRecord) return Q.reject('Invalid arguments: LUSBFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}]
				});
			return me.reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		
		/**************************************** PortfolioItem Funcs ************************************************/
		loadPortfolioItemsOfType: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: OPIOT');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					disableMetaChangeEvent: true,
					remoteSort:false,
					fetch: me.portfolioItemFields,
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me.reloadStore(store);
		},		
		loadPortfolioItemsOfOrdinal: function(portfolioProject, ordinal){
			if(!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: LPIOO');
			var me=this, type = me.PortfolioItemTypes[ordinal];
			if(type) return me.loadPortfolioItemsOfType(portfolioProject, type);
			else return Q.reject('Invalid PortfolioItem ordinal');
		},
		portfolioItemTypeToOrdinal: function(type){
			return this.PortfolioItemTypes.indexOf(type);
		},
		getPortfolioItemTypeStateByOrdinal: function(ordinal, stateName){
			return _.find(this.PortfolioItemTypeStates[ordinal], function(state){ return state.data.Name == stateName; });
		},
		getPortfolioItemTypeStateByName: function(portfolioType, stateName){
			return this.getPortfolioItemTypeStateByOrdinal(this.portfolioItemTypeToOrdinal(portfolioType), stateName);
		},
		
		/********************************************** Project Funcs ********************************************/
		/****************************** THESE DO NOT WORK WITH sdk 2.0. USE SDK 2.0rc3 *******************/
		_storeItemsToProjTree: function(projects){
			var me=this, projTree = {};
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			return projTree;
		},
		_addProjectsWithTeamMembersToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
			}
		},	
		_allChildProjectToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_allLeafProjectsToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		loadAllProjects: function(){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				var map = _.reduce(store.getRange(), function(map, project){
					map[project.data.ObjectID] = project;
					return map;
				}, {});
				return map;
			});	
		},
		loadProjectsWithTeamMembers: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				projectsWithTeamMembers = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
					return projectsWithTeamMembers;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.TeamMembers.Count > 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},	
		loadAllChildrenProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				childrenProjects = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
					return childrenProjects;
				} else {
					return _.reduce(store.getRange(), function(map, project){
						map[project.data.ObjectID] = project;
						return map;
					}, {});
				}
			});
		},	
		loadAllLeafProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				leafProjects = {}, 
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
					return leafProjects;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.Children.Count === 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},
		loadProjectByName: function(projectName){
			if(!projectName) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [{
						property:'Name',
						value:projectName
					}]
				});
			return me.reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** Release loading ********************************************/	
		loadAllReleases: function(projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesBeforeGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					disableMetaChangeEvent: true,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'<=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesBetweenDates: function(projectRecord, startDate, endDate){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit: Infinity,
					autoLoad:false,
					fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					},{
						property:'ReleaseDate',
						operator:'>',
						value: new Date(startDate).toISOString()
					},{
						property:'ReleaseStartDate',
						operator:'<',
						value: new Date(endDate).toISOString()
					}]
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesInTheFuture: function(projectRecord){
			return this.loadReleasesAfterGivenDate(projectRecord, new Date());
		},
		loadReleasesByNameUnderProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					}],
					context:{
						project:projectRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		loadReleaseByNameForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						operator:'contains',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		getScopedRelease: function(releaseRecords, projectOID, appPrefs){			
			/** gets the most likely release to scope to base on the following order:
				1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
								to use preferences for this one)
				2) if we are currently in one of the releases
				3) the closest release planning date to the current date
			*/
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate)*1, d2 = new Date(r.data.ReleaseStartDate)*1, now = new Date()*1;
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());
                /** 
	SUMMARY:
		This mixin is used if you want to listen to events in the parent window (e.g. useful for rally apps that 
		resize with browser screen vertically or things that need to know browser scroll position) 
		You also can artificially fire the events and have the listeners run using fireParentWindowEvent
*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		windowListeners = {};

	Ext.define('Intel.lib.mixin.WindowListener', {

		_initWindowEventListener: function(eventName){
			if(!windowListeners) windowListeners = {};
			windowListeners[eventName] = [];
			
			window.parent['on' + eventName] = function(event){ 
				var listeners = windowListeners[eventName];
				for(var i=0, len=listeners.length; i<len; ++i)
					listeners[i](event);
			};
		},
		
		/** eventName is something like: resize, scroll, etc... */
		addWindowEventListener: function(eventName, fn){
			if(!windowListeners || !windowListeners[eventName]) 
				this._initWindowEventListener(eventName);
			windowListeners[eventName].push(fn);
		},
		
		/** eventName is something like: resize, scroll, etc... */
		fireParentWindowEvent: function(eventName){
			var me=this;
			if(!windowListeners || !windowListeners[eventName]) return;
			var listeners = windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
		}
	});
}());
                /** 
	SUMMARY:
		this mixin is used to mess with the environment outside of the iframe that the rally app is put in. 
		
	DEPENDENCIES:
		'Intel.lib.mixin.WindowListener' mixed in to app so listen for window events
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	var TOP_BAR_HEIGHT = 40,
		BOTTOM_BAR_HEIGHT = 24,
		BOTTOM_IFRAME_PADDING = 20,
		TITLE_BAR_HEIGHT = 33,
		IFRAME_HEADER_HEIGHT = 28;
		
	Ext.define('Intel.lib.mixin.IframeResize', {
		requires: ['Intel.lib.mixin.WindowListener'],
		
		/**
			makes app as large as screen, without the padding/margin. 
			Makes it look more like a built-in rally app instead of a custom app.
			NOTE: as rally changes their interface overtime, this mixin will have to change as well to compensate for it.
		*/
		_fixRallyDashboard: function(){ 
			if(window && window.frameElement){
				var me=this,
					bottomEl = Ext.get(window.frameElement),
					portlet = bottomEl.up('.x-portlet'), 
					dashboard = portlet.up('#mydash_portlet'), //has huge padding values
					titleBar = dashboard.down('.titlebar'), //redundant with app header bar
					domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
					innerHeight = window.parent.innerHeight,
					innerWidth = window.parent.innerWidth;
				
				//adjust widths
				while(true){
					domNodeW.style.width = (innerWidth - 4) + 'px';
					domNodeW.style.padding = '0';
					domNodeW.style.margin = '0';
					if(domNodeW.id === 'mydash_portlet') break;
					domNodeW = domNodeW.parentNode;
				}
				
				//adjust heights
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT + IFRAME_HEADER_HEIGHT + BOTTOM_IFRAME_PADDING)) + 'px';
					if(domNodeH.classList.contains('x-portlet')) break;
					domNodeH = domNodeH.parentNode;
				}
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT)) + 'px';
					if(domNodeH.id == 'mydash_portlet') break;
					domNodeH = domNodeH.parentNode;
				}
				dashboard.dom.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT)) + 'px';
				
				//final touches LOL
				dashboard.dom.style.padding = "0 2px 0 2px";
				titleBar.dom.style.padding = "2px";
				titleBar.dom.style.margin = "0";
			}
		},		
		initFixRallyDashboard: function(){ 
			var me=this;
			if(me.addWindowEventListener){
				me.addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
			}
			me._fixRallyDashboard();
		},

		/** 
			hides the draggable resize handle from under the app 
		*/
		_disableResizeHandle: function(){ 
			var me=this, handle;
			if(window && window.frameElement){
				handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
				if(handle) {
					handle.hide();
					handle.dom.onshow = function(){ if(handle) handle.hide(); };
				}
			}
		},	
		initDisableResizeHandle: function(){
			var me=this;
			if(me.addWindowEventListener){
				me.addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
			}
			me._disableResizeHandle();
		}
	});
}());
                /**  
	DESCRIPTION:
		This mixin gives a window-centered alert or confirm dialog box that isn't ugly. 
		
	ISSUES:
		Sometimes alert.setY() fails so we have to fallback to the ugly built-in alert
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.mixin.PrettyAlert', {	
		_getMessageBoxY: function(){ 
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.frameElement ? window.parent.getWindowHeight() : window.innerHeight,
				ps = window.frameElement ? window.parent.getScrollY() : window.scrollY,
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},
		
		_formatString: function(message){
			message = message || '';
			return (typeof message === 'string') ? 
				message : (message.message ? 
				message.message : JSON.stringify(message, null, '\t'));
		},

		/** non-ugly alert dialog */
		alert: function(title, message){
			if(arguments.length<1) return;
			if(arguments.length===1){
				message = title;
				title = '';
			}
			
			try {
				Ext.MessageBox.alert(this._formatString(title), this._formatString(message)).setY(this._getMessageBoxY());
				setTimeout(function(){
					var x = Ext.MessageBox.down('button');
					while(x.isHidden()) x = x.nextSibling();
					x.focus();
				}, 50);
			}
			catch(e){ alert(this._formatString(message)); }
		},
		
		/** non-ugly confirm dialog */
		confirm: function(title, message, fn){
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = message;
				message = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			
			try {
				Ext.MessageBox.confirm(this._formatString(title), this._formatString(message), fn).setY(this._getMessageBoxY());
				setTimeout(function(){
					var x = Ext.MessageBox.down('button');
					while(x.isHidden()) x = x.nextSibling();
					x.focus();
				}, 50);
			}
			catch(e){ if(confirm(this._formatString(message))) fn('yes'); else fn('no'); }
		}
	});
}());
                (function() {
	var Ext = window.Ext4 || window.Ext;
	
	var teamTypes = [
		'Analog DV', 'Array', 'BI', 'Binsplit',
		'Class TPI', 'CLK', 'EVG','Func Module',
		'Fuse', 'GT Module', 'HTD', 'MIO', 'MIO CLK',
		'MPV', 'PT', 'QRE Qual', 'Reliability', 'Scan',
		'SIO', 'SIO MIO CLK', 'Sort Class TPI', 'Sort TD',
		'Sort TPI', 'TVPV', 'Yield PHI'
	],
		// In English: matches a team type, maybe a number, a hyphen, a train name, and maybe a suffixed parenthetical
		// Remembers the team type, associated keywords, the number or '', and the train name
		// TODO: Fix this and make this faster
		teamInfoRegExp = /^([A-Za-z\s\-]*[A-Za-z])\s+(?:\([A-Za-z\d\s]+\))?\s*(\d*)\s*-\s+([A-Za-z\s]*[A-Za-z]).*$/,
		teamRegExp = /^[A-Za-z ]*[A-Za-z](?:\s\d)?\s-\s.+$/,
		keywordSplitRegExp = /[\s\-]+/;
	
	Ext.define('Intel.lib.mixin.Teams', {
		getTeamInfo: function(project) {
			var results = teamInfoRegExp.exec(project.data.Name),
				team = {};
			if (!results) {
				return null;
			}
			team.FullName = project.data.Name;
			team.Type = results[1];
			team.KeyWords = results[1].split(keywordSplitRegExp).concat('');
			team.Number = (results[2] !== '' ? parseInt(results[2], 10) : 1);
			team.Train = results[3];
			team.Name = team.Type + ' ' + team.Number;
			return team;
		},
		
		createTeamInfoMap: function(teams) {
			var me = this,
				map = {},
				team;
			for (var i in teams) {
				map[teams[i].data.ObjectID] = {
					project: teams[i],
					info: me.getTeamInfo(teams[i])
				};
			}
			return map;
		},
		
		isValidTeamProjectName: function(project) {
			return teamRegExp.test(project.data.Name) && project.data.Children.Count === 0;
		},
		
		isValidTeamType: function(type) {
			return _.includes(teamTypes, type);
		},
		
		filterProjectsByTeamType: function(projects, type) {
			var me = this,
				filter = new RegExp((!type || type === '' || type === 'All') ? '.*' : type),
				filteredProjects = {};
			for (var i in projects) {
				if (filter.test(projects[i].data.Name)) {
					filteredProjects[projects[i].data.ObjectID] = projects[i];
				}
			}
			return filteredProjects;
		},
		
		filterMapByTeamType: function(map, type) {
			var me = this,
				filter = new RegExp((!type || type === '' || type === 'All') ? '.*' : type),
				filteredProjects = {};
			for (var i in map) {
				if (filter.test(map[i].project.data.Name)) {
					filteredProjects[map[i].project.data.ObjectID] = map[i].project;
				}
			}
			return filteredProjects;
		}
	});
})();
                /** 
	SUMMARY:
		This combo has some built in defaults for static-comboboxes (which means you dont type into it, you just select from it)
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.FixedComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
		
		editable: false,	
		allowBlank:true,
		queryMode:'local',
		matchFieldWidth: false,
		listeners: {
			change:function(combo, newval, oldval){ 
				if(newval.length===0) combo.setValue(oldval || ''); 
			},
			focus: function(combo) {
				if(combo.store.findExact(combo.valueField, combo.getValue()) === -1) combo.setValue('');
				combo.expand();
			}
		}
	});
}());
                /** 
	SUMMARY:
		This component is an easy release picker based off Intel.lib.component.FixedComboBox. You supply the 
		Release Records to it on construction.
		
		YOU MUST PASS IT 2 THINGS IN THE CONFIG
			1: releases (array of release records)
			2: currentRelease (what to show as initial value
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.ReleasePicker', {
		extend: 'Intel.lib.component.FixedComboBox',
		alias: ['widget.intelreleasepicker'],
		
		constructor: function(options){
			if(!options.releases || !options.currentRelease) return;
			
			options.displayField = 'Name';
			options.value = options.currentRelease.data.Name;
			options.store = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(options.releases, function(r){ return {Name: r.data.Name }; })
			});
			
			options.fieldLabel = options.fieldLabel || 'Release:';
			options.editable = options.editable || false;
			options.width = options.width || 240;
			options.labelWidth = options.labelWidth || 50;
			
			this.callParent([options]); //now that we have the extra stuff added
		}
	});
}());
                (function() {
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('ContinuousImprovementReport', {
		extend: 'Intel.lib.IntelRallyApp',
		componentCls: 'app',
		mixins:[
			'Intel.lib.mixin.WindowListener',
			'Intel.lib.mixin.PrettyAlert',
			'Intel.lib.mixin.IframeResize',
			'Intel.lib.mixin.Teams'
		],
		items: [
			{
				xtype: 'container',
				id: 'controls-container',
				layout: 'column',
				border: 1,
				style: {
					borderColor: 'black',
					borderStyle: 'solid'
				},
				items: [
					{
						xtype: 'container',
						id: 'general-controls-container',
						columnWidth: 0.14
					},
					{
						xtype: 'container',
						id: 'backlog-chart-controls-container',
						columnWidth: 0.84,
						layout: 'hbox'
					},
					{
						xtype: 'button',
						id: 'create-story-button',
						text: '+',
						style: {
							float: 'right'
						},
						listeners: {
							click: function() {
								// TODO: Add default values or change to custom form
								Rally.nav.Manager.create('HierarchicalRequirement');
							}
						}
					}
				]
			},
			{
				xtype: 'container',
				id: 'chart-and-grid-container',
				layout: 'column',
				items: [
					{
						xtype: 'container',
						id: 'chart-container',
						columnWidth: 0.5,
						padding: '0 10 0 0',
						items: [
							{
								xtype: 'container',
								id: 'backlog-chart-container'
							},
							{
								xtype: 'container',
								id: 'pie-chart-container',
								layout: 'column',
								items: [
									{
										xtype: 'container',
										id: 'state-chart-container',
										columnWidth: 0.5
									},
									{
										xtype: 'container',
										id: 'percentage-chart-container',
										columnWidth: 0.5
									}
								]
							}
						]
					},
					{
						xtype: 'container',
						id: 'grid-container',
						padding: '0 5 0 0',
						columnWidth: 0.49
					}
				]
			}
		],
		/**************************************** Launch ******************************************/
		launch: function() {
			var me = this;
			me.initDisableResizeHandle();
			me.initFixRallyDashboard();
			me.setLoading('Loading configuration');
			me.configureIntelRallyApp()
			// Load scoped project
			.then (function() {
				me.isShowingAllReleases = false;
				var scopedProject = me.getContext().getProject();
				return me.loadProject(scopedProject.ObjectID);
			})
			// Get current release, team info, and load portfolio project
			.then(function(projectRecord) {
				me.ProjectRecord = projectRecord;
			
				// Extract team info from current project
				me.Team = me.getTeamInfo(me.ProjectRecord);
				if (!me.Team) {
					throw 'You must be scoped to a scrum';
				}
				
				// Load release records
				return me._loadReleases();
			})
			// Save current release then load the train portfolio project
			.then(function(release) {
				me.CurrentRelease = release;
				me.FilterRelease = release;
				return me.loadProjectByName(me.Team.Train + ' POWG Portfolios');
			})
			// Get all products under the portfolio project
			.then(function(portfolioProject) {
				me.setLoading('Loading continuous improvement product');
				
				// Load all products
				return me.loadPortfolioItemsOfType(portfolioProject, 'Product');
			})
			// Extract only the continuous improvement product and load milestones under it
			.then(function(productStore) {
				var ciProduct,
					ciProductName = me.Team.Train + 'STDCI';
				
				// Find the continuous improvement product
				ciProduct = _.find(productStore.getRange(), function(p) {return p.data.Name === ciProductName;});
				
				// Load Milestones under the STDCI product
				return me._loadPortfolioChildren(ciProduct, 'Milestone');
			})
			// Load all features then stories under all milestones
			.then(function (milestoneStore) {
				me.Milestones = milestoneStore.getRange();
				return me._loadStories();
			})
			// Load the UI
			.then(me._loadUI.bind(me))
			// Catch-all fail function
			.fail(function(reason) {
				me.setLoading(false);
				me.alert('Error', reason || 'error');
			})
			.done();
		},
		
		/**************************************** Data Loading ************************************/
		/*
		 *	Loads all releases for the project and resolves duplcate releases
		 */
		_loadReleases: function() {
			/*return me.loadAllReleases(me.ProjectRecord).then(function(releaseRecords) {
				me.ReleaseRecords = _.uniq(_.filter(releaseRecords, function(release) {return (/^Q\d{3}/).test(release.data.Name);}), function(release) {return release.data.Name.slice(0,4);});
				return me.getScopedRelease(me.ReleaseRecords, me.ProjectRecord.data.ObjectID, null);
			});*/
			var me = this;
			return me.loadAllReleases(me.ProjectRecord).then(function(releases) {
				var releaseRegExp = /^Q\d{3}$/,
					releaseNameMap = {};
				me.ReleaseRecords = [];
				
				// Filter out non quarterly releases and expand duplicate timeframes
				for (var i in releases) {
					releaseName = releases[i].data.Name.slice(0,4);
					if (releaseRegExp.test(releaseName)) {
						if (releaseNameMap[releaseName]) {
							// Expand the release timescope if necessary
							if (releases[i].data.ReleaseStartDate < releaseNameMap[releaseName].data.ReleaseStartDate) releaseNameMap[releaseName].data.ReleaseStartDate = releases[i].data.ReleaseStartDate;
							if (releases[i].data.ReleaseDate > releaseNameMap[releaseName].data.ReleaseDate) releaseNameMap[releaseName].data.ReleaseDate = releases[i].data.ReleaseDate;
						}
						else {
							// Set the correct name and add it to the map
							releases[i].data.Name = releaseName;
							releaseNameMap[releaseName] = releases[i];
						}
					}
				}
				
				// Push map elements into the array of release records
				for (var j in releaseNameMap) {
					me.ReleaseRecords.push(releaseNameMap[j]);
				}
				
				// Return will be used to set the current release
				return me.getScopedRelease(me.ReleaseRecords, me.ProjectRecord.data.ObjectID, null);
			});
		},
		/*
		 *	Loads direct children of a portfolio item of type
		 *	Filters by customFilter (if provided), a Filter object
		 */
		_loadPortfolioChildren: function(portfolioItem, type) {
			var me = this,
				// Filters to children of portfolioItem
				parentFilter = Ext.create('Rally.data.wsapi.Filter', {property: 'Parent.ObjectID', operator: '=', value: portfolioItem.data.ObjectID}),
				storeConfig = {
					model: me['PortfolioItem/' + type],
					fetch: ['Name', 'ObjectID', 'FormattedID', 'Release'],
					autoLoad: false,
					disableMetaChangeEvent: true,
					limit: Infinity,
					pageSize: 200,
					filters: [parentFilter],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					}
				};
			var store = Ext.create('Rally.data.wsapi.Store', storeConfig);
			
			return me.reloadStore(store);
		},
		
		/*
		 *	Loads stories under features under the CI milestone
		 */
		_loadStories: function() {
			var me = this;
			me.setLoading('Loading stories');
			me.ReleaseFilter = me._getReleaseFilter();
			return me._loadFeaturesUnderMilestones(me.Milestones).then(function(featureStores) {
				return me._loadStoriesUnderFeatures(featureStores);
			});
		},
		
		/*
		 *	Loads all features under the given milestones
		 */
		_loadFeaturesUnderMilestones: function(milestones) {
			var me = this,
				featurePromises = [];

			// Create promise array for features
			for (var i in milestones) {
				featurePromises.push(me._loadPortfolioChildren(milestones[i], 'Feature', me.ReleaseFilter));
			}
			
			return Q.all(featurePromises);
		},
		
		/*
		 *	Loads all stories under the given features
		 */
		_loadStoriesUnderFeatures: function(featureStores) {
			var me = this,
				storyPromises = [];
			me.setLoading('Loading stories');
			
			// Create promise array for loading stories
			for (var i in featureStores) {
				var features = featureStores[i].getRange();
				for (var j in features) {
					storyPromises.push(me._loadStoriesByFeature(features[j]));
				}
			}
			
			// Load stories then aggregate the data into one store
			return Q.all(storyPromises).then(function(storyStores) {
				me.StoryStore = Ext.create('Ext.data.Store', {
					autoLoad: false,
					model: me.UserStory,
					data: []
				});
				for (var i = 0; i < storyStores.length; i++) {
					me.StoryStore.add(storyStores[i].getRange());
				}
				me.StoryStore.sort('CreationDate', 'ASC');
				me.setLoading(false);
			});
		},
		
		/*
		 *	Loads all stories within a feature
		 */
		_loadStoriesByFeature: function(feature) {
			var me = this,
				// Filters to children of feature
				featureFilter = Ext.create('Rally.data.wsapi.Filter', {property: 'Feature.ObjectID', value: feature.data.ObjectID}),
				// Filters to leaf stories
				childrenFilter = Ext.create('Rally.data.wsapi.Filter', {property: 'DirectChildrenCount', value: 0}),
				// Anded filters
				standardFilter = childrenFilter.and(featureFilter.and(me.ReleaseFilter)),
				storeConfig = {
					model: me.UserStory,
					fetch: ['Name', 'ObjectID', 'FormattedID', 'Owner', 'Iteration', 'StartDate', 'EndDate', 'ScheduleState', 'Feature', 'PlanEstimate', 'AcceptedDate', 'CreationDate'],
					autoLoad: false,
					limit: Infinity,
					pageSize: 200,
					filters: [standardFilter],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: me.ProjectRecord.data._ref
					}
				};
			var store = Ext.create('Rally.data.wsapi.Store', storeConfig);
			return me.reloadStore(store);
		},
		
		/*
		 *	Loads all iterations referenced by the current set of user stories
		 */
		_loadIterations: function() {
			var me = this,
				filter = me._getIterationFilter();
			var store = Ext.create('Rally.data.wsapi.Store', {
				autoLoad: false,
				limit: Infinity,
				model: 'Iteration',
				pageSize: 200,
				fetch: ['ObjectID', 'Name', 'StartDate', 'EndDate'],
				filters: filter,
				// This is sorted to make charting it easy
				sorters: [
					{
						property: 'StartDate',
						direction: 'ASC'
					}
				],
				context: {
					workspace: me.getContext().getWorkspace(),
					project: me.getContext().getProject()._ref,
					projectScopeUp: false,
					projectScopeDown: false
				}
			});
			
			return me.reloadStore(store).then(function(iterationStore) {
				me.Iterations = iterationStore.getRange();
			});
		},
		
		/**************************************** Data ********************************************/
		/*
		 *	Gets a filtered subset of data for the backlog chart
		 */
		_filterBacklogPointsToRange: function(points) {
			var me = this,
				startIndex = 0,
				endIndex = points.length - 1;

			if (me.FilterBy !== 'Release') {
				while (startIndex < points.length && points[startIndex].endDate < me.FilterStartDate) {
					startIndex++;
				}
				while (endIndex >= 0 && points[endIndex].startDate > me.FilterEndDate) {
					endIndex--;
				}
			}
			else {
				startIndex = _.findIndex(points, function(point) {return point.name.slice(0, 4) === me.FilterRelease.data.Name.slice(0,4);});
				endIndex = _.findLastIndex(points, function(point) {return point.name.slice(0, 4) === me.FilterRelease.data.Name.slice(0,4);});
			}
			
			return points.slice(startIndex, endIndex + 1);
		},
		
		/*
		 *	Creates the state chart data object
		 */
		_getStateChartData: function() {
			var me = this,
				total = me.StoryStore.data.length,
				stateData = [
					{name: 'Undefined', y: 0, totalCount: total},
					{name: 'Defined', y: 0, totalCount: total},
					{name: 'In-Progress', y: 0, totalCount: total},
					{name: 'Completed', y: 0, totalCount: total},
					{name: 'Accepted', y: 0, totalCount: total}
				];
			
			// Create object for fast counting
			var stateCounts = {};
			_.each(stateData, function(datum, index) {
				stateCounts[datum.name] = stateData[index];
			});
			
			// Count number of user stories in each state category
			_.each(me.StoryStore.getRange(), function(story) {
				stateCounts[story.data.ScheduleState].y++;
			});
			
			// This is to maintain consistency with promises (sorry)
			return Q.fcall(function() {return stateData;});
		},
		
		/*
		 *	Creates the percentage chart data object
		 *	TODO: This should be highly optimizable
		 */
		_getPercentageChartData: function() {
			var me = this,
				percentageData = [
					{name: 'CI', y: me.StoryStore.data.length},
					{name: 'Non-CI', y: 0}
				],
				config = {
					autoLoad: false,
					limit: 1,
					model: me.UserStory,
					// "Get" nothing to make counting total results faster
					fetch: [],
					filters: [me.ReleaseFilter],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: me.ProjectRecord.data._ref,
						projectScopeUp: false,
						projectScopeDown: true
					}
				},
				releaseStoryStore = Ext.create('Rally.data.wsapi.Store', config);
			return me.reloadStore(releaseStoryStore).then(function(store) {
				// Number of non-CI stories is total stories - CI stories
				percentageData[1].y = store.totalCount - percentageData[0].y;
				
				// Used for formatting
				percentageData[1].totalCount = percentageData[0].totalCount = store.totalCount;
				
				return percentageData;
			});
		},
		
		/*
		 *	Creates the backlog chart data object
		 */
		_getBacklogChartData: function(field) {
			var me = this,
				backlogData = [],
				storyTotal = 0,
				dataField = field || 'size',
				iterationNameRegExp = /^Q\d+_s\d+/;
			// Create data objects for all iterations for the deltas and the totals
			_.each(me.Iterations, function(iteration) {
				var iterationStartDate = iteration.data.StartDate,
					iterationEndDate = iteration.data.EndDate;
				backlogData.push({
					name: iteration.data.Name.match(iterationNameRegExp)[0],
					delta: 0,
					added: 0,
					accepted: 0,
					size: 0,
					startDate: iterationStartDate,
					endDate: iterationEndDate,
					y: 0,
					createdStories: [],
					acceptedStories: [],
					backloggedStories: []
				});
			});
			
			// Calculate stories added, accepted, and delta per iteration
			_.each(me.StoryStore.getRange(), function(story) {
				var storyCreationDate = story.data.CreationDate,
					storyAcceptedDate = story.data.AcceptedDate;
					
				// Accounts for stories written before planned iterations
				if (storyCreationDate < backlogData[0].startDate) storyTotal++;
				if (story.data.AcceptedDate && storyAcceptedDate < backlogData[0].startDate) storyTotal--;
				
				for (var i in backlogData) {
					if (storyCreationDate <= backlogData[i].endDate && (!story.data.AcceptedDate || storyAcceptedDate > backlogData[i].endDate)) {
						backlogData[i].backloggedStories.push(story);
					}
					if (storyCreationDate >= backlogData[i].startDate && storyCreationDate <= backlogData[i].endDate) {
						backlogData[i].added++;
						backlogData[i].delta++;
						backlogData[i].createdStories.push(story);
					}
					if (story.data.AcceptedDate && storyAcceptedDate >= backlogData[i].startDate && storyAcceptedDate <= backlogData[i].endDate) {
						backlogData[i].accepted++;
						backlogData[i].delta--;
						backlogData[i].acceptedStories.push(story);
					}
				}
			});
			
			// Calculate backlog count at each iteration end
			for (var j in backlogData) {
				storyTotal += backlogData[j].delta;
				backlogData[j].size = storyTotal;
				backlogData[j].y = backlogData[j][dataField];
			}
			return backlogData;
		},
		
		/**************************************** UI **********************************************/
		/*
		 *	Removes all existing UI components, keeping containers intact
		 */
		_removeAllComponents: function() {
			var me = this;
			
			// Empty chart containers
			$('#state-chart-container').empty();
			$('#percentage-chart-container').empty();
			$('#backlog-chart-container').empty();
			
			// Completely destroy grid
			me.down('#grid-container').removeAll(true);
		},
		
		/*
		 *	Hides the link for Highcharts
		 */
		_hideHighchartsLink: function() {
			$('.highcharts-container > svg > text:last-child').hide();
		},
		
		/*
		 *	Loads all UI components
		 */
		_loadUI: function() {
			var me = this;
			me.setLoading('Loading Visuals');
			
			// Load controls
			me.down('#backlog-chart-controls-container').removeAll();
			me._loadControls();
			
			// Load other UI components
			return me._loadCharts().then(me._loadGrid.bind(me)).then(function() {
				me.setLoading(false);
			});
		},
		
		/*
		 *	Loads all controls
		 */
		_loadControls: function() {
			var me = this;
		
			// Maintain state of checkbox
			if (!me.ReleaseCheck) me._loadReleaseCheck();
			
			// Load backlog chart controls only if showing backlog chart
			if (me.isShowingAllReleases) me._loadBacklogChartControls();
		},
		
		/*
		 *	Creates and adds checkbox for filtering to current release
		 */
		// TODO: Make this checkbox prettier (it's ugly and Spartan right now)
		_loadReleaseCheck: function() {
			var me = this;
			me.ReleaseCheck = Ext.create('Rally.ui.CheckboxField', {
				checked: false,
				fieldLabel: 'All releases',
				listeners: {
					change: me._releaseCheckboxChanged,
					scope: me
				}
			});
			me.down('#general-controls-container').add(me.ReleaseCheck);
		},
		
		/*
		 *	Creates and adds all controls related to the backlog chart
		 */
		_loadBacklogChartControls: function() {
			if (this.Iterations.length === 0) return;
			var me = this,
				backlogControls = [],
				iterationStore = Ext.create('Rally.data.wsapi.Store', {
					autoLoad: false,
					data: me.Iterations,
					model: 'Iteration'
				}),
				dataFieldsStore = Ext.create('Ext.data.Store', {
					fields: ['DisplayName', 'PropertyName'],
					data: [
						{DisplayName: 'Backlog Size', PropertyName: 'size'},
						{DisplayName: 'Added Stories', PropertyName: 'added'},
						{DisplayName: 'Accepted Stories', PropertyName: 'accepted'},
						{DisplayName: 'Backlog Delta', PropertyName: 'delta'}
					]
				});
			
			// Store controls in me for use in listeners
			me.IterationRadio = Ext.create('Ext.form.field.Radio', {
				id: 'iteration-radio-box',
				name: 'filter-type',
				boxLabel: 'Iteration',
				labelWidth: 50,
				checked: true,
				listeners: {
					change: me._backlogFilterTypeChanged,
					scope: me
				}
			});
			me.DateRadio = dateRadio = Ext.create('Ext.form.field.Radio', {
				id: 'date-radio-box',
				name: 'filter-type',
				boxLabel: 'Date',
				labelWidth: 50,
				checked: false,
				listeners: {
					change: me._backlogFilterTypeChanged,
					scope: me
				}
			});
			me.ReleaseRadio = Ext.create('Ext.form.field.Radio', {
				id: 'release-radio-box',
				name: 'filter-type',
				boxLabel: 'Release',
				labelWidth: 50,
				checked: false,
				listeners: {
					change: me._backlogFilterTypeChanged,
					scope: me
				}
			});
			me.StartIterationCombo = Ext.create('Rally.ui.combobox.ComboBox', {
				displayField: 'Name',
				id: 'start-iteration-combo-box',
				fieldLabel: 'Start:',
				labelWidth: 50,
				labelAlign: 'right',
				store: iterationStore,
				padding: '0 0 0 15',
				listeners: {
					select: me._rangeChanged,
					scope: me
				},
				value: me.Iterations[0],
				valueField: 'StartDate'
			});
			me.EndIterationCombo = Ext.create('Rally.ui.combobox.ComboBox', {
				displayField: 'Name',
				id: 'end-iteration-combo-box',
				fieldLabel: 'End:',
				labelWidth: 50,
				labelAlign: 'right',
				store: iterationStore,
				padding: '0 0 0 15',
				listeners: {
					select: me._rangeChanged,
					scope: me
				},
				value: me.Iterations[me.Iterations.length - 1],
				valueField: 'EndDate'
			});
			me.StartDatePicker = Ext.create('Rally.ui.DateField', {
				hidden: true,
				fieldLabel: 'Start:',
				labelAlign: 'right',
				labelWidth: 50,
				id: 'start-date-picker',
				padding: '0 0 0 15',
				listeners: {
					select: me._rangeChanged,
					scope: me
				},
				value: new Date(me.Iterations[0].data.StartDate)
			});
			me.EndDatePicker = Ext.create('Rally.ui.DateField', {
				hidden: true,
				fieldLabel: 'End:',
				labelAlign: 'right',
				labelWidth: 50,
				id: 'end-date-picker',
				padding: '0 0 0 15',
				listeners: {
					select: me._rangeChanged,
					scope: me
				},
				value: new Date(me.Iterations[me.Iterations.length - 1].data.EndDate)
			});
			me.ReleasePicker = Ext.create('Intel.lib.component.ReleasePicker', {
				hidden: true,
				labelWidth: 50,
				labelAlign: 'right',
				fieldLabel: 'Release',
				releases: _.filter(me.ReleaseRecords, function(release) {
						return me.Iterations[0].data.StartDate <= release.data.ReleaseDate && me.Iterations[me.Iterations.length - 1].data.EndDate >= release.data.ReleaseStartDate;
					}),
				currentRelease: me.FilterRelease,
				listeners: {
					select: me._rangeChanged,
					scope: me
				}
			});
			me.DataFieldCombo = Ext.create('Ext.form.field.ComboBox', {
				store: dataFieldsStore,
				fieldLabel: 'Data:',
				labelAlign: 'right',
				labelWidth: 50,
				padding: '0 0 0 15',
				displayField: 'DisplayName',
				valueField: 'PropertyName',
				listeners: {
					select: me._redrawBacklogChart,
					scope: me
				},
				value: 'size'
			});
			
			// Set initial values used
			me.FilterBy = 'Iteration';
			me.FilterStartDate = me.Iterations[0].data.StartDate;
			me.FilterEndDate = me.Iterations[me.Iterations.length - 1].data.EndDate;
			
			// Push all relevant controls onto array for efficient adding
			backlogControls.push(me.IterationRadio, me.DateRadio, me.ReleaseRadio, me.StartIterationCombo, me.EndIterationCombo, me.StartDatePicker, me.EndDatePicker, me.ReleasePicker, me.DataFieldCombo);
			
			// Add components
			return me.down('#backlog-chart-controls-container').add(backlogControls);
		},
		
		/*
		 *	Redraws the backlog chart using the new range and data field
		 */
		_redrawBacklogChart: function() {
			var me = this,
				dataField = me.DataFieldCombo.getValue(),
				data = me._filterBacklogPointsToRange(me._getBacklogChartData(dataField)),
				chartConfig = me._getBacklogChartConfig(data);
				
			// Set new series name
			chartConfig.series[0].name = me.DataFieldCombo.getRawValue() + ' Over Time';
			
			// Remove old chart
			$('#backlog-chart-container').empty();
			
			// Add new chart
			$('#backlog-chart-container').highcharts(chartConfig);
			
			// Hide that pesky link
			me._hideHighchartsLink();
		},
		
		/*
		 *	Creates the config object for the state chart
		 */
		_getStateChartConfig: function(data) {
			var me = this;
			return {
				chart: {
					height:(me.getHeight() > 700) ? (me.getHeight()*0.32 >> 0) : (me.getHeight()*0.45),
					width: (me.getWidth()/4 >> 0),
					plotBackgroundColor: null,
					plotBorderWidth: 0,
					plotShadow: false
				},
				title: {text: 'Story States'},
				tooltip: {enabled: false},
				plotOptions: {
					pie: {
						dataLabels: {
							enabled: true,
							distance:25,
							crop:false,
							overflow:'none',
							formatter: function(){
								var str = '<b>' + this.point.name + '</b>: ' + this.point.y;
								return str;
							},
							style: { 
								cursor:'pointer',
								color: 'black'
							}
						}
					}
				},
				series: [{
					type: 'pie',
					name: 'States',
					innerSize: '25%',
					size: 175,
					data: data
				}]
			};
		},
		
		/*
		 *	Creates the config object for the percentage chart
		 */
		_getPercentageChartConfig: function(data) {
			var me = this;
			return {
				chart: {
					height: (me.getHeight() > 700) ? (me.getHeight()*0.32 >> 0) : (me.getHeight()*0.45),
					width: (me.getWidth()/4 >> 0),
					plotBackgroundColor: null,
					plotBorderWidth: 0,
					plotShadow: false
				},
				title: {text: 'CI Story Percentage'},
				tooltip: {enabled: false},
				plotOptions: {
					pie: {
						dataLabels: {
							enabled: true,
							distance:25,
							crop:false,
							overflow:'none',
							formatter: function(){
								return '<b>' + this.point.name + '</b>: ' + (this.point.y/this.point.totalCount*100).toFixed(1) + '%';
							},
							style: { 
								cursor:'pointer',
								color: 'black'
							}
						}
					}
				},
				series: [{
					type: 'pie',
					name: 'Percentages',
					innerSize: '25%',
					size: 175,
					data: data
				}]
			};
		},
		
		/*
		 *	Creates the config object for the backlog chart
		 */
		_getBacklogChartConfig: function(data) {
			var me = this;
			return {
				chart: {
					height: (me.getHeight() > 700) ? (me.getHeight()*0.64 >> 0) : (me.getHeight()*0.5),
					// width: (me.getWidth()/2 >> 0),
					plotBackgroundColor: null,
					plotBorderWidth: 0,
					plotShadow: false
				},
				title: {text: 'CI Story Backlog'},
				tooltip: {enabled: true},
				series: [
					{
						type: 'column',
						name: 'Backlog Size Over Time',
						data: data,
						tooltip: {
							pointFormatter: function() {
								return '<b><u>Iteration Information:</u></b><br>' + 
									'Backlog Size: ' + this.size + '<br>' +
									'Stories Added: ' + this.added + '<br>' +
									'Stories Accepted: ' + this.accepted + '<br>' +
									'Backlog Delta: ' + this.delta + '<br>';
							}
						},
						events: {
							click: me._loadIterationBreakdown.bind(me)
						}
					}
				],
				yAxis: {
					tickInterval: 2,
					title: {
						text: '# Stories'
					}
				},
				xAxis: {
					title: {
						text: 'Iteration'
					},
					type: 'category'
				}
			};
		},
		
		/*
		 *	Creates three grids for an "exploded view" of the backlog during an iteration
		 */
		_loadIterationBreakdown: function(e) {
			var point = e.point,
				me = this,
				configs = [
					{title: 'Backlogged Stories', field: 'backloggedStories'},
					{title: 'Created Stories', field: 'createdStories'},
					{title: 'Accepted Stories', field: 'acceptedStories'}
				],
				breakdownContainer = Ext.create('Ext.container.Container', {
					id: 'breakdown-container',
					items: [
						{
							xtype: 'button',
							text: 'Close Breakdown',
							listeners: {
								click: function() {
									me.down('#breakdown-container').destroy();
									me.down('#storygrid').show();
								}
							}
						}
					].concat(_.map(configs, function(config) {
						return {
							xtype: 'rallygrid',
							title: config.title,
							columnCfgs: [
								'FormattedID',
								'Name',
								'Owner'
							],
							pagingToolbarCfg: {
								pageSizes: [5, 10],
								autoRender: true,
								resizable: false
							},
							store: Ext.create('Rally.data.custom.Store', {
								model: me.UserStory,
								autoLoad: false,
								data: point[config.field],
								pageSize: 5
							})
						};
					}))
				});
			
			me.down('#storygrid').hide();
			if (me.down('#breakdown-container')) me.down('#breakdown-container').destroy();
			me.down('#grid-container').add(breakdownContainer);
		},
		
		/*
		 *	Creates the config object for the user story grid
		 */
		_getGridConfig: function() {
			var me = this;
			return {
				id: 'storygrid',
				title: 'Team Continuous Improvement Stories',
				store: Ext.create('Rally.data.custom.Store', {
					autoLoad: false,
					model: me.UserStory,
					data: me.StoryStore.getRange(),
					pageSize: (me.getHeight() > 700 ? 20 : 10)
					
				}),
				sortableColumns: true,
				pagingToolbarCfg: {
					pageSizes: [10, 20, 25, 100],
					autoRender: true,
					resizable: false
				},
				columnCfgs: [
					'FormattedID',
					'Name',
					'Owner',
					'Iteration',
					'ScheduleState',
					'PlanEstimate',
					{
						text: 'Days Unaccepted',
						editor: false,
						renderer:function(val, meta, record){
							var day = 1000*60*60*24;
							return ((record.data.AcceptedDate ? new Date(record.data.AcceptedDate) : new Date()) - new Date(record.data.CreationDate).getTime())/day>>0;
						}
					}
				]
			};
		},
		
		/*
		 *	Loads and adds charts
		 */
		_loadCharts: function() {
			var me = this,
				promises = [
					me._getStateChartData(),
					me._getPercentageChartData()
				];
			if (me.isShowingAllReleases) promises.push(me._getBacklogChartData());
			
			return Q.all(promises).then(function(data) {
				// Add charts
				if (me.isShowingAllReleases) $('#backlog-chart-container').highcharts(me._getBacklogChartConfig(data[2]));
				$('#state-chart-container').highcharts(me._getStateChartConfig(data[0]));
				$('#percentage-chart-container').highcharts(me._getPercentageChartConfig(data[1]));
				
				// Hide that pesky link
				me._hideHighchartsLink();
				
				// TODO: Not sure what to return here
				return 0;
			});
		},
		
		/*
		 *	Loads and adds user story grid
		 */
		_loadGrid: function() {
			var me = this,
				gridConfig = me._getGridConfig();
			me.StoryGrid = Ext.create('Rally.ui.grid.Grid', gridConfig);
			return me.down('#grid-container').add(me.StoryGrid);
		},
		
		/**************************************** Event Handling **********************************/
		/*
		 *	Fires when the filter type for the backlog chart is changed
		 *	TODO: Switching timeframes is slightly (extremely broken)
		 */
		_backlogFilterTypeChanged: function(radio) {
			var me = this,
				controlsContainer = me.down('#backlog-chart-controls-container');
			
			// Set the global variable
			if (me.IterationRadio.getValue()) me.FilterBy = 'Iteration';
			else if (me.DateRadio.getValue()) me.FilterBy = 'Date';
			else me.FilterBy = 'Release';
			
			// Hide all filter controls
			me.StartIterationCombo.hide();
			me.EndIterationCombo.hide();
			me.StartDatePicker.hide();
			me.EndDatePicker.hide();
			me.ReleasePicker.hide();
			
			if (me.FilterBy === 'Iteration') {
				me.StartIterationCombo.show();
				me.EndIterationCombo.show();
				
				// TODO: Possibly change the dates to match iteration after setting combo
				me.StartIterationCombo.setValue(_.find(me.Iterations, function(iteration) {return iteration.data.EndDate >= me.FilterStartDate;}));
				me.EndIterationCombo.setValue(_.findLast(me.Iterations, function(iteration) {return iteration.data.StartDate <= me.FilterEndDate;}));
			}
			else if (me.FilterBy === 'Date') {
				me.StartDatePicker.show();
				me.EndDatePicker.show();

				me.StartDatePicker.setValue(me.FilterStartDate);
				me.EndDatePicker.setValue(me.FilterEndDate);
			}
			else {
				me.ReleasePicker.show();
				
				// me.FilterRelease = _.find(me.ReleaseRecords, function(release) {return me.FilterStartDate >= release.data.ReleaseStartDate && me.FilterStartDate <= release.data.ReleaseStartDate;});
				// DEBUG temporary solution
				me.FilterRelease = me.CurrentRelease;
				me.ReleasePicker.setValue(me.FilterRelease);
			}
			me._redrawBacklogChart();
		},
		
		/*
		 *	Fires when an iteration combo box is changed
		 */
		_rangeChanged: function() {
			var me = this;

			if (me.FilterBy === 'Iteration') {
				me.FilterStartDate = me.StartIterationCombo.getValue();
				me.FilterEndDate = me.EndIterationCombo.getValue();
			}
			else if (me.FilterBy === 'Date') {
				me.FilterStartDate = me.StartDatePicker.getValue();
				me.FilterEndDate = me.EndDatePicker.getValue();
			}
			else {
				var release = _.find(me.ReleaseRecords, function(release) {return me.ReleasePicker.getValue() === release.data.Name;});
				me.FilterRelease = release;
				me.FilterStartDate = release.data.ReleaseStartDate;
				me.FilterEndDate = release.data.ReleaseDate;
			}
			
			me._redrawBacklogChart();
		},
		
		/*
		 *	Fired when the checkbox for showing all releases is clicked
		 */
		_releaseCheckboxChanged: function(box, newVal, oldVal, opts) {
			var me = this;
			me.isShowingAllReleases = newVal;
			
			// Reload stories and UI
			me._removeAllComponents();
			if (me.isShowingAllReleases) {
				return me._loadStories().then(function() {
					return me._loadIterations();
				}).then(function() {
					return me._loadUI();
				});
			}
			else {
				return me._loadStories().then(function() {
					return me._loadUI();
				});
			}
		},
		
		/**************************************** Filters *****************************************/
		/*
		 *	Gets a filter object for either all releases or just the current release
		 */
		_getReleaseFilter: function() {
			var me = this;
			if (me.isShowingAllReleases) {
				// TODO: This code just feels wrong, should replace it with something...not terrible
				return Ext.create('Rally.data.wsapi.Filter', {property: 'Name', operator: '!=', value: null});
			}
			else {
				// Filter to only current release
				return Ext.create('Rally.data.wsapi.Filter', {
					property: 'Release.Name',
					operator: '=',
					value: me.CurrentRelease.data.Name
				});
			}
		},
		
		/*
		 *	Gets the filter for all relevant iterations
		 */
		_getIterationFilter: function() {
			var me = this,
				// Set to now, all dates guaranteed to be before
				firstDate = new Date(),
				// Set to minimum date
				lastDate = new Date(null),
				endsAfterFilter,
				startsBeforeFilter;
			
			// Find the extremes of dates
			_.each(me.StoryStore.getRange(), function(story) {
				var creationDate = story.data.CreationDate,
					acceptedDate = story.data.AcceptedDate,
					iterationStartDate = story.data.Iteration ? story.data.Iteration.StartDate : new Date();
					iterationEndDate = story.data.Iteration ? story.data.Iteration.EndDate : new Date(null);
				if (creationDate < firstDate) firstDate = creationDate;
				if (iterationStartDate < firstDate)firstDate = iterationStartDate;
				if (acceptedDate > lastDate) lastDate = acceptedDate;
				if (creationDate > lastDate) lastDate = creationDate;
				if (iterationEndDate > lastDate) lastDate = iterationEndDate;
			});
			
			// Create filters to narrow the time box of the iterations
			endsAfterFilter = Ext.create('Rally.data.wsapi.Filter', {
				property: 'EndDate',
				operator: '>=',
				value: firstDate.toISOString()
			});
			startsBeforeFilter = Ext.create('Rally.data.wsapi.Filter', {
				property: 'StartDate',
				operator: '<=',
				value: lastDate.toISOString()
			});
			
			return [endsAfterFilter, startsBeforeFilter];
		}
	});
})();

            Rally.launchApp('ContinuousImprovementReport', {
                name:"Continuous Improvement Report",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .x-grid-cell.intel-editor-cell *,
.x4-grid-cell.intel-editor-cell *,
.intel-editor-cell {
  cursor: pointer !important;
}
.fa.fa-md {
  font-size: 1.05rem;
  line-height: .75em;
  vertical-align: -15%;
}
/************************************************ RALLY BUTTON STYLE *****************************************/
.intel-button {
  border-radius: 2px;
  background-color: #00a9e0;
  border-color: #00a9e0;
}
.intel-button:hover {
  background-color: #29beff;
  border-color: #29beff;
}
.intel-button * {
  font-size: 12px;
}

    </style>

    <style type="text/css">
        .app {
  /* Add app styles here */
}

    </style>
</head>
<body>
</body>
</html>
