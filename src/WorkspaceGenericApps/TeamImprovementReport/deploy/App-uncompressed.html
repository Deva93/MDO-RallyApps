<!DOCTYPE html>
<html>
<head>
    <title>Continuous Improvement Report</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.js"></script>
    <script type="text/javascript" src="https://code.highcharts.com/highcharts.src.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/sprintf/1.0.1/sprintf.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** this extends Rally.app.app. if you want to use it's utility functions, just
		extend IntelRallyApp instead of Rally.app.App
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	//increase timeouts to 2 minutes since rally can be slow sometimes
	var timeout = 120000;
	Ext.override(Ext.data.proxy.Ajax, { timeout: timeout });
	Ext.override(Ext.data.proxy.JsonP, { timeout: timeout });
	
	//rally's built-in jsonpproxy does not handle timeouts
	Ext.override(Rally.sdk.data.lookback.JsonPProxy, {
		setException: function(operation, response){
			var error = operation.getError() || {};
			operation.setException(Ext.apply(error, {
				errors:(response || {}).Errors || []
			}));
		}
	});
				
	Ext.define('IntelRallyApp', {
		alias: 'widget.intelrallyapp',
		extend: 'Rally.app.App',
		
		_ScrumGroupConfigPrefName: 'intel-portfolio-locations-config', //preference to store portfolio locations config for workspace
		
		_projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
		_portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'Release','c_TeamCommits', 'c_MoSCoW', 
			'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal'],
		_userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
			'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
		_releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
		
		/********************************************** APP CONFIGURATION **************************************/
		_loadScheduleStates: function(){ 
			var me=this, deferred = Q.defer();
			Rally.data.ModelFactory.getModel({
				type: 'UserStory',
				success: function(model) {
					model.getField('ScheduleState').getAllowedValueStore().load({
						callback: function(records, operation, success) {
							me.ScheduleStates = _.map(records, function(r){ return r.data.StringValue; });
							deferred.resolve();
						}
					});
				}
			});
			return deferred.promise;
		},
		_loadPortfolioItemStatesForEachType: function(){ 
			var me=this;
			me.PortfolioItemTypeStates = [];
			return Q.all(_.map(me.PortfolioItemTypes, function(portfolioType, ordinal){
				var store = Ext.create('Rally.data.wsapi.Store', {
					model: 'State',
					autoLoad:false,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Name', 'Enabled', 'OrderIndex'],
					filters: [{
						property: 'TypeDef.Name',
						value: portfolioType
					},{
						property: 'Enabled',
						value: true
					}]
				});
				return me._reloadStore(store).then(function(store){
					me.PortfolioItemTypeStates[ordinal] = store.getRange();
				});
			}));
		},
		_loadPortfolioItemTypes: function(){ 
			/** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
			var me=this,
				deferred = Q.defer(),
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'TypeDefinition',
					autoLoad:true,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					listeners:{
						load:function(portfolioTypeStore){
							me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(), 
								function(item){ return {Name: item.data.Name, Ordinal: item.data.Ordinal}; }),
								function(item){ return item.Ordinal; }),
								function(item){ return item.Name; });
							deferred.resolve();
						}
					}
				});
			return deferred.promise;
		},
		_loadModels: function(){ 
			/** loads models for project, userstories, and all the portfolio items */
			var me=this, 
				promises = [],
				models = {
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					PortfolioItem: 'PortfolioItem'
				};
			_.each(me.PortfolioItemTypes, function(name){ models['PortfolioItem/' + name] = 'PortfolioItem/' + name; });
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},
		_loadScrumGroupConfig: function(){
			/** scrum-groups are groups of scrums that share the same portfolio. The group of scrums may or may not be a train */
			/** me.ScrumGroupConfig is an array of these objects: 
				{
					ScrumGroupRootProjectOID: configItem.ScrumGroupRootProjectOID || 0,
					ScrumGroupName: configItem.ScrumGroupName || '',
					ScrumGroupAndPortfolioLocationTheSame: configItem.ScrumGroupAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0,
					IsTrain: configItem.IsTrain ? true : false
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._ScrumGroupConfigPrefName,
				success: function(prefs) {
					var configString = prefs[me._ScrumGroupConfigPrefName], scrumGroupConfig;
					try{ scrumGroupConfig = JSON.parse(configString); }
					catch(e){ scrumGroupConfig = []; }
					me.ScrumGroupConfig = scrumGroupConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveScrumGroupConfig: function(scrumGroupConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[me._ScrumGroupConfigPrefName] = JSON.stringify(scrumGroupConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._ScrumGroupConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_configureIntelRallyApp: function(){
			var me=this;
			me.BaseUrl = Rally.environment.getServer().getBaseUrl(); //is "" when in custom app iframe
			return Q.all([
				me._loadPortfolioItemTypes().then(function(){ 
					me._userStoryFields.push(me.PortfolioItemTypes[0]);  //HOLY PROGRAM BOARD BUG, BATMAN! (me._isUserStoryInRelease false for those who: (release == null && portfolioItrem.release.name == me.ReleaseRecord.data.Name)).
					return Q.all([
						me._loadModels(),
						me._loadPortfolioItemStatesForEachType()
					]);
				}),
				me._loadScrumGroupConfig(),
				me._loadScheduleStates()
			]);
		},
				
		/**************************** Generic store loading with Q wrapper, returns promise *************************************/		
		_reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		},
		
		/********************************************** LOADING SINGLE MODELS **************************************/	
		_loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LP');
			else if(!me.Project) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.Project.load(oid, {
					fetch: me._projectFields,
					context: { 
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadUserStory: function(oid, projectRecord){
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LUS');
			else if(!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.UserStory.load(oid, {
					fetch: me._userStoryFields,
					context: {
						workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
						project: projectRecord ? projectRecord.data._ref : null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByType: function(oid, type){
			var me = this, deferred = Q.defer();
			if(!oid || !type) return Q.reject('Invalid arguments: LPIBT');
			else {
				me[type].load(oid, {
					fetch: me._portfolioItemFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByOrdinal: function(oid, ordinal){
			var me = this, deferred = Q.defer(),
				type = me.PortfolioItemTypes[ordinal];
			return me._loadPortfolioItemByType(oid, type);
		},	
		
		/**************************************** ScrumGroup Funcs ***************************************************/
		_projectInWhichScrumGroup: function(projectRecord){ 
			/** returns scrumgroup the projectRecord is in, otherwise null. */
			if(!projectRecord) return Q();
			else {
				var me=this,
					foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
						return scrumGroupConfig.ScrumGroupRootProjectOID == projectRecord.data.ObjectID; 
					});
				if(foundScrumGroupConfig) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q();
					else {
						return me._loadProject(parent.ObjectID).then(function(parentRecord){
							return me._projectInWhichScrumGroup(parentRecord);
						});
					}
				}
			}
		},
		_loadScrumGroupPortfolioProject: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) return Q.reject('Invalid arguments: _loadScrumGroupPortfolioProject');
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) return Q.reject('Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum group!');
			if(foundScrumGroupConfig.ScrumGroupAndPortfolioLocationTheSame) return Q(scrumGroupRootProjectRecord);
			else return me._loadProject(foundScrumGroupConfig.PortfolioProjectOID);
		},
		_getScrumGroupName: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) throw 'Invalid arguments: _getScrumGroupName';
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) throw 'Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum-group!';
			if(foundScrumGroupConfig.ScrumGroupName) return foundScrumGroupConfig.ScrumGroupName;
			else return scrumGroupRootProjectRecord.data.Name;
		},
		_loadAllScrumGroups: function(){
			var me=this,
				filter = _.reduce(me.ScrumGroupConfig, function(filter, scrumGroupConfig){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', { property:'ObjectID', value: scrumGroupConfig.ScrumGroupRootProjectOID });
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			if(!filter) return Q([]);
			else {
				var store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._projectFields,
					filters:[filter],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
				return me._reloadStore(store).then(function(store){ return store.getRange(); });
			}
		},
		
		/**************************************** UserStory Funcs ************************************************/
		__getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ 
			/** only pull look at PortfolioItem Release if US.Release == null */
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property: lowestPortfolioItem + '.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property: lowestPortfolioItem + '.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		_loadRandomUserStory: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: LRUS');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: false,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{ 
						property:'Project.ObjectID', 
						value: projectRecord.data.ObjectID 
					}]
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadRandomUserStoryFromReleaseTimeframe: function(projectRecord, releaseRecord){
			if(!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: LRUSFR');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					disableMetaChangeEvent: true,
					fetch: me._userStoryFields,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project.ObjectID', value: projectRecord.data.ObjectID }).and(
						me.__getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me._reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		_loadUserStoryByFID: function(formattedID, projectRecord){
			if(!formattedID || !projectRecord) return Q.reject('Invalid arguments: LUSBFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		
		/**************************************** PortfolioItem Funcs ************************************************/
		_loadPortfolioItemsOfType: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: OPIOT');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					disableMetaChangeEvent: true,
					remoteSort:false,
					fetch: me._portfolioItemFields,
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store);
		},		
		_loadPortfolioItemsOfOrdinal: function(portfolioProject, ordinal){
			if(!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: LPIOO');
			var me=this, type = me.PortfolioItemTypes[ordinal];
			if(type) return me._loadPortfolioItemsOfType(portfolioProject, type);
			else return Q.reject('Invalid PortfolioItem ordinal');
		},
		_portfolioItemTypeToOrdinal: function(type){
			return this.PortfolioItemTypes.indexOf(type);
		},
		_getPortfolioItemTypeStateByOrdinal: function(ordinal, stateName){
			return _.find(this.PortfolioItemTypeStates[ordinal], function(state){ return state.data.Name == stateName; });
		},
		_getPortfolioItemTypeStateByName: function(portfolioType, stateName){
			return this._getPortfolioItemTypeStateByOrdinal(this._portfolioItemTypeToOrdinal(portfolioType), stateName);
		},
		
		/********************************************** Project Funcs ********************************************/
		/****************************** THESE DO NOT WORK WITH sdk 2.0. USE SDK 2.0rc3 *******************/
		__storeItemsToProjTree: function(projects){
			var me=this, projTree = {};
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			return projTree;
		},
		_loadAllProjects: function(){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				var map = _.reduce(store.getRange(), function(map, project){
					map[project.data.ObjectID] = project;
					return map;
				}, {});
				return map;
			});	
		},
		__addProjectsWithTeamMembersToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
			}
		},	
		_loadProjectsWithTeamMembers: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				projectsWithTeamMembers = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
					return projectsWithTeamMembers;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.TeamMembers.Count > 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},	
		__allChildProjectToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_loadAllChildrenProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				childrenProjects = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
					return childrenProjects;
				} else {
					return _.reduce(store.getRange(), function(map, project){
						map[project.data.ObjectID] = project;
						return map;
					}, {});
				}
			});
		},	
		__allLeafProjectsToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		_loadAllLeafProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				leafProjects = {}, 
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
					return leafProjects;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.Children.Count === 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},
		_loadProjectByName: function(projectName){
			if(!projectName) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [{
						property:'Name',
						value:projectName
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** Release loading ********************************************/	
		_loadAllReleases: function(projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesBeforeGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					disableMetaChangeEvent: true,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'<=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesBetweenDates: function(projectRecord, startDate, endDate){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit: Infinity,
					autoLoad:false,
					fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					},{
						property:'ReleaseDate',
						operator:'>',
						value: new Date(startDate).toISOString()
					},{
						property:'ReleaseStartDate',
						operator:'<',
						value: new Date(endDate).toISOString()
					}]
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesInTheFuture: function(projectRecord){
			return this._loadReleasesAfterGivenDate(projectRecord, new Date());
		},
		_loadReleasesByNameUnderProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					}],
					context:{
						project:projectRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleaseByNameForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						operator:'contains',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_getScopedRelease: function(releaseRecords, projectOID, appPrefs){			
			/** gets the most likely release to scope to base on the following order:
				1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
								to use preferences for this one)
				2) if we are currently in one of the releases
				3) the closest release planning date to the current date
			*/
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate)*1, d2 = new Date(r.data.ReleaseStartDate)*1, now = new Date()*1;
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
		/************************* MODEL FOR WORKWEEK DROPDOWNS *********************************************/
	Ext.define('WorkweekDropdown', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Workweek', type:'string'},
			{name: 'DateVal', type:'number'}
		]
	});
		
	/************************* USED FOR WORKSPACE TRAIN CONFIG *********************************************/
	Ext.define('TrainConfigItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'TrainProjectOID', type: 'number'},
			{name: 'TrainName', type: 'string'},
			{name: 'TrainAndPortfolioLocationTheSame', type:'boolean'},
			{name: 'PortfolioProjectOID', type:'number'}
		]
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
		/** this is used if you want to listen to events in the parent window (e.g. useful for rally apps that resize with browser screen
			vertically or things that need to know browser scroll position) 
		You also can artificially fire the events and have the listeners run
	*/
	Ext.define('WindowListener', {

		__initWindowEventListener: function(eventName){
			var me=this;
			if(!me._windowListeners) me._windowListeners = {};
			me._windowListeners[eventName] = [];
			
			window.parent['on' + eventName] = function(event){ 
				var listeners = me._windowListeners[eventName];
				for(var i=0, len=listeners.length; i<len; ++i)
					listeners[i](event);
			};
		},
		
		_addWindowEventListener: function(eventName, fn){
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) 
				me.__initWindowEventListener(eventName);
			me._windowListeners[eventName].push(fn);
		},
		
		_fireParentWindowEvent: function(eventName){ //eg: resize or scroll
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) return;
			var listeners = me._windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
		}
	});
}());
                /** this mixin is used to mess with the environment outside of the iframe that the rally app is put in. */
(function(){
	var Ext = window.Ext4 || window.Ext;

	var TOP_BAR_HEIGHT = 40,
		BOTTOM_BAR_HEIGHT = 24,
		BOTTOM_IFRAME_PADDING = 20,
		TITLE_BAR_HEIGHT = 33,
		IFRAME_HEADER_HEIGHT = 28;
		
	Ext.define('IframeResize', {
		requires: ['WindowListener'],
		
		_fixRallyDashboard: function(){ 
			/** makes app as large as screen, without the padding/margin */
			if(window && window.frameElement){
				var me=this,
					bottomEl = Ext.get(window.frameElement),
					portlet = bottomEl.up('.x-portlet'), 
					dashboard = portlet.up('#mydash_portlet'), //has huge padding values
					titleBar = dashboard.down('.titlebar'), //redundant with app header bar
					domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
					innerHeight = window.parent.innerHeight,
					innerWidth = window.parent.innerWidth;
				
				//adjust widths
				while(true){
					domNodeW.style.width = (innerWidth - 4) + 'px';
					domNodeW.style.padding = '0';
					domNodeW.style.margin = '0';
					if(domNodeW.id === 'mydash_portlet') break;
					domNodeW = domNodeW.parentNode;
				}
				
				//adjust heights
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT + IFRAME_HEADER_HEIGHT + BOTTOM_IFRAME_PADDING)) + 'px';
					if(domNodeH.classList.contains('x-portlet')) break;
					domNodeH = domNodeH.parentNode;
				}
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT)) + 'px';
					if(domNodeH.id == 'mydash_portlet') break;
					domNodeH = domNodeH.parentNode;
				}
				dashboard.dom.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT)) + 'px';
				
				//final touches LOL
				dashboard.dom.style.padding = "0 2px 0 2px";
				titleBar.dom.style.padding = "2px";
				titleBar.dom.style.margin = "0";
			}
		},		
		_initFixRallyDashboard: function(){ 
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
			}
			me._fixRallyDashboard();
		},

		_disableResizeHandle: function(){ 
			/** hides the draggable resize handle from under the app */
			var me=this, handle;
			if(window && window.frameElement){
				handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
				if(handle) {
					handle.hide();
					handle.dom.onshow = function(){ if(handle) handle.hide(); };
				}
			}
		},	
		_initDisableResizeHandle: function(){
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
			}
			me._disableResizeHandle();
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/**  
		THIS IS ONLY USEFUL AS A RALLYAPP MIXIN 
		gives a window-centered alert or confirm dialog box that isn't ugly. 
	*/
	Ext.define('PrettyAlert', {

		__getMessageBoxY: function(){ 
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.frameElement ? window.parent.getWindowHeight() : window.innerHeight,
				ps = window.frameElement ? window.parent.getScrollY() : window.scrollY,
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},
		
		_alert: function(title, message){
			var me=this;
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<1) return;
			if(arguments.length===1){
				message = title;
				title = '';
			}
			Ext.MessageBox.alert(title, message).setY(me.__getMessageBoxY());
			setTimeout(function(){ //give some time to give the 'ok' or 'yes' button focus
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 50);
		},
		
		_confirm: function(title, message, fn){
			var me=this;
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = message;
				message = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			Ext.MessageBox.confirm(title, message, fn).setY(me.__getMessageBoxY());
			setTimeout(function(){
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 20);
		}
	});
}());
                (function() {
	var Ext = window.Ext4 || window.Ext;
	
	var teamTypes = [
		'Analog DV', 'Array', 'BI', 'Binsplit',
		'Class TPI', 'CLK', 'EVG','Func Module',
		'Fuse', 'GT Module', 'HTD', 'MIO', 'MIO CLK',
		'MPV', 'PT', 'QRE Qual', 'Reliability', 'Scan',
		'SIO', 'SIO MIO CLK', 'Sort Class TPI', 'Sort TD',
		'Sort TPI', 'TVPV', 'Yield PHI'
	],
		// In English: matches a team type, maybe a number, a hyphen, a train name, and maybe a suffixed parenthetical
		// Remembers the team type, associated keywords, the number or '', and the train name
		// TODO: Fix this and make this faster
		teamInfoRegExp = /^([A-Za-z\s\-]*[A-Za-z])\s+(?:\([A-Za-z\d\s]+\))?\s*(\d*)\s*-\s+([A-Za-z\s]*[A-Za-z]).*$/,
		teamRegExp = /^[A-Za-z ]*[A-Za-z](?:\s\d)?\s-\s.+$/,
		keywordSplitRegExp = /[\s\-]+/;
	
	Ext.define('Teams', {
		_getTeamInfo: function(project) {
			var results = teamInfoRegExp.exec(project.data.Name),
				team = {};
			if (!results) {
				return null;
			}
			team.FullName = project.data.Name;
			team.Type = results[1];
			team.KeyWords = results[1].split(keywordSplitRegExp).concat('');
			team.Number = (results[2] !== '' ? parseInt(results[2], 10) : 1);
			team.Train = results[3];
			team.Name = team.Type + ' ' + team.Number;
			return team;
		},
		
		_createTeamInfoMap: function(teams) {
			var me = this,
				map = {},
				team;
			for (var i in teams) {
				map[teams[i].data.ObjectID] = {
					project: teams[i],
					info: me._getTeamInfo(teams[i])
				};
			}
			return map;
		},
		
		_isValidTeamProjectName: function(project) {
			return teamRegExp.test(project.data.Name) && project.data.Children.Count === 0;
		},
		
		_isValidTeamType: function(type) {
			return _.includes(teamTypes, type);
		},
		
		_filterProjectsByTeamType: function(projects, type) {
			var me = this,
				filter = new RegExp((!type || type === '' || type === 'All') ? '.*' : type),
				filteredProjects = {};
			for (var i in projects) {
				if (filter.test(projects[i].data.Name)) {
					filteredProjects[projects[i].data.ObjectID] = projects[i];
				}
			}
			return filteredProjects;
		},
		
		filterMapByTeamType: function(map, type) {
			var me = this,
				filter = new RegExp((!type || type === '' || type === 'All') ? '.*' : type),
				filteredProjects = {};
			for (var i in map) {
				if (filter.test(map[i].project.data.Name)) {
					filteredProjects[map[i].project.data.ObjectID] = map[i].project;
				}
			}
			return filteredProjects;
		}
	});
})();
                (function() {
	// TODO: Investigate use of single promise anonymous funcitons e.g.
	// Using then(me.{function name}) instead of then(funciton() {return me.{funciton name}})
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('ContinuousImprovementReport', {
		extend: 'IntelRallyApp',
		componentCls: 'app',
		mixins:[
			'WindowListener',
			'PrettyAlert',
			'IframeResize',
			'Teams'
		],
		// Commented out for large changeset
		/*items: [
			{
				xtype: 'container',
				id: 'controls-container',
				layout: 'column',
				items: [
					{
						xtype: 'container',
						id: 'general-controls-container',
						columnWidth: 0.49
					},
					{
						xtype: 'container',
						id: 'backlog-chart-controls-container',
						columnWidth: 0.49,
						layout: 'hbox'
					}
				]
			},
			{
				xtype: 'container',
				id: 'chart-container',
				items: [
					{
						xtype: 'container',
						id: 'state-chart-container',
						columnWidth: 0.24
					},
					{
						xtype: 'container',
						id: 'percentage-chart-container',
						columnWidth: 0.24
					},
					{
						xtype: 'container',
						id: 'backlog-chart-container',
						columnWidth: 0.49
					}
				],
				layout: 'column'
			},
			{
				xtype: 'container',
				id: 'grid-container'
			}
		],*/
		items: [
			{
				xtype: 'container',
				id: 'controls-container',
				layout: 'column',
				border: 1,
				style: {
					borderColor: 'black',
					borderStyle: 'solid'
				},
				items: [
					{
						xtype: 'container',
						id: 'general-controls-container',
						columnWidth: 0.14
					},
					{
						xtype: 'container',
						id: 'backlog-chart-controls-container',
						columnWidth: 0.84,
						layout: 'hbox'
					}
				]
			},
			{
				xtype: 'container',
				id: 'chart-and-grid-container',
				layout: 'column',
				items: [
					{
						xtype: 'container',
						id: 'chart-container',
						columnWidth: 0.5,
						padding: '0 10 0 0',
						items: [
							{
								xtype: 'container',
								id: 'backlog-chart-container'
							},
							{
								xtype: 'container',
								id: 'pie-chart-container',
								layout: 'column',
								items: [
									{
										xtype: 'container',
										id: 'state-chart-container',
										columnWidth: 0.5
									},
									{
										xtype: 'container',
										id: 'percentage-chart-container',
										columnWidth: 0.5
									}
								]
							}
						]
					},
					{
						xtype: 'container',
						id: 'grid-container',
						padding: '0 5 0 0',
						columnWidth: 0.49
					}
				]
			}
		],
		launch: function() {
			var me = this;
			me._initDisableResizeHandle();
			me._initFixRallyDashboard();
			me.setLoading('Loading configuration');
			me._configureIntelRallyApp()
			// Load scoped project
			.then (function() {
				me.isShowingAllReleases = false;
				var scopedProject = me.getContext().getProject();
				return me._loadProject(scopedProject.ObjectID);
			})
			// Get current release, team info, and load portfolio project
			.then(function(projectRecord) {
				me.Project = projectRecord;
			
				// Extract team info from current project
				me.Team = me._getTeamInfo(me.Project);
				if (!me.Team) {
					throw 'You must be scoped to a scrum';
				}
				console.log(me.Team);
				
				// Load release records
				return me._loadAllReleases(me.Project).then(function(releaseRecords) {
					me.ReleaseRecords = releaseRecords;
					return me._getScopedRelease(releaseRecords, me.Project.data.ObjectID, null);
				});
			})
			// Save current release then load the train portfolio project
			.then(function(release) {
				me.CurrentRelease = release;
				return me._loadProjectByName(me.Team.Train + ' POWG Portfolios');
			})
			// Get all products under the portfolio project
			.then(function(portfolioProject) {
				me.setLoading('Loading continuous improvement product');
				
				// Load all products
				return me._loadPortfolioItemsOfType(portfolioProject, 'Product');
			})
			// Extract only the continuous improvement product and load milestones under it
			.then(function(productStore) {
				var ciProduct,
					ciProductName = me.Team.Train + 'STDCI';
				
				// Find the continuous improvement product
				ciProduct = _.find(productStore.getRange(), function(p) {return p.data.Name === ciProductName;});
				
				// Load Milestones under the STDCI product
				return me._loadPortfolioChildren(ciProduct, 'Milestone');
			})
			// Load all features then stories under all milestones
			.then(function (milestoneStore) {
				me.Milestones = milestoneStore.getRange();
				console.log(me.Milestones);
				return me._loadStories();
			})
			// Load the UI
			.then(function() {
				return me._loadUI();
			})
			// Catch-all fail function
			.fail(function(reason) {
				me.setLoading(false);
				me._alert('Error', reason || 'error');
			})
			.done();
		},
		
		/*
		 *	Loads all UI components
		 */
		_loadUI: function() {
			var me = this;
			me.setLoading('Loading Visuals');
			
			// Load controls
			me.down('#backlog-chart-controls-container').removeAll();
			me._loadControls();
			
			// Load other UI components
			return me._loadCharts().then(function() {
				return me._loadGrid();
			}).then(function() {
				me.setLoading(false);
			});
		},
		
		/*
		 *	Loads all controls
		 */
		_loadControls: function() {
			var me = this;
		
			// Maintain state of checkbox
			if (!me.ReleaseCheck) me._loadReleaseCheck();
			
			// Load backlog chart controls only if showing backlog chart
			if (me.isShowingAllReleases) me._loadBacklogChartControls();
		},
		
		/*
		 *	Creates and adds all controls related to the backlog chart
		 */
		_loadBacklogChartControls: function() {
			if (this.Iterations.length === 0) return;
			var me = this,
				backlogControls = [],
				iterationStore = Ext.create('Rally.data.wsapi.Store', {
					autoLoad: false,
					data: me.Iterations,
					model: 'Iteration'
				}),
				iterationRadio = Ext.create('Ext.form.field.Radio', {
					id: 'iteration-radio-box',
					name: 'filter-type',
					boxLabel: 'Iteration',
					labelWidth: 50,
					checked: true,
					listeners: {
						change: me._backlogFilterTypeChanged,
						scope: me
					}
				}),
				dateRadio = Ext.create('Ext.form.field.Radio', {
					id: 'date-radio-box',
					name: 'filter-type',
					boxLabel: 'Date',
					labelWidth: 50,
					checked: false,
					listeners: {
						change: me._backlogFilterTypeChanged,
						scope: me
					}
				}),
				startIterationCombo = Ext.create('Rally.ui.combobox.ComboBox', {
					displayField: 'Name',
					id: 'start-iteration-combo-box',
					fieldLabel: 'Start:',
					labelWidth: 50,
					labelAlign: 'right',
					store: iterationStore,
					padding: '0 0 0 15',
					listeners: {
						select: me._rangeChanged,
						scope: me
					},
					value: me.Iterations[0],
					valueField: 'StartDate'
				}),
				endIterationCombo = Ext.create('Rally.ui.combobox.ComboBox', {
					displayField: 'Name',
					id: 'end-iteration-combo-box',
					fieldLabel: 'End:',
					labelWidth: 50,
					labelAlign: 'right',
					store: iterationStore,
					padding: '0 0 0 15',
					listeners: {
						select: me._rangeChanged,
						scope: me
					},
					value: me.Iterations[me.Iterations.length - 1],
					valueField: 'EndDate'
				}),
				startDatePicker = Ext.create('Rally.ui.DateField', {
					fieldLabel: 'Start:',
					labelAlign: 'right',
					labelWidth: 50,
					id: 'start-date-picker',
					padding: '0 0 0 15',
					listeners: {
						select: me._rangeChanged,
						scope: me
					},
					value: new Date(me.Iterations[0].data.StartDate)
				}),
				endDatePicker = Ext.create('Rally.ui.DateField', {
					fieldLabel: 'End:',
					labelAlign: 'right',
					labelWidth: 50,
					id: 'end-date-picker',
					padding: '0 0 0 15',
					listeners: {
						select: me._rangeChanged,
						scope: me
					},
					value: new Date(me.Iterations[me.Iterations.length - 1].data.EndDate)
				}),
				dataFieldsStore = Ext.create('Ext.data.Store', {
					fields: ['DisplayName', 'PropertyName'],
					data: [
						{DisplayName: 'Backlog Size', PropertyName: 'size'},
						{DisplayName: 'Added Stories', PropertyName: 'added'},
						{DisplayName: 'Accepted Stories', PropertyName: 'accepted'},
						{DisplayName: 'Backlog Delta', PropertyName: 'delta'}
					]
				}),
				dataFieldCombo = Ext.create('Ext.form.field.ComboBox', {
					store: dataFieldsStore,
					fieldLabel: 'Data:',
					labelAlign: 'right',
					labelWidth: 50,
					padding: '0 0 0 15',
					displayField: 'DisplayName',
					valueField: 'PropertyName',
					listeners: {
						select: me._dataFieldSelected,
						scope: me
					},
					value: 'size'
				});
			
			// Store controls in me for use in listeners
			me.IterationRadio = iterationRadio;
			me.DateRadio = dateRadio;
			me.StartIterationCombo = startIterationCombo;
			me.EndIterationCombo = endIterationCombo;
			me.StartDatePicker = startDatePicker;
			me.EndDatePicker = endDatePicker;
			me.DataFieldCombo = dataFieldCombo;
			
			// Set initial values used
			me.StartingIteration = me.Iterations[0];
			me.EndingIteration = me.Iterations[me.Iterations.length - 1];
			me.StartingDate = new Date(me.Iterations[0].data.StartDate);
			me.EndingDate = new Date(me.Iterations[me.Iterations.length - 1].data.EndDate);
			me.isFilteringByIteration = true;
			
			// Push all relevant controls onto array for efficient adding
			backlogControls.push(iterationRadio, dateRadio, startIterationCombo, endIterationCombo, dataFieldCombo);
			
			// Add components
			return me.down('#backlog-chart-controls-container').add(backlogControls);
		},
		
		/*
		 *	Fires when the data field is changed
		 */
		_dataFieldSelected: function() {
			var me = this;
			me._redrawBacklogChart();
		},
		
		/*
		 *	Fires when the filter type for the backlog chart is changed
		 *	NOTE: The chart DOES NOT need to be redrawn, as the values for the combo boxes will be set appropriately
		 */
		_backlogFilterTypeChanged: function() {
			var me = this,
				controlsContainer = me.down('#backlog-chart-controls-container');
			
			// Set the global variable
			me.isFilteringByIteration = me.IterationRadio.getValue();
			
			// Remove pickers and add other set
			if (me.isFilteringByIteration) {
				controlsContainer.remove(me.StartDatePicker, false);
				controlsContainer.remove(me.EndDatePicker, false);
				controlsContainer.remove(me.DataFieldCombo, false);
				controlsContainer.add(me.StartIterationCombo);
				controlsContainer.add(me.EndIterationCombo);
				controlsContainer.add(me.DataFieldCombo);
				
				me.StartIterationCombo.setValue(me.StartingIteration);
				me.EndIterationCombo.setValue(me.EndingIteration);
			}
			else {
				controlsContainer.remove(me.StartIterationCombo, false);
				controlsContainer.remove(me.EndIterationCombo, false);
				controlsContainer.remove(me.DataFieldCombo, false);
				controlsContainer.add(me.StartDatePicker);
				controlsContainer.add(me.EndDatePicker);
				controlsContainer.add(me.DataFieldCombo);
				
				me.StartDatePicker.setValue(me.StartingDate);
				me.EndDatePicker.setValue(me.EndingDate);
			}
		},
		
		/*
		 *	Fires when an iteration combo box is changed
		 */
		_rangeChanged: function() {
			var me = this;
			
			if (me.isFilteringByIteration) {
				me.StartingIteration = _.find(me.Iterations, function(iteration) {return iteration.data.StartDate == me.StartIterationCombo.getValue();});
				me.EndingIteration = _.find(me.Iterations, function(iteration) {return iteration.data.EndDate == me.EndIterationCombo.getValue();});
				me.StartingDate = new Date(me.StartingIteration.data.StartDate);
				me.EndingDate = new Date(me.EndingIteration.data.EndDate);
			}
			else {
				// TODO: Ending iteration is horribly wrong, gets one iteration ahead
				me.StartingIteration = _.find(me.Iterations, function(iteration) {return new Date(iteration.data.StartDate) >= me.StartDatePicker.getValue();});
				me.EndingIteration = _.findLast(me.Iterations, function(iteration) {return new Date(iteration.data.EndDate) <= me.EndDatePicker.getValue();});
				me.StartingDate = me.StartDatePicker.getValue();
				me.EndingDate = me.EndDatePicker.getValue();
			}
			
			me._redrawBacklogChart();
		},
		
		/*
		 *	Redraws the backlog chart using the new range and data field
		 */
		_redrawBacklogChart: function() {
			var me = this,
				dataField = me.DataFieldCombo.getValue(),
				data = me._filterBacklogPointsToRange(me._getBacklogChartData(dataField)),
				chartConfig = me._getBacklogChartConfig(data);
			
			// Remove old chart
			$('#backlog-chart-container').empty();
			
			// Add new chart
			$('#backlog-chart-container').highcharts(chartConfig);
			
			// Hide that pesky link
			me._hideHighchartsLink();
		},
		
		/*
		 *	Loads stories under features under the CI milestone
		 */
		_loadStories: function() {
			var me = this;
			me.setLoading('Loading stories');
			me.ReleaseFilter = me._getReleaseFilter();
			return me._loadFeaturesUnderMilestones(me.Milestones).then(function(featureStores) {
				return me._loadStoriesUnderFeatures(featureStores);
			});
		},
		
		/*
		 *	Loads all features under the given milestones
		 */
		_loadFeaturesUnderMilestones: function(milestones) {
			var me = this,
				featurePromises = [];

			// Create promise array for features
			for (var i in milestones) {
				featurePromises.push(me._loadPortfolioChildren(milestones[i], 'Feature', me.ReleaseFilter));
			}
			
			return Q.all(featurePromises);
		},
		
		/*
		 *	Loads all stories under the given features
		 */
		_loadStoriesUnderFeatures: function(featureStores) {
			var me = this,
				storyPromises = [];
			me.setLoading('Loading stories');
			
			// Create promise array for loading stories
			for (var i in featureStores) {
				var features = featureStores[i].getRange();
				console.log('Features', features);
				for (var j in features) {
					storyPromises.push(me._loadStoriesByFeature(features[j]));
				}
			}
			
			// Load stories then aggregate the data into one store
			return Q.all(storyPromises).then(function(storyStores) {
				me.StoryStore = Ext.create('Ext.data.Store', {
					autoLoad: false,
					model: me.UserStory,
					data: []
				});
				for (var i = 0; i < storyStores.length; i++) {
					me.StoryStore.add(storyStores[i].getRange());
				}
				me.StoryStore.sort('CreationDate', 'ASC');
				me.setLoading(false);
			});
		},
		
		/*
		 *	Gets a filter object for either all releases or just the current release
		 */
		_getReleaseFilter: function() {
			var me = this;
			if (me.isShowingAllReleases) {
				// TODO: This code just feels wrong, should replace it with something...not terrible
				return Ext.create('Rally.data.wsapi.Filter', {property: 'Name', operator: '!=', value: null});
			}
			else {
				// Filter to only current release
				return Ext.create('Rally.data.wsapi.Filter', {
					property: 'Release.Name',
					operator: '=',
					value: me.CurrentRelease.data.Name
				});
			}
		},
		
		/*
		 *	Loads direct children of a portfolio item of type
		 *	Filters by customFilter (if provided), a Filter object
		 */
		_loadPortfolioChildren: function(portfolioItem, type, customFilter) {
			var me = this,
				// Filters to children of portfolioItem
				parentFilter = Ext.create('Rally.data.wsapi.Filter', {property: 'Parent.ObjectID', operator: '=', value: portfolioItem.data.ObjectID}),
				// Combines with customFilter if present
				portfolioFilter = (!customFilter ? parentFilter : parentFilter.and(customFilter)),
				storeConfig = {
					model: me['PortfolioItem/' + type],
					fetch: ['Name', 'ObjectID', 'FormattedID', 'Release'],
					autoLoad: false,
					disableMetaChangeEvent: true,
					limit: Infinity,
					pageSize: 200,
					filters: [portfolioFilter],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					}
				};
			var store = Ext.create('Rally.data.wsapi.Store', storeConfig);
			
			return me._reloadStore(store);
		},
		
		/*
		 *	Loads all stories within a feature
		 */
		_loadStoriesByFeature: function(feature, customFilter) {
			var me = this,
				// Filters to children of feature
				featureFilter = Ext.create('Rally.data.wsapi.Filter', {property: 'Feature.ObjectID', operator: '=', value: feature.data.ObjectID}),
				// Filter for if customFilter is not provided
				standardFilter = featureFilter.and(me.ReleaseFilter),
				// Combined filter
				storyFilter = (!customFilter ? standardFilter : standardFilter.and(customFilter)),
				storeConfig = {
					model: me.UserStory,
					fetch: ['Name', 'ObjectID', 'FormattedID', 'Owner', 'Iteration', 'StartDate', 'EndDate', 'ScheduleState', 'Feature', 'PlanEstimate', 'AcceptedDate', 'CreationDate'],
					autoLoad: false,
					limit: Infinity,
					pageSize: 200,
					filters: [storyFilter],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: me.Project.data._ref
					}
				};
			var store = Ext.create('Rally.data.wsapi.Store', storeConfig);
			return me._reloadStore(store);
		},
		
		/*
		 *	Creates and adds checkbox for filtering to current release
		 */
		// TODO: Make this checkbox prettier (it's ugly and Spartan right now)
		_loadReleaseCheck: function() {
			var me = this;
			me.ReleaseCheck = Ext.create('Rally.ui.CheckboxField', {
				checked: false,
				fieldLabel: 'All releases: ',
				listeners: {
					change: me._releaseCheckboxChanged,
					scope: me
				}
			});
			me.down('#general-controls-container').add(me.ReleaseCheck);
		},
		
		/*
		 *	Fired when the checkbox for showing all releases is clicked
		 */
		_releaseCheckboxChanged: function(box, newVal, oldVal, opts) {
			var me = this;
			me.isShowingAllReleases = newVal;
			
			// Reload stories and UI
			me._removeAllComponents();
			if (me.isShowingAllReleases) {
				return me._loadStories().then(function() {
					return me._loadIterations();
				}).then(function() {
					return me._loadUI();
				});
			}
			else {
				return me._loadStories().then(function() {
					return me._loadUI();
				});
			}
		},
		
		/*
		 *	Removes all existing UI components, keeping containers intact
		 */
		_removeAllComponents: function() {
			var me = this;
			
			// Empty chart containers
			$('#state-chart-container').empty();
			$('#percentage-chart-container').empty();
			$('#backlog-chart-container').empty();
			
			// Completely destroy grid
			me.down('#grid-container').removeAll(true);
		},
		
		/*
		 *	Creates the state chart data object
		 */
		_getStateChartData: function() {
			var me = this,
				total = me.StoryStore.data.length,
				stateData = [
					{name: 'Undefined', y: 0, totalCount: total},
					{name: 'Defined', y: 0, totalCount: total},
					{name: 'In-Progress', y: 0, totalCount: total},
					{name: 'Completed', y: 0, totalCount: total},
					{name: 'Accepted', y: 0, totalCount: total}
				];
			
			// Create object for fast counting
			var stateCounts = {};
			_.forEach(stateData, function(datum, index) {
				stateCounts[datum.name] = stateData[index];
			});
			
			// Count number of user stories in each state category
			_.each(me.StoryStore.getRange(), function(story) {
				stateCounts[story.data.ScheduleState].y++;
			});
			
			// This is to maintain consistency with promises (sorry)
			return Q.fcall(function() {return stateData;});
		},
		
		/*
		 *	Creates the percentage chart data object
		 *	TODO: This should be highly optimizable
		 */
		_getPercentageChartData: function() {
			var me = this,
				percentageData = [
					{name: 'CI', y: me.StoryStore.data.length},
					{name: 'Non-CI', y: 0}
				],
				config = {
					autoLoad: false,
					limit: 1,
					model: me.UserStory,
					// "Get" nothing to make counting total results faster
					fetch: [],
					filters: [me.ReleaseFilter],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: me.Project.data._ref,
						projectScopeUp: false,
						projectScopeDown: true
					}
				},
				releaseStoryStore = Ext.create('Rally.data.wsapi.Store', config);
			return me._reloadStore(releaseStoryStore).then(function(store) {
				// Number of non-CI stories is total stories - CI stories
				percentageData[1].y = store.totalCount - percentageData[0].y;
				
				// Used for formatting
				percentageData[1].totalCount = percentageData[0].totalCount = store.totalCount;
				
				return percentageData;
			});
		},
		
		/*
		 *	Gets the filter for all relevant iterations
		 */
		_getIterationFilter: function() {
			var me = this,
				// Set to now, all dates guaranteed to be before
				firstDate = new Date(),
				// Set to minimum date
				lastDate = new Date(null),
				endsAfterFilter,
				startsBeforeFilter;
			
			// Find the extremes of dates
			_.each(me.StoryStore.getRange(), function(story) {
				var creationDate = new Date(story.data.CreationDate),
					acceptedDate = new Date(story.data.AcceptedDate),
					iterationStartDate = story.data.Iteration ? new Date(story.data.Iteration.StartDate) : new Date();
					iterationEndDate = story.data.Iteration ? new Date(story.data.Iteration.EndDate) : new Date(null);
				if (creationDate < firstDate) firstDate = creationDate;
				if (iterationStartDate < firstDate)firstDate = iterationStartDate;
				if (acceptedDate > lastDate) lastDate = acceptedDate;
				if (creationDate > lastDate) lastDate = creationDate;
				if (iterationEndDate > lastDate) lastDate = iterationEndDate;
			});
			
			// Create filters to narrow the time box of the iterations
			endsAfterFilter = Ext.create('Rally.data.wsapi.Filter', {
				property: 'EndDate',
				operator: '>=',
				value: firstDate.toISOString()
			});
			startsBeforeFilter = Ext.create('Rally.data.wsapi.Filter', {
				property: 'StartDate',
				operator: '<=',
				value: lastDate.toISOString()
			});
			
			return [endsAfterFilter, startsBeforeFilter];
		},
		
		/*
		 *	Loads all iterations referenced by the current set of user stories
		 */
		_loadIterations: function() {
			var me = this,
				filter = me._getIterationFilter();
			var store = Ext.create('Rally.data.wsapi.Store', {
				autoLoad: false,
				limit: Infinity,
				model: 'Iteration',
				pageSize: 200,
				fetch: ['ObjectID', 'Name', 'StartDate', 'EndDate'],
				filters: filter,
				// This is sorted to make charting it easy
				sorters: [
					{
						property: 'StartDate',
						direction: 'ASC'
					}
				],
				context: {
					workspace: me.getContext().getWorkspace(),
					project: me.getContext().getProject()._ref,
					projectScopeUp: false,
					projectScopeDown: false
				}
			});
			
			return me._reloadStore(store).then(function(iterationStore) {
				me.Iterations = iterationStore.getRange();
			});
		},
		
		/*
		 *	Gets a filtered subset of data for the backlog chart
		 */
		_filterBacklogPointsToRange: function(points) {
			var me = this,
				rangeStartDate,
				rangeEndDate,
				startIndex = 0,
				endIndex = points.length - 1;
				
			// Set the appropriate date range
			if (me.isFilteringByIteration) {
				rangeStartDate = new Date(me.StartingIteration.data.StartDate);
				rangeEndDate = new Date(me.EndingIteration.data.EndDate);
			}
			else {
				rangeStartDate = me.StartingDate;
				rangeEndDate = me.EndingDate;
			}
			
			// Find start and stop indexes
			while (startIndex < points.length && points[startIndex].startDate < rangeStartDate) {
				startIndex++;
			}
			while (endIndex >= 0 && points[endIndex].endDate > rangeEndDate) {
				endIndex--;
			}
			
			return points.slice(startIndex, endIndex + 1);
		},
		
		/*
		 *	Creates the backlog chart data object
		 */
		_getBacklogChartData: function(field) {
			var me = this,
				backlogData = [],
				storyTotal = 0,
				dataField = field || 'size',
				iterationNameRegExp = /^Q\d+_s\d+/;
			// Create data objects for all iterations for the deltas and the totals
			_.each(me.Iterations, function(iteration) {
				var iterationStartDate = new Date(iteration.data.StartDate),
					iterationEndDate = new Date(iteration.data.EndDate);
				backlogData.push({
					name: iteration.data.Name.match(iterationNameRegExp)[0],
					delta: 0,
					added: 0,
					accepted: 0,
					size: 0,
					startDate: iterationStartDate,
					endDate: iterationEndDate,
					y: 0,
					createdStories: [],
					acceptedStories: [],
					backloggedStories: []
				});
			});
			
			// Calculate stories added, accepted, and delta per iteration
			_.each(me.StoryStore.getRange(), function(story) {
				var storyCreationDate = new Date(story.data.CreationDate),
					storyAcceptedDate = new Date(story.data.AcceptedDate);
					
				// Accounts for stories written before planned iterations
				if (storyCreationDate < backlogData[0].startDate) storyTotal++;
				if (story.data.AcceptedDate && storyAcceptedDate < backlogData[0].startDate) storyTotal--;
				
				for (var i in backlogData) {
					if (storyCreationDate <= backlogData[i].endDate && (!story.data.AcceptedDate || storyAcceptedDate > backlogData[i].endDate)) {
						backlogData[i].backloggedStories.push(story);
					}
					if (storyCreationDate >= backlogData[i].startDate && storyCreationDate <= backlogData[i].endDate) {
						backlogData[i].added++;
						backlogData[i].delta++;
						backlogData[i].createdStories.push(story);
					}
					if (story.data.AcceptedDate && storyAcceptedDate >= backlogData[i].startDate && storyAcceptedDate <= backlogData[i].endDate) {
						backlogData[i].accepted++;
						backlogData[i].delta--;
						backlogData[i].acceptedStories.push(story);
					}
				}
			});
			
			// Calculate backlog count at each iteration end
			for (var j in backlogData) {
				storyTotal += backlogData[j].delta;
				backlogData[j].size = storyTotal;
				backlogData[j].y = backlogData[j][dataField];
			}
			
			me.BacklogData = backlogData;
			
			return backlogData;
		},
		
		/*
		 *	Creates a new data set from the old using a different property
		 */
		_extractData: function(originalData, yPropertyName, otherPropertyNames) {
			var data = [];
			for (var i in originalData) {
				var point = {y: originalData[i][yPropertyName]};
				for (var j in otherPropertyNames) {
					point[otherPropertyNames[j]] = originalData[i][otherPropertyNames[j]];
				}
				data.push(point);
			}
			
			return data;
		},
		
		/*
		 *	Creates the config object for the state chart
		 */
		_getStateChartConfig: function(data) {
			var me = this;
			return {
				chart: {
					height:(me.getHeight() > 1100) ? (me.getHeight()*0.32 >> 0) : (me.getHeight()*0.45),
					width: (me.getWidth()/4 >> 0),
					plotBackgroundColor: null,
					plotBorderWidth: 0,
					plotShadow: false
				},
				title: {text: 'Story States'},
				tooltip: {enabled: false},
				plotOptions: {
					pie: {
						dataLabels: {
							enabled: true,
							distance:25,
							crop:false,
							overflow:'none',
							formatter: function(){
								var str = '<b>' + this.point.name + '</b>: ' + this.point.y;
								return str;
							},
							style: { 
								cursor:'pointer',
								color: 'black'
							}
						}
					}
				},
				series: [{
					type: 'pie',
					name: 'States',
					innerSize: '25%',
					size: 175,
					data: data
				}]
			};
		},
		
		/*
		 *	Creates the config object for the percentage chart
		 */
		_getPercentageChartConfig: function(data) {
			var me = this;
			return {
				chart: {
					height: (me.getHeight() > 1100) ? (me.getHeight()*0.32 >> 0) : (me.getHeight()*0.45),
					width: (me.getWidth()/4 >> 0),
					plotBackgroundColor: null,
					plotBorderWidth: 0,
					plotShadow: false
				},
				title: {text: 'CI Story Percentage'},
				tooltip: {enabled: false},
				plotOptions: {
					pie: {
						dataLabels: {
							enabled: true,
							distance:25,
							crop:false,
							overflow:'none',
							formatter: function(){
								return '<b>' + this.point.name + '</b>: ' + (this.point.y/this.point.totalCount*100).toFixed(1) + '%';
							},
							style: { 
								cursor:'pointer',
								color: 'black'
							}
						}
					}
				},
				series: [{
					type: 'pie',
					name: 'Percentages',
					innerSize: '25%',
					size: 175,
					data: data
				}]
			};
		},
		
		_loadIterationBreakdown: function(e) {
			var point = e.point,
				me = this,
				breakdownContainer = Ext.create('Ext.container.Container', {
					id: 'breakdown-container',
					items: [
						{
							xtype: 'button',
							text: 'Close Breakdown',
							listeners: {
								click: function() {
									me.down('#breakdown-container').destroy();
									me.down('#storygrid').show();
								}
							}
						},
						{
							xtype: 'rallygrid',
							title: 'Backlogged Stories',
							columnCfgs: [
								'FormattedID',
								'Name',
								'Owner'
							],
							pagingToolbarCfg: {
								pageSizes: [5, 10],
								autoRender: true,
								resizable: false
							},
							store: Ext.create('Rally.data.custom.Store', {
								model: me.UserStory,
								autoLoad: false,
								data: point.backloggedStories,
								pageSize: 5
							})
						},
						{
							xtype: 'rallygrid',
							title: 'Created Stories',
							columnCfgs: [
								'FormattedID',
								'Name',
								'Owner'
							],
							pagingToolbarCfg: {
								pageSizes: [5, 10],
								autoRender: true,
								resizable: false
							},
							store: Ext.create('Rally.data.custom.Store', {
								model: me.UserStory,
								autoLoad: false,
								data: point.createdStories,
								pageSize: 5
							})
						},
						{
							xtype: 'rallygrid',
							title: 'Accepted Stories',
							columnCfgs: [
								'FormattedID',
								'Name',
								'Owner'
							],
							pagingToolbarCfg: {
								pageSizes: [5, 10],
								autoRender: true,
								resizable: false
							},
							store: Ext.create('Rally.data.custom.Store', {
								model: me.UserStory,
								autoLoad: false,
								data: point.acceptedStories,
								pageSize: 5
							})
						}
					]
				});
			
			me.down('#storygrid').hide();
			if (me.down('#breakdown-container')) me.down('#breakdown-container').destroy();
			me.down('#grid-container').add(breakdownContainer);
		},
		
		/*
		 *	Creates the config object for the backlog chart
		 */
		_getBacklogChartConfig: function(data) {
			var me = this;
			return {
				chart: {
					height: (me.getHeight() > 1100) ? (me.getHeight()*0.64 >> 0) : (me.getHeight()*0.5),
					// width: (me.getWidth()/2 >> 0),
					plotBackgroundColor: null,
					plotBorderWidth: 0,
					plotShadow: false
				},
				title: {text: 'CI Story Backlog'},
				tooltip: {enabled: true},
				series: [
					{
						type: 'column',
						name: 'Backlog Over Time',
						data: data,
						tooltip: {
							pointFormatter: function() {
								return '<b><u>Iteration Information:</u></b><br>' + 
									'Backlog Size: ' + this.size + '<br>' +
									'Stories Added: ' + this.added + '<br>' +
									'Stories Accepted: ' + this.accepted + '<br>' +
									'Backlog Delta: ' + this.delta + '<br>';
							}
						},
						events: {
							click: me._loadIterationBreakdown.bind(me)
						}
					}
				],
				yAxis: {
					tickInterval: 2,
					title: {
						text: '# Stories'
					}
				},
				xAxis: {
					title: {
						text: 'Iteration'
					},
					type: 'category'
				}
			};
		},
		
		/*
		 *	Hides the link for Highcharts
		 */
		_hideHighchartsLink: function() {
			$('.highcharts-container > svg > text:last-child').hide();
		},
		
		/*
		 *	Creates the config object for the user story grid
		 */
		_getGridConfig: function() {
			var me = this;
			return {
				id: 'storygrid',
				title: 'Team Continuous Improvement Stories',
				store: Ext.create('Rally.data.custom.Store', {
					autoLoad: false,
					model: me.UserStory,
					data: me.StoryStore.getRange(),
					pageSize: (me.getHeight() > 1100 ? 25 : 10)
					
				}),
				sortableColumns: true,
				pagingToolbarCfg: {
					pageSizes: [10, 15, 25, 100],
					autoRender: true,
					resizable: false
				},
				columnCfgs: [
					'FormattedID',
					'Name',
					'Owner',
					'Iteration',
					'ScheduleState',
					{
						text: 'Days Unaccepted',
						editor: false,
						renderer:function(val, meta, record){
							var day = 1000*60*60*24;
							return ((record.data.AcceptedDate ? new Date(record.data.AcceptedDate) : new Date()) - new Date(record.data.CreationDate).getTime())/day>>0;
						}
					}
				]
			};
		},
		
		/*
		 *	Loads and adds charts
		 */
		_loadCharts: function() {
			var me = this,
				promises = [
					me._getStateChartData(),
					me._getPercentageChartData()
				];
			if (me.isShowingAllReleases) promises.push(me._getBacklogChartData());
			
			return Q.all(promises).then(function(data) {
				// Add charts
				if (me.isShowingAllReleases) $('#backlog-chart-container').highcharts(me._getBacklogChartConfig(data[2]));
				$('#state-chart-container').highcharts(me._getStateChartConfig(data[0]));
				$('#percentage-chart-container').highcharts(me._getPercentageChartConfig(data[1]));
				
				// Hide that pesky link
				me._hideHighchartsLink();
				
				// TODO: Not sure what to return here
				return 0;
			});
		},
		
		/*
		 *	Loads and adds user story grid
		 */
		_loadGrid: function() {
			var me = this,
				gridConfig = me._getGridConfig();
			me.StoryGrid = Ext.create('Rally.ui.grid.Grid', gridConfig);
			return me.down('#grid-container').add(me.StoryGrid);
		}
	});
})();

            Rally.launchApp('ContinuousImprovementReport', {
                name:"Continuous Improvement Report",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .x-grid-cell.intel-editor-cell *,
.x4-grid-cell.intel-editor-cell *,
.intel-editor-cell {
  cursor: pointer !important;
}
.fa.fa-md {
  font-size: 1.05rem;
  line-height: .75em;
  vertical-align: -15%;
}

    </style>

    <style type="text/css">
        .app {
  /* Add app styles here */
}

    </style>
</head>
<body>
</body>
</html>
