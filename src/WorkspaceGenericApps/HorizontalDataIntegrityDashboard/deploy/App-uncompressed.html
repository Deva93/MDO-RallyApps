<!DOCTYPE html>
<html>
<head>
    <title>Data Integrity Dashboard</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.js"></script>
    <script type="text/javascript" src="https://code.highcharts.com/highcharts.src.js"></script>
    <script type="text/javascript" src="https://code.highcharts.com/modules/heatmap.src.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/sprintf/1.0.1/sprintf.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** this extends Rally.app.app. if you want to use it's utility functions, just
		extend IntelRallyApp instead of Rally.app.App
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	//increase timeouts to 2 minutes since rally can be slow sometimes
	var timeout = 120000;
	Ext.override(Ext.data.proxy.Ajax, { timeout: timeout });
	Ext.override(Ext.data.proxy.JsonP, { timeout: timeout });
	
	//rally's built-in jsonpproxy does not handle timeouts
	Ext.override(Rally.sdk.data.lookback.JsonPProxy, {
		setException: function(operation, response){
			var error = operation.getError() || {};
			operation.setException(Ext.apply(error, {
				errors:(response || {}).Errors || []
			}));
		}
	});
				
	Ext.define('IntelRallyApp', {
		alias: 'widget.intelrallyapp',
		extend: 'Rally.app.App',
		
		_ScrumGroupConfigPrefName: 'intel-portfolio-locations-config', //preference to store portfolio locations config for workspace
		
		_projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
		_portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'Release','c_TeamCommits', 'c_MoSCoW', 
			'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal'],
		_userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
			'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
		_releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
		
		/********************************************** APP CONFIGURATION **************************************/
		_loadScheduleStates: function(){ 
			var me=this, deferred = Q.defer();
			Rally.data.ModelFactory.getModel({
				type: 'UserStory',
				success: function(model) {
					model.getField('ScheduleState').getAllowedValueStore().load({
						callback: function(records, operation, success) {
							me.ScheduleStates = _.map(records, function(r){ return r.data.StringValue; });
							deferred.resolve();
						}
					});
				}
			});
			return deferred.promise;
		},
		_loadPortfolioItemStatesForEachType: function(){ 
			var me=this;
			me.PortfolioItemTypeStates = [];
			return Q.all(_.map(me.PortfolioItemTypes, function(portfolioType, ordinal){
				var store = Ext.create('Rally.data.wsapi.Store', {
					model: 'State',
					autoLoad:false,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Name', 'Enabled', 'OrderIndex'],
					filters: [{
						property: 'TypeDef.Name',
						value: portfolioType
					},{
						property: 'Enabled',
						value: true
					}]
				});
				return me._reloadStore(store).then(function(store){
					me.PortfolioItemTypeStates[ordinal] = store.getRange();
				});
			}));
		},
		_loadPortfolioItemTypes: function(){ 
			/** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
			var me=this,
				deferred = Q.defer(),
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'TypeDefinition',
					autoLoad:true,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					listeners:{
						load:function(portfolioTypeStore){
							me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(), 
								function(item){ return {Name: item.data.Name, Ordinal: item.data.Ordinal}; }),
								function(item){ return item.Ordinal; }),
								function(item){ return item.Name; });
							deferred.resolve();
						}
					}
				});
			return deferred.promise;
		},
		_loadModels: function(){ 
			/** loads models for project, userstories, and all the portfolio items */
			var me=this, 
				promises = [],
				models = {
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					PortfolioItem: 'PortfolioItem'
				};
			_.each(me.PortfolioItemTypes, function(name){ models['PortfolioItem/' + name] = 'PortfolioItem/' + name; });
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},
		_loadScrumGroupConfig: function(){
			/** scrum-groups are groups of scrums that share the same portfolio. The group of scrums may or may not be a train */
			/** me.ScrumGroupConfig is an array of these objects: 
				{
					ScrumGroupRootProjectOID: configItem.ScrumGroupRootProjectOID || 0,
					ScrumGroupName: configItem.ScrumGroupName || '',
					ScrumGroupAndPortfolioLocationTheSame: configItem.ScrumGroupAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0,
					IsTrain: configItem.IsTrain ? true : false
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._ScrumGroupConfigPrefName,
				success: function(prefs) {
					var configString = prefs[me._ScrumGroupConfigPrefName], scrumGroupConfig;
					try{ scrumGroupConfig = JSON.parse(configString); }
					catch(e){ scrumGroupConfig = []; }
					me.ScrumGroupConfig = scrumGroupConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveScrumGroupConfig: function(scrumGroupConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[me._ScrumGroupConfigPrefName] = JSON.stringify(scrumGroupConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: me._ScrumGroupConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_configureIntelRallyApp: function(){
			var me=this;
			me.BaseUrl = Rally.environment.getServer().getBaseUrl(); //is "" when in custom app iframe
			return Q.all([
				me._loadPortfolioItemTypes().then(function(){ 
					me._userStoryFields.push(me.PortfolioItemTypes[0]);  //HOLY PROGRAM BOARD BUG, BATMAN! (me._isUserStoryInRelease false for those who: (release == null && portfolioItrem.release.name == me.ReleaseRecord.data.Name)).
					return Q.all([
						me._loadModels(),
						me._loadPortfolioItemStatesForEachType()
					]);
				}),
				me._loadScrumGroupConfig(),
				me._loadScheduleStates()
			]);
		},
				
		/**************************** Generic store loading with Q wrapper, returns promise *************************************/		
		_reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		},
		
		/********************************************** LOADING SINGLE MODELS **************************************/	
		_loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LP');
			else if(!me.Project) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.Project.load(oid, {
					fetch: me._projectFields,
					context: { 
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadUserStory: function(oid, projectRecord){
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: LUS');
			else if(!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.UserStory.load(oid, {
					fetch: me._userStoryFields,
					context: {
						workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
						project: projectRecord ? projectRecord.data._ref : null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByType: function(oid, type){
			var me = this, deferred = Q.defer();
			if(!oid || !type) return Q.reject('Invalid arguments: LPIBT');
			else {
				me[type].load(oid, {
					fetch: me._portfolioItemFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadPortfolioItemByOrdinal: function(oid, ordinal){
			var me = this, deferred = Q.defer(),
				type = me.PortfolioItemTypes[ordinal];
			return me._loadPortfolioItemByType(oid, type);
		},	
		
		/**************************************** ScrumGroup Funcs ***************************************************/
		_projectInWhichScrumGroup: function(projectRecord){ 
			/** returns scrumgroup the projectRecord is in, otherwise null. */
			if(!projectRecord) return Q();
			else {
				var me=this,
					foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
						return scrumGroupConfig.ScrumGroupRootProjectOID == projectRecord.data.ObjectID; 
					});
				if(foundScrumGroupConfig) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q();
					else {
						return me._loadProject(parent.ObjectID).then(function(parentRecord){
							return me._projectInWhichScrumGroup(parentRecord);
						});
					}
				}
			}
		},
		_loadScrumGroupPortfolioProject: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) return Q.reject('Invalid arguments: _loadScrumGroupPortfolioProject');
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) return Q.reject('Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum group!');
			if(foundScrumGroupConfig.ScrumGroupAndPortfolioLocationTheSame) return Q(scrumGroupRootProjectRecord);
			else return me._loadProject(foundScrumGroupConfig.PortfolioProjectOID);
		},
		_getScrumGroupName: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) throw 'Invalid arguments: _getScrumGroupName';
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) throw 'Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum-group!';
			if(foundScrumGroupConfig.ScrumGroupName) return foundScrumGroupConfig.ScrumGroupName;
			else return scrumGroupRootProjectRecord.data.Name;
		},
		_loadAllScrumGroups: function(){
			var me=this,
				filter = _.reduce(me.ScrumGroupConfig, function(filter, scrumGroupConfig){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', { property:'ObjectID', value: scrumGroupConfig.ScrumGroupRootProjectOID });
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			if(!filter) return Q([]);
			else {
				var store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._projectFields,
					filters:[filter],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
				return me._reloadStore(store).then(function(store){ return store.getRange(); });
			}
		},
		
		/**************************************** UserStory Funcs ************************************************/
		__getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ 
			/** only pull look at PortfolioItem Release if US.Release == null */
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property: lowestPortfolioItem + '.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property: lowestPortfolioItem + '.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		_loadRandomUserStory: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: LRUS');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: false,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{ 
						property:'Project.ObjectID', 
						value: projectRecord.data.ObjectID 
					}]
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadRandomUserStoryFromReleaseTimeframe: function(projectRecord, releaseRecord){
			if(!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: LRUSFR');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					disableMetaChangeEvent: true,
					fetch: me._userStoryFields,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project.ObjectID', value: projectRecord.data.ObjectID }).and(
						me.__getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me._reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		_loadUserStoryByFID: function(formattedID, projectRecord){
			if(!formattedID || !projectRecord) return Q.reject('Invalid arguments: LUSBFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		
		/**************************************** PortfolioItem Funcs ************************************************/
		_loadPortfolioItemsOfType: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: OPIOT');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					disableMetaChangeEvent: true,
					remoteSort:false,
					fetch: me._portfolioItemFields,
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store);
		},		
		_loadPortfolioItemsOfOrdinal: function(portfolioProject, ordinal){
			if(!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: LPIOO');
			var me=this, type = me.PortfolioItemTypes[ordinal];
			if(type) return me._loadPortfolioItemsOfType(portfolioProject, type);
			else return Q.reject('Invalid PortfolioItem ordinal');
		},
		_portfolioItemTypeToOrdinal: function(type){
			return this.PortfolioItemTypes.indexOf(type);
		},
		_getPortfolioItemTypeStateByOrdinal: function(ordinal, stateName){
			return _.find(this.PortfolioItemTypeStates[ordinal], function(state){ return state.data.Name == stateName; });
		},
		_getPortfolioItemTypeStateByName: function(portfolioType, stateName){
			return this._getPortfolioItemTypeStateByOrdinal(this._portfolioItemTypeToOrdinal(portfolioType), stateName);
		},
		
		/********************************************** Project Funcs ********************************************/
		/****************************** THESE DO NOT WORK WITH sdk 2.0. USE SDK 2.0rc3 *******************/
		__storeItemsToProjTree: function(projects){
			var me=this, projTree = {};
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			return projTree;
		},
		_loadAllProjects: function(){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				var map = _.reduce(store.getRange(), function(map, project){
					map[project.data.ObjectID] = project;
					return map;
				}, {});
				return map;
			});	
		},
		__addProjectsWithTeamMembersToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
			}
		},	
		_loadProjectsWithTeamMembers: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				projectsWithTeamMembers = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
					return projectsWithTeamMembers;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.TeamMembers.Count > 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},	
		__allChildProjectToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_loadAllChildrenProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				childrenProjects = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
					return childrenProjects;
				} else {
					return _.reduce(store.getRange(), function(map, project){
						map[project.data.ObjectID] = project;
						return map;
					}, {});
				}
			});
		},	
		__allLeafProjectsToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me.__allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		_loadAllLeafProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				leafProjects = {}, 
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me._projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me.__storeItemsToProjTree(store.getRange());
					me.__allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
					return leafProjects;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.Children.Count === 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},
		_loadProjectByName: function(projectName){
			if(!projectName) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [{
						property:'Name',
						value:projectName
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** Release loading ********************************************/	
		_loadAllReleases: function(projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesBeforeGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					disableMetaChangeEvent: true,
					fetch: me._releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'<=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesBetweenDates: function(projectRecord, startDate, endDate){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit: Infinity,
					autoLoad:false,
					fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					},{
						property:'ReleaseDate',
						operator:'>',
						value: new Date(startDate).toISOString()
					},{
						property:'ReleaseStartDate',
						operator:'<',
						value: new Date(endDate).toISOString()
					}]
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_loadReleasesInTheFuture: function(projectRecord){
			return this._loadReleasesAfterGivenDate(projectRecord, new Date());
		},
		_loadReleasesByNameUnderProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					}],
					context:{
						project:projectRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		_loadReleaseByNameForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		_loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me._releaseFields,
					filters:[{
						property:'Name',
						operator:'contains',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me._reloadStore(store).then(function(store){ return store.getRange(); });
		},
		_getScopedRelease: function(releaseRecords, projectOID, appPrefs){			
			/** gets the most likely release to scope to base on the following order:
				1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
								to use preferences for this one)
				2) if we are currently in one of the releases
				3) the closest release planning date to the current date
			*/
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate)*1, d2 = new Date(r.data.ReleaseStartDate)*1, now = new Date()*1;
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
		/************************* MODEL FOR WORKWEEK DROPDOWNS *********************************************/
	Ext.define('WorkweekDropdown', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Workweek', type:'string'},
			{name: 'DateVal', type:'number'}
		]
	});
		
	/************************* USED FOR WORKSPACE TRAIN CONFIG *********************************************/
	Ext.define('TrainConfigItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'TrainProjectOID', type: 'number'},
			{name: 'TrainName', type: 'string'},
			{name: 'TrainAndPortfolioLocationTheSame', type:'boolean'},
			{name: 'PortfolioProjectOID', type:'number'}
		]
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
		/** this is used if you want to listen to events in the parent window (e.g. useful for rally apps that resize with browser screen
			vertically or things that need to know browser scroll position) 
		You also can artificially fire the events and have the listeners run
	*/
	Ext.define('WindowListener', {

		__initWindowEventListener: function(eventName){
			var me=this;
			if(!me._windowListeners) me._windowListeners = {};
			me._windowListeners[eventName] = [];
			
			window.parent['on' + eventName] = function(event){ 
				var listeners = me._windowListeners[eventName];
				for(var i=0, len=listeners.length; i<len; ++i)
					listeners[i](event);
			};
		},
		
		_addWindowEventListener: function(eventName, fn){
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) 
				me.__initWindowEventListener(eventName);
			me._windowListeners[eventName].push(fn);
		},
		
		_fireParentWindowEvent: function(eventName){ //eg: resize or scroll
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) return;
			var listeners = me._windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
		}
	});
}());
                /** this mixin is used to mess with the environment outside of the iframe that the rally app is put in. */
(function(){
	var Ext = window.Ext4 || window.Ext;

	var TOP_BAR_HEIGHT = 40,
		BOTTOM_BAR_HEIGHT = 24,
		BOTTOM_IFRAME_PADDING = 20,
		TITLE_BAR_HEIGHT = 33,
		IFRAME_HEADER_HEIGHT = 28;
		
	Ext.define('IframeResize', {
		requires: ['WindowListener'],
		
		_fixRallyDashboard: function(){ 
			/** makes app as large as screen, without the padding/margin */
			if(window && window.frameElement){
				var me=this,
					bottomEl = Ext.get(window.frameElement),
					portlet = bottomEl.up('.x-portlet'), 
					dashboard = portlet.up('#mydash_portlet'), //has huge padding values
					titleBar = dashboard.down('.titlebar'), //redundant with app header bar
					domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
					innerHeight = window.parent.innerHeight,
					innerWidth = window.parent.innerWidth;
				
				//adjust widths
				while(true){
					domNodeW.style.width = (innerWidth - 4) + 'px';
					domNodeW.style.padding = '0';
					domNodeW.style.margin = '0';
					if(domNodeW.id === 'mydash_portlet') break;
					domNodeW = domNodeW.parentNode;
				}
				
				//adjust heights
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT + IFRAME_HEADER_HEIGHT + BOTTOM_IFRAME_PADDING)) + 'px';
					if(domNodeH.classList.contains('x-portlet')) break;
					domNodeH = domNodeH.parentNode;
				}
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT)) + 'px';
					if(domNodeH.id == 'mydash_portlet') break;
					domNodeH = domNodeH.parentNode;
				}
				dashboard.dom.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT)) + 'px';
				
				//final touches LOL
				dashboard.dom.style.padding = "0 2px 0 2px";
				titleBar.dom.style.padding = "2px";
				titleBar.dom.style.margin = "0";
			}
		},		
		_initFixRallyDashboard: function(){ 
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
			}
			me._fixRallyDashboard();
		},

		_disableResizeHandle: function(){ 
			/** hides the draggable resize handle from under the app */
			var me=this, handle;
			if(window && window.frameElement){
				handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
				if(handle) {
					handle.hide();
					handle.dom.onshow = function(){ if(handle) handle.hide(); };
				}
			}
		},	
		_initDisableResizeHandle: function(){
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
			}
			me._disableResizeHandle();
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/**  
		THIS IS ONLY USEFUL AS A RALLYAPP MIXIN 
		gives a window-centered alert or confirm dialog box that isn't ugly. 
	*/
	Ext.define('PrettyAlert', {

		__getMessageBoxY: function(){ 
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.frameElement ? window.parent.getWindowHeight() : window.innerHeight,
				ps = window.frameElement ? window.parent.getScrollY() : window.scrollY,
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},
		
		_alert: function(title, message){
			var me=this;
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<1) return;
			if(arguments.length===1){
				message = title;
				title = '';
			}
			Ext.MessageBox.alert(title, message).setY(me.__getMessageBoxY());
			setTimeout(function(){ //give some time to give the 'ok' or 'yes' button focus
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 50);
		},
		
		_confirm: function(title, message, fn){
			var me=this;
			message = (typeof message === 'string') ? message : 
								(message.message ? message.message : 
								JSON.stringify(message, null, '\t'));
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = message;
				message = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			Ext.MessageBox.confirm(title, message, fn).setY(me.__getMessageBoxY());
			setTimeout(function(){
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 20);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;

	var intel_ww = {},
		SECOND = 1000,
		MINUTE = 60*SECOND,
		HOUR = 60*MINUTE,
		DAY = 24*HOUR,
		WEEK = 7*DAY;
		
	Ext.define('IntelWorkweek', {
		/** 
			intel workweek utility module. you can pass in Date objects, strings, or numbers.
			do not pass in Unix UTC millis though, or you will get wrong answer (eg: dont use Date.UTC(...))
		**/
		
		/** calculates intel workweek, returns integer */
		_getWorkweek: function(_date){  //ww1 always contains jan 1st
			var date = new Date(_date),
				yearStart = new Date(date.getFullYear(), 0, 1),
				dayIndex = yearStart.getDay(),
				ww01Start = new Date(yearStart - dayIndex*DAY),
				utcDateMillis = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
				ww01Millis = Date.UTC(ww01Start.getFullYear(), ww01Start.getMonth(), ww01Start.getDate()),
				timeDiff = utcDateMillis - ww01Millis,
				ww = Math.floor(timeDiff/WEEK) + 1,
				leap = (date.getFullYear() % 4 === 0),
				weekCount = ((leap && dayIndex >= 5) || (!leap && dayIndex === 6 )) ? 53 : 52; //weeks in this year
			return weekCount < ww ? 1 : ww;
		},
		
		/** returns the number of intel workweeks in the year the date is in */
		_getWeekCount: function(_date){  // # of intel workweeks in the year the date is in
			var date = new Date(_date),
				leap = (date.getFullYear() % 4 === 0),
				day = new Date(date.getFullYear(), 0, 1).getDay();
			return ((leap && day >= 5) || (!leap && day === 6 )) ? 53 : 52;
		},
		
		_roundDateDownToWeekStart: function(_date){
			var date = new Date(_date),
				day = date.getDay(),
				monthDate = date.getDate(),
				month = date.getMonth(),
				year = date.getFullYear(),
				sundayMidday = new Date(new Date(year, month, monthDate)*1 - (day*DAY - 0.5*DAY)); //daylight savings ._.
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/**  gets list of date numbers for each week start between start and end date*/
		_getWorkweekDates: function(startDate, endDate){ //gets list of dates for each week. INCLUSIVE
			var startWeekDate = this._roundDateDownToWeekStart(startDate),
				endWeekDate = this._roundDateDownToWeekStart(endDate),
				startMillis = Date.UTC(startWeekDate.getFullYear(), startWeekDate.getMonth(), startWeekDate.getDate()),
				endMillis = Date.UTC(endWeekDate.getFullYear(), endWeekDate.getMonth(), endWeekDate.getDate()),
				totalWeeks = Math.floor((endMillis - startMillis) / WEEK)+1,
				weeks = new Array(totalWeeks);
			for(var i=0; i<totalWeeks; ++i) {
				var sundayMidday = new Date(startWeekDate*1 + (WEEK*i + HOUR*12));
				weeks[i] = new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
			}
			return weeks;
		},
		
		_workweekToDate: function(ww, year){ //gets the Date() object of this ww and year
			var yearStart = new Date(year, 0, 1),
				dayIndex = yearStart.getDay(),
				ww01StartMidday = new Date(yearStart - (dayIndex*DAY - 0.5*DAY)),
				sundayMidday = new Date(ww01StartMidday*1 + (ww-1)*WEEK);
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		_getWorkWeeksForDropdown: function(releaseStartDate, releaseEndDate){ //assumes DropDown uses WorkweekDropdown model
			var workweeks = this._getWorkweekDates(releaseStartDate, releaseEndDate),
				data = new Array(workweeks.length);
			for(var i=0, len=workweeks.length; i<len; ++i){
				data[i] = { 
					Workweek: 'ww' + this._getWorkweek(workweeks[i]),
					DateVal: workweeks[i]*1
				};
			}
			return data;
		}	
	});
}());
                /** This class is used to save user preferences per project, that can follow the user from app to app **/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('UserAppsPreference', {
		
		_userAppsPref: 'intel-user-apps-preference', //preference name can be overridden, unless you want all apps to share prefs
		
		_loadAppsPreference: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				filterByUser:true,
				filterByName:me._userAppsPref,
				success: function(prefs) {
					var appPrefs = prefs[me._userAppsPref];
					try{ appPrefs = JSON.parse(appPrefs); }
					catch(e){ appPrefs = { projs:{}, refresh:0};}
					deferred.resolve(appPrefs);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveAppsPreference: function(prefs){
			var me=this, s = {}, deferred = Q.defer();
			prefs = {projs:prefs.projs, refresh:prefs.refresh};
			s[me._userAppsPref] = JSON.stringify(prefs); 
			Rally.data.PreferenceManager.update({
				filterByUser: true,
				filterByName:me._userAppsPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                /** 
	Use this to load stores that have lots of records. it will load them in parallel instead of serially.
	what it does is loads 1 page and then based on the totalCount it loads the rest of the pages in parallel.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('ParallelLoader', {		
		_parallelLoadWsapiStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.wsapi.Store', _.merge({}, config, {
						pageSize:200,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.wsapi.Store', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = ((store.totalCount/200>>0) + (store.totalCount%200 === 0? 0 : 1)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		},
		_parallelLoadLookbackStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.lookback.SnapshotStore', _.merge({}, config, {
						pageSize:20000,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.lookback.SnapshotStore', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = (store.totalCount/20000>>0 + (store.totalCount%20000 ? 0 : 1)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		}
	});
}());
                /** This class is used to communicate between apps the location of the data-integrity dashboard **/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('DataIntegrityDashboardObjectIDPreference', {
		
		_dataIntegrityObjectIdPref: 'intel-data-integrity-dashboard-objectid',
		
		_loadDataIntegrityDashboardObjectID: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName:me._dataIntegrityObjectIdPref,
				success: function(prefs){
					var objectID = prefs[me._dataIntegrityObjectIdPref]*1;
					deferred.resolve(objectID);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_setDataIntegrityDashboardObjectID: function(){
			var me=this, s = {}, deferred = Q.defer(),
				objectID = window.parent.location.hash.split("/").pop();
			s[me._dataIntegrityObjectIdPref] = objectID; 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName:me._dataIntegrityObjectIdPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                (function() {
	var Ext = window.Ext4 || window.Ext;
	
	var teamTypes = [
		'Analog DV', 'Array', 'BI', 'Binsplit',
		'Class TPI', 'CLK', 'EVG','Func Module',
		'Fuse', 'GT Module', 'HTD', 'MIO', 'MIO CLK',
		'MPV', 'PT', 'QRE Qual', 'Reliability', 'Scan',
		'SIO', 'SIO MIO CLK', 'Sort Class TPI', 'Sort TD',
		'Sort TPI', 'TVPV', 'Yield PHI'
	],
		// In English: matches a team type, maybe a number, a hyphen, a train name, and maybe a suffixed parenthetical
		// Remembers the team type, associated keywords, the number or '', and the train name
		// TODO: Fix this and make this faster
		teamInfoRegExp = /^([A-Za-z\s\-]*[A-Za-z])\s+(?:\([A-Za-z\d\s]+\))?\s*(\d*)\s*-\s+([A-Za-z\s]*[A-Za-z]).*$/,
		teamRegExp = /^[A-Za-z ]*[A-Za-z](?:\s\d)?\s-\s.+$/,
		keywordSplitRegExp = /[\s\-]+/;
	
	Ext.define('Teams', {
		_getTeamInfo: function(project) {
			var results = teamInfoRegExp.exec(project.data.Name),
				team = {};
			if (!results) {
				return null;
			}
			team.FullName = project.data.Name;
			team.Type = results[1];
			team.KeyWords = results[1].split(keywordSplitRegExp).concat('');
			team.Number = (results[2] !== '' ? parseInt(results[2], 10) : 1);
			team.Train = results[3];
			team.Name = team.Type + ' ' + team.Number;
			return team;
		},
		
		_createTeamInfoMap: function(teams) {
			var me = this,
				map = {},
				team;
			for (var i in teams) {
				map[teams[i].data.ObjectID] = {
					project: teams[i],
					info: me._getTeamInfo(teams[i])
				};
			}
			return map;
		},
		
		_isValidTeamProjectName: function(project) {
			return teamRegExp.test(project.data.Name) && project.data.Children.Count === 0;
		},
		
		_isValidTeamType: function(type) {
			return _.includes(teamTypes, type);
		},
		
		_filterProjectsByTeamType: function(projects, type) {
			var me = this,
				filter = new RegExp((!type || type === '' || type === 'All') ? '.*' : type),
				filteredProjects = {};
			for (var i in projects) {
				if (filter.test(projects[i].data.Name)) {
					filteredProjects[projects[i].data.ObjectID] = projects[i];
				}
			}
			return filteredProjects;
		},
		
		filterMapByTeamType: function(map, type) {
			var me = this,
				filter = new RegExp((!type || type === '' || type === 'All') ? '.*' : type),
				filteredProjects = {};
			for (var i in map) {
				if (filter.test(map[i].project.data.Name)) {
					filteredProjects[map[i].project.data.ObjectID] = map[i].project;
				}
			}
			return filteredProjects;
		}
	});
})();
                /*
 *	Utility functions relating to horizontal groups
 */
 (function(){
	var Ext = window.Ext4 || window.Ext;

	var HorizontalGroups = {
		ACD: ['CLK 1', 'MIO 1', 'MIO CLK 1', 'CLK MIO 1' /*Incorrect scrum name in Rally*/, 'PT 1', 'PT 2', 'SIO 1', 'SIO 2', 'SIO MIO CLK 1', 'MIO-SIO 2'/*D.N.E. in TCD*/],
		DCD: ['Array 1', 'Array 2', 'Func Module 1', 'Func Module 2', 'GT Module 1', 'HTD 1', 'Scan 1', 'Scan 2'],
		MPV: ['MPV 1', 'MPV 2', 'MPV 3'],
		PHI: ['Binsplit 1', 'Binsplit 2', 'Yield PHI 1'],
		QRE: ['BI 1', 'Reliability 1'],
		SCI: ['Fuse 1', 'Fuse 2', 'TVPV 1', 'TVPV 2'],
		TPI: ['Class TPI 1', 'Sort Class TPI 1', 'Sort Class TPI 2', 'Sort Class TPI 3', 'Sort Class TPI 4', 'Sort Class TPI 5', 'Sort TD 1', 'Sort TPI 1'],
		// The 1's are added for consistency with the other naming conventions
		Other: ['Analog DV 1', 'EVG 1', 'QRE Qual 1']
	};
	var TeamToGroupMap = {
		'CLK 1': 'ACD', 'MIO 1': 'ACD', 'MIO CLK 1': 'ACD', 'CLK MIO 1': 'ACD' /*Incorrect scrum name in Rally*/, 'PT 1': 'ACD', 'PT 2': 'ACD', 'SIO 1': 'ACD', 'SIO 2': 'ACD', 'SIO MIO CLK 1': 'ACD', 'MIO-SIO 2': 'ACD'/*D.N.E in TCD*/,
		'Array 1': 'DCD', 'Array 2': 'DCD', 'Func Module 1': 'DCD', 'Func Module 2': 'DCD', 'GT Module 1': 'DCD', 'HTD 1': 'DCD', 'Scan 1': 'DCD', 'Scan 2': 'DCD',
		'MPV 1': 'MPV', 'MPV 2': 'MPV', 'MPV 3': 'MPV',
		'Binsplit 1': 'PHI', 'Binsplit 2': 'PHI', 'Yield PHI 1': 'PHI',
		'BI 1': 'QRE', 'Reliability 1': 'QRE',
		'Fuse 1': 'SCI', 'Fuse 2': 'SCI', 'TVPV 1': 'SCI', 'TVPV 2': 'SCI',
		'Class TPI 1': 'TPI', 'Sort Class TPI 1': 'TPI', 'Sort Class TPI 2': 'TPI', 'Sort Class TPI 3': 'TPI', 'Sort Class TPI 4': 'TPI', 'Sort Class TPI 5': 'TPI', 'Sort TD 1': 'TPI', 'Sort TPI 1': 'TPI',
		'Analog DV 1': 'Other', 'EVG 1': 'Other', 'QRE Qual 1': 'Other'
	};

	Ext.define('HorizontalGroups', {
		requires: ['Teams'],
	
		_getHorizontalGroups: function() {
			return HorizontalGroups;
		},
		
		_getAllTeams: function() {
			teams = [];
			for (var i in HorizontalGroups) {
				teams = teams.concat(HorizontalGroups[i]);
			}
			return teams;
		},
		
		_isInGroup: function(project, group, info) {
			var me = this,
				team = info || me._getTeamInfo(project);
			// return !!_.find(HorizontalGroups[group], function(team) {return team === teamNameAndNumber;});
			return (TeamToGroupMap[team.Name] === group);
		},
		
		_inWhichGroup: function(project) {
			var team = me._getTeamInfo(project),
				name = team.Type + ' ' + team.Number,
				compareFn = function(n) {return n === name;};
			for (var i in HorizontalGroups) {
				if (_.find(HorizontalGroups[i], compareFn)) {
					return i;
				}
			}
		},
		
		_filterProjectsByHorizontalGroup: function(projects, group) {
			var me = this,
				filteredProjects = {};
			if (!group || group === 'All' || group === '') {
				return projects;
			}
			else {
				for (var i in projects) {
					if (me._isInGroup(projects[i], group)) {
						filteredProjects[projects[i].data.ObjectID] = projects[i];
					}
				}
				return filteredProjects;
			}
		},
		
		_filterMapByHorizontalGroup: function(map, group) {
			var me = this,
				filteredProjects = {};
			if (!group || group === 'All' || group === '') {
				for (var j in map) {
					filteredProjects[map[j].project.data.ObjectID] = map[j].project;
				}
			}
			else {
				for (var i in map) {
					if (me._isInGroup(map[i].project, group, map[i].info)) {
						filteredProjects[map[i].project.data.ObjectID] = map[i].project;
					}
				}
			}
			return filteredProjects;
		},
		
		_loadHorizontalGroup: function(group) {
			return me._loadAllLeafProjects().then(function (projects) {
				return me._filterProjectsByHorizontalGroup(projects, group);
			});
		},
		
		_loadAllHorizontalGroups: function() {
			return me._loadAllLeafProjects().then(function(projects) {
				var groupedProjects = {
					ACD: {},
					DCD: {},
					MPV: {},
					PHI: {},
					QRE: {},
					SCI: {},
					TPI: {},
					Other: {}
				};
				for (var i in projects) {
					groupedProjects[me._inWhichGroup(projects[i])] = projects[i];
				}
				return groupedProjects;
			});
		}
		
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** this combo has filter-as-you-type and drops down on click. it also lets you navigate with arrow keys
		(although there is some arrow key scrolling bug) 
	*/
	Ext.define('IntelComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelcombo', 'widget.intelcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				enableKeyEvents:true,
				queryMode:'local',
				ignoreNoChange:true,
				allowBlank:true,
				listeners: {
					keyup: function(a,b){
						if(b.keyCode>=37 && b.keyCode <=40) return; //arrow keys
						var combo = this;
						combo.store.clearFilter();
						combo.store.filterBy(function(item){
							return item.data[combo.displayField].match(new RegExp(combo.getRawValue(), 'i')) !== null;
						});
					},
					focus: function(combo) {
						combo.store.clearFilter();
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('IntelFixedComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				editable: false,	
				allowBlank:true,
				queryMode:'local',
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					focus: function(combo) {
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}	
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** YOU MUST PASS IT 2 THINGS IN THE CONFIG
		1: releases (array of release records)
		2: currentRelease (what to show as initial value
	*/
	Ext.define('IntelReleasePicker', {
		extend: 'IntelFixedComboBox',
		alias: ['widget.intelreleasepicker'],
		
		constructor: function(options){
			if(!options.releases || !options.currentRelease) return;
			
			options.displayField = 'Name';
			options.value = options.currentRelease.data.Name;
			options.store = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(options.releases, function(r){ return {Name: r.data.Name }; })
			});
			
			options.fieldLabel = options.fieldLabel || 'Release:';
			options.editable = options.editable || false;
			options.width = options.width || 240;
			options.labelWidth = options.labelWidth || 50;
			
			this.callParent([options]); //now that we have the extra stuff added
		}
	});
}());
                /*
 *	This is the hyper-optimized version of the Data Integrity Dashboard. It is capable of viewing
 *	integrity both horizontally and vertically. Use of lodash is minimized for the sake of reducing
 *	function overhead and increasing performance.
 */
(function(){
	var Ext = window.Ext4 || window.Ext;

	/************************** Data Integrity Dashboard *****************************/
	Ext.define('DataIntegrityDashboard', {
		extend: 'IntelRallyApp',
		// Important! Allows the same code to be used for both the horizontal and the vertical versions of the app
		settingsScope: 'workspace',
		cls:'app',
		mixins:[
			'WindowListener',
			'PrettyAlert',
			'IframeResize',
			'IntelWorkweek',
			'ParallelLoader',
			'UserAppsPreference',
			'DataIntegrityDashboardObjectIDPreference',
			'Teams',
			'HorizontalGroups'
		],
		minWidth:1100,
		/*
		 *	This layout consists of:
		 *		Top horizontal bar for controls
		 *		Horizontal bar for a pie chart and heat map (the 'ribbon')
		 *		Two columns (referred to as Left and Right) for grids
		 */
		items:[{
			xtype: 'container',
			id: 'controlsContainer',
			layout:'hbox'
		},{ 
			xtype: 'container',
			id: 'ribbon',
			cls:'ribbon',
			layout: 'column',
			items: [{
				xtype: 'container',
				width:480,
				id: 'pie'
			},{
				xtype: 'container',
				columnWidth:0.999,
				id: 'heatmap'
			}]
		},{
			xtype: 'button',
			id: 'expand-heatmap-button',
			text: 'Expand Heatmap'
		},{
			xtype:'container',
			id:'gridsContainer',
			cls:'grids-container',
			layout: 'column',
			items: [{
				xtype: 'container',
				columnWidth:0.495,
				id: 'gridsLeft',
				cls:'grids-left'
			},{
				xtype: 'container',
				columnWidth:0.495,
				id: 'gridsRight',
				cls:'grids-right'
			}]
		}],
		_colors: [
			'#AAAAAA', //GRAY
			'#2ECC40', //GREEN
			'#7FDBFF', //AQUA
			'#DDDDDD', //SILVER
			'#39CCCC', //TEAL
			'#01FF70', //LIME
			'#FFDC00', //YELLOW
			'#0074D9' //BLUE
		],
		
		_userAppsPref: 'intel-SAFe-apps-preference',
		/**************************************** Settings ***************************************/
		
		/*
		 *	Creates a single check box to control whether the app is in vertical or horizontal mode
		 */
		getSettingsFields: function() {
			return [{name: 'Horizontal', xtype: 'rallycheckboxfield'}];
		},
		
		/**************************************** Launch *****************************************/
		launch: function() {
			var me = this;
			// App configuration function calls
			me._initDisableResizeHandle();
			me._initFixRallyDashboard();
			me._addScrollEventListener();
			me._setDataIntegrityDashboardObjectID();
			me.setLoading('Loading Configuration');
			me._configureIntelRallyApp()
			.then(function() {
				// Get settings
				me.isHorizontalView = me.getSetting('Horizontal');
				
				// Set up overrides
				me._processOverrides();
				
				// Create dummy project record (eliminates network loading and lag time)
				// This is a fun little hack since almost all functions in IntelRallyApp require a project record
				me.ProjectRecord = me._createDummyProjectRecord(me.getContext().getProject());
				
				// Set up some configuration variables
				me.HorizontalGroups = me._getHorizontalGroups();
				me.isScopedToScrum = (me.ProjectRecord.data.Children.Count === 0);
				
				// Initialize filter variables
				if (me.isHorizontalView && !me.isScopedToScrum) {
					me.HorizontalGroup = me.Overrides.HorizontalGroup || 'ACD';
				}
				if (me.isScopedToScrum) {
					me.TeamType = me._getTeamInfo(me.ProjectRecord).Type;
				}
				else {
					me.TeamType = me.Overrides.TeamName || '';
				}
				
				// Get project groups
				return me._loadGroups();
			})
			.then(function() {
				// Get all data
				return me._getReleases().then(function() {return me._loadData();});
			})
			.then(function() {
				// Add remaining properties to the heatmap expansion button
				me._initializeExpandHeatmapButton();
				// Load remaining UI components
				return me._loadUI();
			})
			// Catch-all fail function
			.fail(function(msg) {
				me.setLoading(false);
				me._alert('Error', msg || 'Unknown error');
			})
			.done();
		},
		
		/**************************************** Overrides ***************************************/
		/*
		 *	Searches current URL for override arguments
		 */
		_processOverrides: function() {
			var me = this;
			// Create overrides object
			me.Overrides = {decodedUrl: decodeURI(window.parent.location.href)};
			// Determine if URL parameters should be used
			me.isStandalone = me.Overrides.decodedUrl.match('isStandalone=true') ? true : false;
			if (me.isStandalone) {
				// Process URL for possible parameters
				me.Overrides.isHorizontalView = me.isHorizontalView = me.Overrides.decodedUrl.match('isHorizontal=true');
				me.Overrides.TeamName = me.Overrides.decodedUrl.match('team=.*');
				me.Overrides.TeamName = (me.Overrides.TeamName ? me.Overrides.TeamName[0].slice(5).split('&')[0] : undefined);
				me.Overrides.HorizontalGroup = me.Overrides.decodedUrl.match('group=.*');
				me.Overrides.HorizontalGroup = (me.Overrides.HorizontalGroup ? me.Overrides.HorizontalGroup[0].slice(6).split('&')[0] : undefined);
				me.Overrides.ReleaseName = me.Overrides.decodedUrl.match('release=.*');
				me.Overrides.ReleaseName = (me.Overrides.CurrentReleaseName ? me.Overrides.CurrentReleaseName[0].slice(8).split('&')[0] : undefined);
			}
		},
		
		/**************************************** Group Loading ***********************************/
		/*
		 *	Creates dummy projects for all train scrum groups
		 */
		_createDummyTrainProjects: function() {
			var me = this;
			for (var i = 0; i < me.ScrumGroupConfig.length; i++) {
				if (me.ScrumGroupConfig[i].IsTrain) {
					me.ProjectGroups.push(
						me._createDummyProjectRecord({
							ObjectID: me.ScrumGroupConfig[i].ScrumGroupRootProjectOID
						})
					);
					// Important! This will be used to load portfolio items
					me.PortfolioProjectObjectIDs.push(me.ScrumGroupConfig[i].PortfolioProjectOID);
				}
			}
		},
		
		/*
		 *	Loads/creates dummy projects for necessary scrum groups based on scope and settings
		 */
		_loadGroups: function() {
			var me = this;
			me.ProjectGroups = [];
			me.PortfolioProjectObjectIDs = [];
			
			if (me.isHorizontalView) {
				me._createDummyTrainProjects();
				return me.ProjectGroups;
			}
			else {
				// Project needs to be fully loaded to use the parent field
				return me._loadProject(me.ProjectRecord.data.ObjectID).then(function(project) {
					return me._projectInWhichScrumGroup(project);
				}).then(function(scrumGroup) {
					if (scrumGroup) {
						if (scrumGroup.data.ObjectID === me.ProjectRecord.data.ObjectID) {
							me.ProjectGroups.push(scrumGroup);
						}
						else {
							me.ProjectGroups.push(me.ProjectRecord);
						}
						// Important! Used to get portfolio projects
						me.PortfolioProjectObjectIDs.push(_.find(me.ScrumGroupConfig, function(group) {return group.ScrumGroupRootProjectOID === scrumGroup.data.ObjectID;}).PortfolioProjectOID);
					}
					else {
						me.ProjectGroups.push(me.ProjectRecord);
						for (var i = 0; i < me.ScrumGroupConfig.length; i++) {
							// If the group is a train, create a dummy project and add to the array
							if (me.ScrumGroupConfig[i].IsTrain) me.PortfolioProjectObjectIDs.push(me.ScrumGroupConfig[i].PortfolioProjectOID);
						}
					}
					return me.ProjectGroups;
				});
			}
		},
		
		/**************************************** Data Loading ************************************/
		/*
		 *	Sorts leaf projects by their scrum group
		 */
		_sortLeafProjectsByGroup: function() {
			var me = this;
			for (var projectIndex = 0; projectIndex < me.AllProjectsByGroup.length; projectIndex++) {
				me.LeafProjectsByGroup.push({});
				for (var oid in me.LeafProjects) {
					if (me.AllProjectsByGroup[projectIndex][oid]) {
						me.LeafProjectsByGroup[projectIndex][oid] = me.LeafProjects[oid];
					}
				}
			}
			me.LeafProjectsByGroup = _.filter(me.LeafProjectsByGroup, function(group) {return Object.keys(group).length !== 0;});
		},
		
		/*
		 *	Loads the leaf projects under the scrum groups
		 */
		_getProjects: function() {
			var me = this;
			me.LeafProjectsByGroup = [];
				
			// External definition to avoid definition within loop
			function concatLeaves(leafProjectsUnderGroup) {
				_.assign(allProjects, leafProjectsUnderGroup);
				return leafProjectsUnderGroup;
			}
			
			// If cache does not exist
			if (!me.TeamInfoMap) {
				var projectPromises = [],
					allProjects = {};
					
				// Fill array with promises for all leaf projects of each scrum group
				for (var i = 0; i < me.ProjectGroups.length; i++) {
					projectPromises.push(me._loadAllLeafProjects(me.ProjectGroups[i]).then(concatLeaves));
				}
				
				// Do promises and filter projects down by group then team
				return Q.all(projectPromises).then(function(groupArray) {
					me.AllProjectsByGroup = groupArray;
					// Cache team info
					me.TeamInfoMap = me._createTeamInfoMap(allProjects);
					// Apply all necessary filters
					me.LeafProjects = me._filterProjectsByTeamType(me._filterProjectsByHorizontalGroup(allProjects, me.HorizontalGroup), me.TeamType);
					me._sortLeafProjectsByGroup();
				});
			}
			else {
				// Apply all necessary filters
				me.LeafProjects = me._filterProjectsByTeamType(me._filterMapByHorizontalGroup(me.TeamInfoMap, me.HorizontalGroup), me.TeamType);
				me._sortLeafProjectsByGroup();
			}
		},
		
		/*
		 *	Loads releases associated with the scrum groups
		 */
		_getReleases: function() {
			var me = this,
				releasePromises = [],
				twelveWeeks = 12*7*24*60*60*1000,
				unfilteredReleases = [];
			
			// External definition to avoid definition within loop
			function concatReleases(releasesUnderGroup) {
				unfilteredReleases = unfilteredReleases.concat(releasesUnderGroup);
				return releasesUnderGroup;
			}
			
			// Fill array with promises for all releases under each group after 12 weeks ago
			for (var i = 0; i < me.ProjectGroups.length; i++) {
				releasePromises.push(me._loadReleasesAfterGivenDate(me.ProjectGroups[i], (new Date()).getTime() - twelveWeeks).then(concatReleases));
			}
			
			return Q.all(releasePromises).then(function() {
				me.Releases = _.uniq(unfilteredReleases, false, function(release) {
					return release.data.Name;
				});
				// Set the current release to the release we're in or the closest release to the date
				// Important! This sets the current release to an overridden value if necessary (that's why it's ridiculously long)
				me.CurrentRelease = (me.isStandalone ? _.find(me.Releases, function(release) {return release.data.Name === me.Overrides.ReleaseName;}) : false) || me._getScopedRelease(me.Releases, null, null);
			});
		},
		
		/*
		 *	Creates a filter for the portfolio items
		 */
		_createPortfolioItemFilter: function() {
			var me = this,
				releaseName = me.CurrentRelease.data.Name,
				releaseFilter = Ext.create('Rally.data.wsapi.Filter', {
					property: 'Release.Name',
					operator: '=',
					value: releaseName
				}),
				oids = [];
			return releaseFilter;
		},
		
		/*
		 *	Gets portfolio items in the current release associated with the scrum groups
		 */
		_getPortfolioItems: function() {
			var me = this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				piStore = Ext.create('Rally.data.custom.Store', {
					autoLoad: false,
					model: me['PortfolioItem/' + lowestPortfolioItem],
					pageSize: 200
				}),
				piPromises = [];
			
			// Returns a promise for a store of all stories matching a filter under the project
			function loadStore(project) {
				store = Ext.create('Rally.data.wsapi.Store', {
					model: me['PortfolioItem/' + lowestPortfolioItem],
					filters: [me._createPortfolioItemFilter()],
					autoLoad: false,
					pageSize: 200,
					fetch:['Name', 'ObjectID', 'Project', 'PlannedEndDate', 'ActualEndDate', 'Release', 
							'Description', 'FormattedID', 'UserStories', 'Parent'],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: project.data._ref,
						projectScopeUp: false,
						projectScopeDown: true
					}
				});
				
				return me._reloadStore(store);
			}
			
			// External definition to avoid declaring within loop
			function addRecordsToStore(store) {
				piStore.add(store.getRange());
				return store;
			}
			
			// Create a promise for the portfolio project of each scrum group
			for (var i in me.PortfolioProjectObjectIDs) {
				piPromises.push(
					me._loadProject(me.PortfolioProjectObjectIDs[i]).then(loadStore).then(addRecordsToStore)
				);
			}
			
			return Q.all(piPromises).then(function(stores) {
				me.PortfolioItemStore = piStore;
				return piStore;
			});
		},
	
		/*
		 *	Creates a filter for stories that:
		 *		Belong to one of the projects
		 *					AND
		 *		Are in an during the release but not the release OR in the release
		 */
		_createStoryFilter: function(projects){			
			var me = this,
				releaseName = me.CurrentRelease.data.Name,
				releaseDate = me.CurrentRelease.data.ReleaseDate.toISOString(),
				releaseStartDate = me.CurrentRelease.data.ReleaseStartDate.toISOString(),
				releaseNameFilter = Ext.create('Rally.data.wsapi.Filter', { property: 'Release.Name', value: releaseName }),// this will ONLY get leaf-stories (good)
				// Filter for user stories that in iteration not a release
				inIterationButNotReleaseFilter =
					Ext.create('Rally.data.wsapi.Filter', { property: 'Iteration.StartDate', operator:'<', value:releaseDate}).and(
					Ext.create('Rally.data.wsapi.Filter', { property: 'Iteration.EndDate', operator:'>', value:releaseStartDate})).and(
					Ext.create('Rally.data.wsapi.Filter', { property: 'Release.Name', operator: '!=', value: releaseName })).and(
					Ext.create('Rally.data.wsapi.Filter', { property: 'Iteration.Name', operator: 'contains', value: releaseName}).and(
					Ext.create('Rally.data.wsapi.Filter', { property: 'DirectChildrenCount', value: 0 }))),
				projectFilter;
				
			// There must be leaf projects in order to create a valid filter
			if(me.LeafProjects && Object.keys(me.LeafProjects).length > 0) {
				// Create a filter for all user stories within the leaf projects
				var keys = Object.keys(projects),
					newFilter;
				for (var i = 0; i < keys.length; i++) {
					newFilter = Ext.create('Rally.data.wsapi.Filter', {property: 'Project.ObjectID', value: parseInt(keys[i], 10)});
					if (projectFilter) {
						projectFilter = projectFilter.or(newFilter);
					}
					else {
						projectFilter = newFilter;
					}
				}
			}
			else return undefined;

			return Rally.data.wsapi.Filter.and([
				projectFilter, 
				Rally.data.wsapi.Filter.or([inIterationButNotReleaseFilter, releaseNameFilter])
			]);
		},
		
		/*
		 *	Gets the filtered user stories under the filtered projects
		 */
		_getStories: function() {
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				filter,
				fetchFields = ['Name', 'ObjectID', 'Project', 'PlannedEndDate', 'ActualEndDate', 'StartDate', 'EndDate', 'Iteration', 
					'Release', 'ReleaseStartDate', 'ReleaseDate', 'PlanEstimate', 'FormattedID', 'ScheduleState', 
					'Blocked', 'BlockedReason', 'Blocker', 'CreationDate', lowestPortfolioItem],
				promises = [];
			
			// Create promises for parallel loading stories under leaf projects under each group
			for (var groupIndex in me.LeafProjectsByGroup) {
				filter = me._createStoryFilter(me.LeafProjectsByGroup[groupIndex]);
				var config = {
					model: me.UserStory,
					enablePostGet: true,
					autoLoad: false,
					filters: [filter],
					fetch: fetchFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: me.ProjectGroups[groupIndex].data._ref,
						projectScopeUp: false,
						projectScopeDown: true
					},
					pageSize: 200
				};
				promises.push(me._parallelLoadWsapiStore(config));
			}
			
			// Do promises then compile stories into one store
			return Q.all(promises).then(function(stores) {
				me.UserStoryStore = Ext.create('Rally.data.wsapi.Store', {
					autoLoad: false,
					model: me.UserStory,
					pageSize: 200,
					data: []
				});
				for (var i = 0; i < stores.length; i++) {
					me.UserStoryStore.add(stores[i].getRange());
				}
			});
		},
		
		/*
		 *	Counts the number of stories associated with each portfolio item
		 */
		_countPortfolioItemStories: function() {
			var me = this;
			if(me.PortfolioItemStore){
				var lowestPortfolioItemType = me.PortfolioItemTypes[0];
				me.PortfolioUserStoryCount = {};
				_.each(me.PortfolioItemStore.getRange(), function(portfolioItemRecord){
					me.PortfolioUserStoryCount[portfolioItemRecord.data.ObjectID] = portfolioItemRecord.data.UserStories.Count;
				});
			}
		},
		
		/*
		 *	Control function for loading projects, portfolio items, and stories
		 */
		_loadData: function() {
			var me = this;
			me.setLoading('Loading Data');
			return Q.all([
				me._getProjects(),
				me._getPortfolioItems()
			]).then(function() {
				return me._getStories();
			}).then(function() {
				me.setLoading(false);
				return me._countPortfolioItemStories();
			});
		},
		/**************************************** UI Functions ************************************/
		/*
		 *	Removes the chart, heat map, and all grids
		 */
		_removeAllItems: function(){
			var me = this;
			Ext.getCmp('pie').removeAll();
			Ext.getCmp('heatmap').removeAll();
			Ext.getCmp('gridsLeft').removeAll();
			Ext.getCmp('gridsRight').removeAll();
			var indicator = Ext.getCmp('integrityIndicator');
			if(indicator) indicator.destroy();
		},
		
		/**************************************** UI Component Loading ****************************/
		/*
		 *	Adds the click listener to the expand heatmap button
		 */
		_initializeExpandHeatmapButton: function() {
			var me = this;
			me.isPieHidden = false;
			
			// Add click listener to button
			me.down('#expand-heatmap-button').on('click', function() {
				var me = this,
					heatmap = $('#heatmap'),
					ribbon = me.down('#ribbon');
				// Show pie chart
				if (me.isPieHidden) {
					me.down('#pie').setWidth(480);
					button = me.down('#expand-heatmap-button').setText('Expand Heatmap');
				}
				// Hide pie chart
				else {
					me.down('#pie').setWidth(0);
					button = me.down('#expand-heatmap-button').setText('Show Pie');
				}
				
				// Create heat map
				heatmap.empty();
				heatmap.highcharts(me._getHeatMapConfig());
				
				me.isPieHidden = !me.isPieHidden;
				me._hideHighchartsLinks();
			}, me);
		},
		
		/*
		 *	Loads the release picker
		 */
		_loadReleasePicker: function(){
			var me = this;
			me.ReleasePicker = Ext.getCmp('controlsContainer').add({
				xtype:'intelreleasepicker',
				labelWidth: 50,
				width: 240,
				releases: me.Releases,
				currentRelease: me.CurrentRelease,
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					select: me._releasePickerSelected.bind(me)
				}
			});
		},
		
		/*
		 *	Loads the horizontal group picker
		 */
		_loadHorizontalGroupPicker: function () {
			var me = this;
			me.HorizontalGroupPicker = Ext.getCmp('controlsContainer').add({
				xtype:'intelcombobox',
				width: 200,
				padding:'0 0 0 40px',
				fieldLabel: 'Group:',
				labelWidth:50,
				store: Ext.create('Ext.data.Store', {
					fields: ['Group', 'Teams'],
					data: [{Group:'All', Teams: []}].concat(_.map(Object.keys(me.HorizontalGroups), function(key) {return {Group: key, Teams: me.HorizontalGroups[key]};}))
				}),
				displayField:'Group',
				value:me.HorizontalGroup,
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					select: me._horizontalGroupPickerSelected.bind(me)
				}
			});
		},
		
		/*
		 *	Gets the values for the team picker combo box
		 */
		_getTeamPickerValues: function() {
			var me = this;
			if (me.isHorizontalView) {
				return [{Type:'All'}].concat(
					// In English: get all unique function keywords from the active scrums and sort them alphabetically
					_.sortBy(
						_.uniq(
							_.map(
								_.reduce(me.LeafProjects, function(a, project) {return a.concat(me._getTeamInfo(project).KeyWords);}, []),
								function(type) {return {Type: type};}
							),
							function(key) {return key.Type;}
						),
						function(key) {return key.Type;}
					)
				);
			}
			else {
				return [{Type: 'All'}].concat(_.sortBy(_.map(me.LeafProjects, function(project) {
						return {Type: project.data.Name};
					}),
					function(key) {return key.Type;}
				));
			}
		},
		
		/*
		 *	Loads the team picker
		 */
		_loadTeamPicker: function(){
			var me=this;
			me.TeamPicker = Ext.getCmp('controlsContainer').add({
				id: 'teampicker',
				xtype:'intelcombobox',
				width: 200,
				padding:'0 0 0 40px',
				fieldLabel: 'Team:',
				labelWidth:50,
				store: Ext.create('Ext.data.Store', {
					fields: ['Type'],
					data: me._getTeamPickerValues()
				}),
				displayField:'Type',
				value:'All',
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					select: me._teamPickerSelected.bind(me)
				}
			});
		},
		
		/*
		 *	Generates the url the current view
		 */
		_generateMailto: function() {
			var me = this;
			var base = 'mailto:',
				subject = '&subject=Data%20Integrity%20Dashboard%20View',
				urlSegments = me.Overrides.decodedUrl.split('?'),
				options = [];
				
			// Push options that will always be present
			options.push('isStandalone=true');
			options.push('isHorizontal=' + me.isHorizontalView);
			options.push('release=' + me.CurrentRelease.data.Name);
			
			// Push variable options
			if (me.isHorizontalView) {
				if (me.TeamType !== '') {
					options.push('team=' + me.TeamType);
				}
				if (me.HorizontalGroup) {
					options.push('group=' + me.HorizontalGroup);
				}
			}
			else if (!me.isScopedToScrum) {
				if (me.TeamType !== '') {
					options.push('team=' + me.TeamType);
				}
			}
			
			// Create the correctly encoded app url
			var appUrl = urlSegments[0] + '%3F' + options.join('%26');
			appUrl = appUrl.replace(/\s/g, '%2520');
			
			// Create the full mailto url
			var body = '&body=' + appUrl,
				url = base + subject + body;
			return url;
		},
		
		/*
		 *	Updates the email link
		 */
		_setNewEmailLink: function() {
			var me = this;
			if (me.EmailLink) {
				me.EmailLink.setText('<a href="' + me._generateMailto() + '">Email this view</a>', false);
			}
		},
		
		/*
		 *	Create link to email current view
		 */
		_loadEmailLink: function() {
			var me = this;
			me.EmailLink = Ext.getCmp('controlsContainer').add({
				xtype: 'label',
				width: 200,
				padding: '0 0 0 40px',
				html: '<a href="' + me._generateMailto() + '">Email this view</a>'
			});
		},
		
		/*
		 *	Loads all controls
		 */
		_loadControls: function() {
			var me = this;
			
			// Conditionally loads controls
			if (!me.ReleasePicker) me._loadReleasePicker();
			if (!me.HorizontalGroupPicker && !me.isScopedToScrum && me.isHorizontalView) me._loadHorizontalGroupPicker();
			if (!me.TeamPicker && !me.isScopedToScrum) me._loadTeamPicker();
			if (me.isStandalone) {
				me.ReleasePicker.hide();
				if (me.HorizontalGroupPicker) me.HorizontalGroupPicker.hide();
				if (me.TeamPicker) me.TeamPicker.hide();
			}
			if (!me.EmailLink) me._loadEmailLink();
		},
		
		/*
		 *	Creates and adds the overall indicator of integrity to the app
		 */
		_buildIntegrityIndicator: function(){
			var me=this,
				userStoryGrids = _.filter(Ext.getCmp('gridsContainer').query('rallygrid'), function(grid){ 
					return grid.originalConfig.model == 'UserStory'; 
				}).reverse(),
				storyNum = {},
				storyDen = userStoryGrids[0].originalConfig.totalCount,
				pointNum,
				pointDen = userStoryGrids[0].originalConfig.totalPoints,
				storyPer,
				pointPer;
				
			// Sums the point estimates and number of stories
			_.each(userStoryGrids, function(grid){
				_.each(grid.originalConfig.data, function(item){ storyNum[item.data.ObjectID] = item.data.PlanEstimate; });
			});
			pointNum = (100*(pointDen - _.reduce(storyNum, function(sum, planEstimate){ return sum + planEstimate; }, 0))>>0)/100;
			storyNum = storyDen - Object.keys(storyNum).length;
			storyPer = (storyNum/storyDen*10000>>0)/100;
			pointPer = (pointNum/pointDen*10000>>0)/100;
			
			// Creates the integrity scope label
			// Collective (Release) || Group[/Team] (Release) || Team (Release) || ProjectName (Release)
			var scopeLabel = '';
			if (me.isHorizontalView) {
				if (me.HorizontalGroup) {
					if (me.HorizontalGroup !== 'All') {
						scopeLabel = me.HorizontalGroup;
						if (me.TeamType !== '') {
							scopeLabel = scopeLabel.concat('/' + me.TeamType);
						}
					}
					else {
						if (me.TeamType !== '') {
							scopeLabel = me.TeamType;
						}
						else {
							scopeLabel = 'Collective';
						}
					}
				}
				else {
					if (me.TeamType !== '') {
						scopeLabel = me.TeamType;
					}
					else {
						scopeLabel = 'Collective';
					}
				}
			}
			else {
				if (me.isScopedToScrum) {
					scopeLabel = me.ProjectRecord.data.Name;
				}
				else {
					scopeLabel = me.ProjectRecord.data.Name;
					if (me.TeamType !== '') {
						scopeLabel = scopeLabel.concat('/' + me.TeamType);
					}
				}
			}
			scopeLabel = scopeLabel.concat(' (' + me.CurrentRelease.data.Name + ')');
			
			// Creates and adds the integrity indicator
			me.IntegrityIndicator = Ext.getCmp('controlsContainer').add({
				xtype:'container',
				id:'integrityIndicator',
				padding:'5px 20px 0 0',
				flex:1,
				layout:{
					type:'hbox',
					pack:'end'
				},
				items:[{
					xtype:'container',
					html:'<span class="integrity-inticator-title">' + 
						scopeLabel +
						' Integrity <em>(% Correct)</em></span><br/>' + 
						'<span class="integrity-indicator-value"><b>Stories: </b>' + storyNum + '/' + storyDen + ' <em>(' + storyPer + '%)</em></span><br/>' +
						'<span class="integrity-indicator-value"><b>Points: </b>' + pointNum + '/' + pointDen + ' <em>(' + pointPer + '%)<em/></span>'
				}]
			});
		},
		
		/*
		 *	Loads all data visuals
		 */
		_loadVisuals: function() {
			var me = this;
			me.setLoading('Loading Visuals');
			me._setNewEmailLink();
			me._removeAllItems();
			return me._buildGrids().then(function(){ 
				// Grids must exists in order for calculations to be made
				return Q.all([
					me._buildRibbon(),
					me._buildIntegrityIndicator()
				]).then(function() {
					me.setLoading(false);
				});
			});
		},
		
		/*
		 *	Loads all controls and visuals
		 */
		_loadUI: function() {
			var me = this;
			me._loadControls();
			return me._loadVisuals();
		},
		
		/**************************************** Grids and Charts ********************************/
		_getProjectStoriesForGrid: function(project, grid){
			return _.filter(grid.originalConfig.data, function(story){
				return story.data.Project.ObjectID == project.data.ObjectID;
			});
		},
		_getProjectStoriesForRelease: function(project, grid){
			return _.filter(grid.originalConfig.totalStories, function(story){
				return story.data.Project.ObjectID == project.data.ObjectID;
			});
		},
		_getProjectPointsForGrid: function(project, grid){
			return _.reduce(this._getProjectStoriesForGrid(project, grid), function(sum, story){
				return sum + story.data.PlanEstimate;
			}, 0);
		},		
		_getProjectPointsForRelease: function(project, grid){
			return _.reduce(this._getProjectStoriesForRelease(project, grid), function(sum, story){
				return sum + story.data.PlanEstimate;
			}, 0);
		},
		
		/*
		 *	Gets the stories for the grid, filtering by team name or displaying all
		 */
		_getFilteredStories: function(){
			var me = this;
			if (!me.isScopedToScrum) {
				if (me.TeamType !== '' && me.TeamType !== 'All') {
					var re = new RegExp(me.TeamType);
					return _.filter(me.UserStoryStore.getRange(), function(story){ 
						return re.test(story.data.Project.Name);
					});
				}
				else {
					return me.UserStoryStore.getRange();
				}
			}
			else {
				return me.UserStoryStore.getRange();
			}
		},
		
		/*
		 *	Gets the collection of items of the lowest portfolio item type
		 */
		_getFilteredLowestPortfolioItems: function(){ 
			var me = this,
				activeGroups = {},
				activeProjects = me._filterProjectsByTeamType(me.LeafProjects, me.TeamType),
				portfolioItems = me.PortfolioItemStore.getRange(),
				filteredPortfolioItems = [];
				
			// Determine the active scrum groups (those that have projects remaining after filtering by group and team type)
			for (var i in activeProjects) {
				for (var j in me.ScrumGroupConfig) {
					if (!activeGroups[me.ScrumGroupConfig[j].PortfolioProjectOID] && me.ScrumGroupConfig[j].ScrumGroupName.indexOf(me.TeamInfoMap[activeProjects[i].data.ObjectID].info.Train) > -1) {
						activeGroups[me.ScrumGroupConfig[j].PortfolioProjectOID] = me.ScrumGroupConfig[j];
					}
				}
			}
			
			// If the portfolio item's project or that project's parent is an active scrum group, use it
			for (var k in portfolioItems) {
				if (activeGroups[portfolioItems[k].data.Project.Parent.ObjectID] || activeGroups[portfolioItems[k].data.Project.ObjectID]) {
					filteredPortfolioItems.push(portfolioItems[k]);
				}
			}
			return filteredPortfolioItems;
		},
		
		/*
		 *	Gets the configuration of the pie chart
		 */
		_getPieChartConfig: function() { 
			var me=this,
				// Create data for the chart using each grid's data
				chartData = _.map(Ext.getCmp('gridsContainer').query('rallygrid'), function(grid) { 
					return {
						name: grid.originalConfig.title,
						y: grid.originalConfig.data.length,
						totalCount: grid.originalConfig.totalCount,
						gridID: grid.originalConfig.id,
						model: grid.originalConfig.model
					};
				});
			
			// Change data if no problem stories are found
			if(_.every(chartData, function(item){ return item.y === 0; })){
				chartData = [{
					name: 'Everything is correct!',
					y:1,
					totalCount:1,
					color:'#2ECC40', //GREEN
					model:''
				}];
			}
			
			// Create the chart config
			return {
				chart: {
					height:370,
					marginLeft: -15,
					plotBackgroundColor: null,
					plotBorderWidth: 0,
					plotShadow: false
				},
				colors: me._colors,
				title: { text: null },
				tooltip: { enabled:false },
				plotOptions: {
					pie: {
						dataLabels: {
							enabled: true,
							distance:25,
							crop:false,
							overflow:'none',
							formatter: function() {
								var str = '<b>' + this.point.name + '</b>: ' + this.point.y;
								return str + '/' + this.point.totalCount;
							},
							style: { 
								cursor:'pointer',
								color: 'black'
							}
						},
						startAngle: 10,
						endAngle: 170,
						center: ['0%', '50%']
					}
				},
				series: [{
					type: 'pie',
					name: 'Grid Count',
					innerSize: '25%',
					size:260,
					point: {
						events: {
							click: function(e) {
								if(e.point.gridID) Ext.get(e.point.gridID).scrollIntoView(me.el);
								e.preventDefault();
							}
						}
					},
					data: chartData
				}]
			};
		},
		
		/*
		 *	Gets the configuration of the heat map
		 */
		_getHeatMapConfig: function() { 
			var me=this,
				highestNum = 0,
				userStoryGrids = _.filter(Ext.getCmp('gridsContainer').query('rallygrid'), function(grid){ 
					return grid.originalConfig.model == 'UserStory'; 
				}).reverse(),
				chartData = [],
				selectIdFunctionName = '_selectId' + (Math.random()*10000>>0);
				
			// Get the data for each scrum from each grid
			_.each(userStoryGrids, function(grid, gindex) {
				_.each(_.sortBy(me._filterProjectsByTeamType(me._filterProjectsByHorizontalGroup(me.LeafProjects, me.HorizontalGroup), me.TeamType), function(p){ return p.data.Name; }), function(project, pindex){
					var gridCount = me._getProjectStoriesForGrid(project, grid).length;
					highestNum = Math.max(gridCount, highestNum);
					chartData.push([pindex, gindex, gridCount]);
				});
			});
			
			// Function for scrolling to grid
			window[selectIdFunctionName] = function(gridId){
				Ext.get(gridId).scrollIntoView(me.el);
			};
			
			// Create the map config
			return {       
				chart: {
					type: 'heatmap',
					height:370,
					marginTop: 10,
					marginLeft: 140,
					marginBottom: 80
				},
				colors: ['#AAAAAA'],
				title: { text: null },
				xAxis: {
					categories: _.sortBy(_.map(me._filterProjectsByTeamType(me._filterProjectsByHorizontalGroup(me.LeafProjects, me.HorizontalGroup), me.TeamType), 
						function(project){ return project.data.Name; }),
						function(p){ return p; }),
					labels: {
						style: { width:100 },
						formatter: function(){
							var text = '<span title="' + this.value + '" class="heatmap-xlabel-text">' + this.value + '</span>';
							return '<a class="heatmap-xlabel">' + text + '</a>';
						},
						useHTML:true,
						rotation: -45
					}
				},
				yAxis: {
					categories: _.map(userStoryGrids, function(grid){ return grid.originalConfig.title; }),
					title: null,
					labels: {
						formatter: function(){
							var text = this.value,
								index = _.indexOf(this.axis.categories, text),
								gridID = userStoryGrids[index].originalConfig.id,
								styleAttr='style="background-color:' + me._colors[userStoryGrids.length - index - 1] + '"';
							return '<div class="heatmap-ylabel"' + styleAttr + ' onclick="' + 
												selectIdFunctionName + '(\'' + gridID +  '\')">' + text + '</div>';
						},
						useHTML:true
					}
				},
				colorAxis: {
					min: 0,
					minColor: '#FFFFFF',
					maxColor: highestNum ? '#ec5b5b' : '#FFFFFF' //if they are all 0 make white
				},
				plotOptions: {
					series: {
						point: {
							events: {
								click: function(e){
									var point = this,
										scrum = _.sortBy(me.LeafProjects, function(p){ return p.data.Name; })[point.x],
										grid = userStoryGrids[point.y];
									me._onHeatmapClick(point, scrum, grid);
								}
							}
						}
					}
				},
				legend: { enabled:false },
				tooltip: { enabled:false },
				series: [{
					name: 'Errors per Violation per Scrum',
					borderWidth: 1,
					data: chartData,
					dataLabels: {
						enabled: true,
						color: 'black',
						style: {
							textShadow: 'none'
						}
					}
				}]  
			};
		},
		
		/*
		 *	Creates and adds all charts
		 */
		_buildRibbon: function() {
			var me = this;
			$('#pie').highcharts(me._getPieChartConfig());
			$('#heatmap').highcharts(me._getHeatMapConfig());
			me._hideHighchartsLinks();
		},
		
		/*
		 *	Creates a Rally grid based on the given configuration
		 */
		_addGrid: function(gridConfig){
			var me=this,
				lowestPortfolioItemType = me.PortfolioItemTypes[0],
				randFunctionName = '_scrollToTop' + (Math.random()*10000>>0);
				
			window[randFunctionName] = function(){ Ext.get('controlsContainer').scrollIntoView(me.el); };
			
			var getGridTitleLink = function(data, model){
					var hasData = !!data,
						countNum = data && data.length,
						countDen = gridConfig.totalCount,
						pointNum = data && (100*_.reduce(data, function(sum, item){ return sum + item.data.PlanEstimate; }, 0)>>0)/100,
						pointDen = gridConfig.totalPoints,
						type = (model==='UserStory' ? 'Stories' : lowestPortfolioItemType + 's');
					return sprintf([
						'<span class="data-integrity-grid-header-left">',
							'%s',
							'<span class="data-integrity-grid-header-stats">%s<br/>%s</span>',
						'</span>',
						'<span class="data-integrity-grid-header-top-link"><a onclick="%s()">Top</a></span>'
					].join(''),
					gridConfig.title + (hasData ? '<br>' : ''),
					hasData ? sprintf('<b>%s:</b> %s/%s (%s%%)', type, countNum, countDen, (countNum/countDen*10000>>0)/100) : '',
					(hasData && model=='UserStory') ? sprintf('<b>Points:</b> %s/%s (%s%%)', pointNum, pointDen, (pointNum/pointDen*10000>>0)/100) : '',
					randFunctionName);
				},
				storeModel = (gridConfig.model == 'UserStory') ? me.UserStoryStore.model : me.PortfolioItemStore.model,
				grid = Ext.getCmp('grids' + gridConfig.side).add(gridConfig.data.length ? 
					Ext.create('Rally.ui.grid.Grid', {
						title: getGridTitleLink(gridConfig.data, gridConfig.model),
						id: gridConfig.id,
						cls:'grid-unhealthy data-integrity-grid rally-grid',
						columnCfgs: gridConfig.columns,
						enableBulkEdit: true,
						emptyText: ' ',
						originalConfig:gridConfig,
						gridContainer: Ext.getCmp('grids' + gridConfig.side),
						pagingToolbarCfg: {
							pageSizes: [10, 15, 25, 100],
							autoRender: true,
							resizable: false
						},
						store: Ext.create('Rally.data.custom.Store', {
							model: storeModel,
							pageSize:10,
							data: gridConfig.data,
							autoLoad: false
						})
					}) : 
					Ext.create('Rally.ui.grid.Grid', {
						xtype:'rallygrid',
						title: getGridTitleLink(),
						id: gridConfig.id,
						cls:' data-integrity-grid grid-healthy',
						showPagingToolbar: false,
						showRowActionsColumn: false,
						emptyText: '0 Problems!',
						originalConfig: gridConfig,
						gridContainer: Ext.getCmp('grids' + gridConfig.side),
						store: Ext.create('Rally.data.custom.Store', {data:[] })
					})
				);
			return grid;
		},
		
		/*
		 *	Creates grids with filtered results for the user stories and adds them to the screen
		 */
		_buildGrids: function() { 
			var me = this,
				filteredStories = me._getFilteredStories(),
				filteredLowestPortfolioItems = me._getFilteredLowestPortfolioItems(),
				lowestPortfolioItemType = me.PortfolioItemTypes[0],
				releaseName = me.CurrentRelease.data.Name,
				releaseDate = new Date(me.CurrentRelease.data.ReleaseDate),
				releaseStartDate = new Date(me.CurrentRelease.data.ReleaseStartDate),
				now = new Date(),
				defaultUserStoryColumns = [{
						text:'FormattedID',
						dataIndex:'FormattedID', 
						editor:false
					},{
						text:'Name',
						dataIndex:'Name', 
						editor:false
					}].concat(!me.CurrentScrum ? [{
						text: 'Scrum', 
						dataIndex: 'Project',
						editor:false
					}] : []),
				defaultLowestPortfolioItemColumns = [{
						text:'FormattedID',
						dataIndex:'FormattedID', 
						editor:false
					},{
						text:'Name',
						dataIndex:'Name', 
						editor:false
					},{
						text:'PlannedEndDate',
						dataIndex:'PlannedEndDate', 
						editor:false
					}],
				gridConfigs = [{
					showIfLeafProject:true,
					title: 'Blocked Stories',
					id: 'grid-blocked-stories',
					model: 'UserStory',
					columns: defaultUserStoryColumns.concat([{
						text:'Blocked',
						dataIndex:'Blocked'
					},{
						text:'BlockedReason',
						dataIndex:'BlockedReason',
						tdCls:'editor-cell'
					},{
						text:'Days Blocked',
						tdCls:'editor-cell',
						editor:false,
						renderer:function(val, meta, record){
							var day = 1000*60*60*24;
							return (now - new Date(record.data.Blocker.CreationDate))/day>>0;
						}
					}]),
					side: 'Left',
					filterFn:function(item){ 
						if(!item.data.Release || item.data.Release.Name != releaseName) return false;
						return item.data.Blocked; 
					}
				},{
					showIfLeafProject:true,
					title: 'Unsized Stories',
					id: 'grid-unsized-stories',
					model: 'UserStory',
					columns: defaultUserStoryColumns.concat([{
						text:'PlanEstimate',
						dataIndex:'PlanEstimate',
						tdCls:'editor-cell'
					}]),
					side: 'Left',
					filterFn:function(item){ 
						if(!item.data.Release || item.data.Release.Name != releaseName) return false;
						return item.data.PlanEstimate === null; 
					}
				},{
					showIfLeafProject:true,
					title: 'Improperly Sized Stories',
					id: 'grid-improperly-sized-stories',
					model: 'UserStory',
					columns: defaultUserStoryColumns.concat([{
						text:'PlanEstimate',
						dataIndex:'PlanEstimate',
						tdCls:'editor-cell'
					}]),
					side: 'Left',
					filterFn:function(item){
						if(!item.data.Release || item.data.Release.Name != releaseName) return false;
						if(item.data.Children.Count === 0) return false;
						var pe = item.data.PlanEstimate;
						return pe && pe !== 0 && pe !== 1 && pe !== 2 && pe !== 4 && pe !== 8 && pe !== 16;
					}
				},{
					showIfLeafProject:true,
					title: 'Stories in Release without Iteration',
					id: 'grid-stories-in-release-without-iteration',
					model: 'UserStory',
					columns: defaultUserStoryColumns.concat([{
						text:'Iteration',
						dataIndex:'Iteration',
						tdCls:'editor-cell'
					}]),
					side: 'Left',
					filterFn:function(item){ 
						if(!item.data.Release || item.data.Release.Name != releaseName) return false;
						return !item.data.Iteration; 
					}
				},{
					showIfLeafProject:true,
					title: 'Stories in Iteration not attached to Release',
					id: 'grid-stories-in-iteration-not-attached-to-release',
					model: 'UserStory',
					columns: defaultUserStoryColumns.concat([{
						text:'Iteration',
						dataIndex:'Iteration',
						tdCls:'editor-cell'
					},{
						text:'Release',
						dataIndex:'Release',
						tdCls:'editor-cell'
					}]),
					side: 'Right',
					filterFn:function(item){
						/* if(!item.data.Iteration || item.data.Release) return false;
						return item.data.Iteration.StartDate < releaseDate && 
							item.data.Iteration.EndDate > releaseStartDate; */
						if (!item.data.Iteration) return false;
						return (new Date(item.data.Iteration.StartDate) < releaseDate && new Date(item.data.Iteration.EndDate) > releaseStartDate) &&
							(!item.data.Release || item.data.Release.Name.indexOf(releaseName) < 0);
					}
				},{
					showIfLeafProject:true,
					title: 'Unaccepted Stories in Past Iterations',
					id: 'grid-unaccepted-stories-in-past-iterations',
					model: 'UserStory',
					columns: defaultUserStoryColumns.concat([{
						text:'Iteration',
						dataIndex:'Iteration',
						editor:false
					},{
						text:'ScheduleState',
						dataIndex:'ScheduleState',
						tdCls:'editor-cell'
					}]),
					side: 'Right',
					filterFn:function(item){
						if(!item.data.Release || item.data.Release.Name != releaseName) return false;
						if(!item.data.Iteration) return false;
						return new Date(item.data.Iteration.EndDate) < now && item.data.ScheduleState != 'Accepted';
					}
				},{
					showIfLeafProject:true,
					title: 'Stories Scheduled After ' + lowestPortfolioItemType + ' End Date',
					id: 'grid-stories-scheduled-after-' + lowestPortfolioItemType + '-end',
					model: 'UserStory',
					columns: defaultUserStoryColumns.concat([{
						text:'Iteration',
						dataIndex:'Iteration',
						editor:false
					},{
						text: lowestPortfolioItemType,
						dataIndex: lowestPortfolioItemType,
						editor:false
					}]),
					side: 'Right',
					filterFn:function(item){
						if(!item.data.Release || item.data.Release.Name != releaseName) return false;
						if(!item.data.Iteration || !item.data[lowestPortfolioItemType] || 
							!item.data[lowestPortfolioItemType].PlannedEndDate || !item.data.Iteration.StartDate) return false;
						if(item.data.ScheduleState == 'Accepted') return false;
						return item.data[lowestPortfolioItemType].PlannedEndDate < item.data.Iteration.StartDate;
					}
				},{
					showIfLeafProject:false,
					title: 'Features with No Stories',
					id: 'grid-features-with-no-stories',
					model: 'PortfolioItem/' + lowestPortfolioItemType,
					columns: defaultLowestPortfolioItemColumns,
					side: 'Right',
					filterFn:function(item){ 
						if(!item.data.Release || item.data.Release.Name != releaseName) return false;
						return !me.PortfolioUserStoryCount[item.data.ObjectID];
					}
				}];

			return Q.all(_.map(gridConfigs, function(gridConfig){
				if(!gridConfig.showIfLeafProject && me.isScopedToScrum) return Q();
				else {
					var list = gridConfig.model == 'UserStory' ? filteredStories : filteredLowestPortfolioItems;
					gridConfig.data = _.filter(list, gridConfig.filterFn);
					gridConfig['total' + (gridConfig.model == 'UserStory' ? 'Stories' : lowestPortfolioItemType + 's')] = list;
					gridConfig.totalCount = list.length;
					gridConfig.totalPoints = (100*_.reduce(list, function(sum, item){ return sum + item.data.PlanEstimate; }, 0)>>0)/100;
					return me._addGrid(gridConfig);
				}
			}))
			.fail(function(reason){ me._alert('ERROR:', reason); });
		},
		
		/**************************************** Event Handling **********************************/
		/*
		 *	Reloads the page with new data and saves the selection in the app preferences
		 */
		_releasePickerSelected: function(combo, records){
			var me=this;
			me._clearToolTip();
			me.setLoading();
			me.CurrentRelease = _.find(me.Releases, function(rr){ return rr.data.Name == records[0].data.Name; });
			return me._loadData().then(function() {return me._loadVisuals();});
		},
		
		/*
		 *	Changes the group to filter by and reloads data
		 */
		_horizontalGroupPickerSelected: function(combo, records) {
			var me = this;
			me._clearToolTip();
			me.setLoading(true);
			me.HorizontalGroup = combo.getValue();
			me.TeamType = '';
			me.TeamPicker.setValue('All');
			return me._loadData().then(function() {
				return me._loadVisuals();
			}).then(function() {
				me.TeamPicker.bindStore(Ext.create('Ext.data.Store', {
					fields: ['Type'],
					data: me._getTeamPickerValues()
				}));
				me.setLoading(false);
			});
		},
		
		/*
		 *	Changes the team name to filter by and reloads all graphical elements
		 */
		_teamPickerSelected: function(combo, records){
			var me = this;
			me._clearToolTip();
			me.setLoading(true);
			if (combo.getValue() !== 'All') me.TeamType = combo.getValue();
			else me.TeamType = '';
			return me._loadVisuals();
		},
		
		/*
		 *	Displays a tool tip when a point on the heat map is clicked
		 */
		_onHeatmapClick: function(point, scrum, grid){
			var me=this,
				panelWidth=320,
				rect = point.graphic.element.getBoundingClientRect(),
				leftSide = rect.left,
				rightSide = rect.right,
				topSide = rect.top,
				showLeft = leftSide - panelWidth > 0,
				x = point.x,
				y = point.y,
				storyDen = me._getProjectStoriesForRelease(scrum, grid).length,
				storyNum = me._getProjectStoriesForGrid(scrum, grid).length,
				pointDen = (100*me._getProjectPointsForRelease(scrum, grid)>>0)/100,
				pointNum = (100*me._getProjectPointsForGrid(scrum, grid)>>0)/100,
				storyPer = (10000*storyNum/storyDen>>0)/100,
				pointPer = (10000*pointNum/pointDen>>0)/100;
			
			// Clears tool tip and returns if the position hasn't changed
			if(me.tooltip && me.tooltip.x == x && me.tooltip.y == y) return me._clearToolTip();
			me._clearToolTip();
			
			// Builds the tool tip
			me.tooltip = {
				x:x,
				y:y,
				panel: Ext.widget('container', {
					floating:true,
					width: panelWidth,
					autoScroll:false,
					id:'HeatmapTooltipPanel',
					cls: 'intel-tooltip',
					focusOnToFront:false,
					shadow:false,
					renderTo:Ext.getBody(),
					items: [{
						xtype:'container',
						layout:'hbox',
						cls: 'intel-tooltip-inner-container',
						items:[{
							xtype:'container',
							cls: 'intel-tooltip-inner-left-container',
							flex:1,
							items:[{
								xtype:'rallygrid',
								title: scrum.data.Name,
								columnCfgs:[{
									dataIndex:'Label',
									width:60,
									draggable:false,
									sortable:false,
									resizable:false,
									editable:false
								},{
									text:'Outstanding',
									dataIndex:'Outstanding',
									width:85,
									draggable:false,
									sortable:false,
									resizable:false,
									editable:false
								},{
									text:'Total',
									dataIndex:'Total',
									width:60,
									draggable:false,
									sortable:false,
									resizable:false,
									editable:false
								},{
									text:'% Problem',
									dataIndex:'Percent',
									width:70,
									draggable:false,
									sortable:false,
									resizable:false,
									editable:false
								}],
								store: Ext.create('Rally.data.custom.Store', {
									data:[{
										Label:'Stories',
										Outstanding:storyNum,
										Total:storyDen,
										Percent:storyPer + '%'
									},{
										Label:'Points',
										Outstanding:pointNum,
										Total:pointDen,
										Percent:pointPer + '%'
									}]
								}),
								showPagingToolbar: false,
								showRowActionsColumn: false
							},{
								xtype:'button',
								id:'heatmap-tooltip-goto-button',
								text:'GO TO THIS GRID',
								handler: function(){
									me._clearToolTip();
									Ext.get(grid.originalConfig.id).scrollIntoView(me.el);
								}
							}]
						},{
							xtype:'button',
							cls:'intel-tooltip-close',
							text:'X',
							width:20,
							handler: function(){ me._clearToolTip(); }
						}]
					}],
					listeners:{
						afterrender: function(panel){
							panel.setPosition(showLeft ? leftSide-panelWidth : rightSide, topSide);
						}
					}
				})	
			};
			me.tooltip.triangle = Ext.widget('container', {
				floating:true,
				width:0, height:0,
				focusOnToFront:false,
				shadow:false,
				renderTo:Ext.getBody(),
				listeners:{
					afterrender: function(panel){
						setTimeout(function(){
							panel.addCls('intel-tooltip-triangle');
							panel.setPosition(showLeft ? leftSide - 10 : rightSide - 10, topSide);
						}, 10);
					}
				}
			});	
		},
		
		/**************************************** Tooltip Functions *******************************/
		/*
		 *	Removes the tool tip from the screen
		 */
		_clearToolTip: function(){
			var me = this;
			if(me.tooltip){
				me.tooltip.panel.hide();
				me.tooltip.triangle.hide();
				me.tooltip.panel.destroy();
				me.tooltip.triangle.destroy();
				me.tooltip = null;
			}
		},
		/*
		 *	Clears the tool tip at the start of scrolling
		 */
		_addScrollEventListener: function(){
			var me=this;
			setTimeout(function addScrollListener(){
				if(me.getEl()) me.getEl().dom.addEventListener('scroll', function(){ me._clearToolTip(); });
				else setTimeout(addScrollListener, 10);
			}, 0);
		},
		
		/**************************************** Utility Functions *******************************/
		/*
		 *	Creates a dummy project record with only necessary data fields populated
		 */
		_createDummyProjectRecord: function(dataObject) {
			return {
				data: dataObject
			};
		},
		
		/*
		 *	Hides the Highcharts link
		 */
		_hideHighchartsLinks: function(){ 
			$('.highcharts-container > svg > text:last-child').hide(); 
		}
	});
})();

            Rally.launchApp('DataIntegrityDashboard', {
                name:"Data Integrity Dashboard",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .x-grid-cell.intel-editor-cell *,
.x4-grid-cell.intel-editor-cell *,
.intel-editor-cell {
  cursor: pointer !important;
}
.fa.fa-md {
  font-size: 1.05rem;
  line-height: .75em;
  vertical-align: -15%;
}

    </style>

    <style type="text/css">
        .intel-tooltip {
  padding: 10px;
  background-color: #C0D9FA;
  border-radius: 8px;
  z-index: 500;
  box-shadow: -3px 3px 3px;
}
.intel-tooltip p {
  margin: 2px 0 2px 0;
}
.intel-tooltip ol {
  margin: 2px 0 2px 0;
  padding-left: 20px;
}
.intel-tooltip-triangle {
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 10px solid #C0D9FA;
  height: 0px;
  width: 0px;
  z-index: 500;
}
.intel-tooltip-triangle-up {
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 10px solid #C0D9FA;
  height: 0px;
  width: 0px;
  z-index: 500;
}
.intel-tooltip-close {
  padding: 0 0 2px 0;
  font-weight: bold;
  margin-left: 5px;
  margin-top: -5px;
  border-radius: 10px;
}
.intel-tooltip-inner-container,
.intel-tooltip-inner-container * {
  overflow: visible;
}
.intel-tooltip-inner-left-container {
  overflow: hidden;
}

    </style>

    <style type="text/css">
        .app {
  margin: 0;
  padding: 0;
  width: 100%;
  overflow-x: hidden !important;
}
.ribbon {
  margin: 10px 0 0 0;
  padding: 0;
  width: 98%;
  height: 390px;
  border: 1px solid #AAA;
}
/*********************************** GRIDS  ****************************/
.grids-container {
  margin: 10px 0 0 0;
  padding: 0;
  position: relative !important;
  width: 98%;
}
.grids-container .grids-left {
  margin-right: 5px;
  position: absolute !important;
  left: 0;
}
.grids-container .grids-right {
  margin-left: 5px;
  position: absolute !important;
  right: 0;
}
.data-integrity-grid {
  border: 2px solid #AAA;
  padding: 0;
  margin: 0 0 5px 0;
}
.grid-healthy.data-integrity-grid .x-panel-header,
.grid-healthy.data-integrity-grid .x4-panel-header {
  font-weight: bold;
  background-color: rgba(0, 255, 0, 0.4) !important;
}
.grid-unhealthy.data-integrity-grid .x-panel-header,
.grid-unhealthy.data-integrity-grid .x4-panel-header {
  font-weight: bold;
  background-color: rgba(255, 0, 0, 0.4) !important;
}
.data-integrity-grid .grid-pager {
  margin: 3px !important;
}
.data-integrity-grid .editor-cell,
.data-integrity-grid .editor-cell * {
  cursor: pointer !important;
}
.data-integrity-grid.rally-grid .x-grid-row-over .editable.rally-edit-cell:not(.editor-cell):hover,
.data-integrity-grid.rally-grid .x4-grid-row-over .editable.rally-edit-cell:not(.editor-cell):hover {
  background-image: none;
}
.data-integrity-grid-header-left {
  float: left;
  font-size: 1rem;
}
.data-integrity-grid-header-stats {
  font-size: 12px;
}
.data-integrity-grid-header-top-link {
  float: right;
  cursor: pointer;
  font-weight: bold;
  font-size: 0.8rem;
}
.data-integrity-grid .x-grid-cell-inner,
.data-integrity-grid .x4-grid-cell-inner {
  white-space: normal;
}
/*********************************** HEATMAP  ****************************/
.highcharts-container {
  overflow: visible !important;
}
.my-heatmap-tooltip {
  z-index: 10000;
  border-radius: 2px;
  padding: 5px;
  border: 1px solid gray;
  background: lightgray;
}
.heatmap-xlabel {
  white-space: nowrap;
  z-index: 100;
  cursor: pointer;
}
.heatmap-xlabel:hover {
  color: blue;
}
.heatmap-xlabel .curscrum {
  font-weight: bolder;
  font-size: 1.1em;
}
.heatmap-xlabel-text {
  display: block;
  overflow: hidden;
}
#heatmap .highcharts-yaxis-labels > span {
  width: 134px !important;
}
.heatmap-ylabel {
  white-space: normal;
  width: 134px;
  height: 35px;
  text-align: center;
  display: flex;
  border-bottom-left-radius: 5px;
  border-top-left-radius: 5px;
  justify-content: center;
  align-items: center;
  font-size: 0.65rem;
  cursor: pointer;
  padding: 0 2px 0 2px;
  margin: 0;
}
/*********************************** integrity indicator ****************/
.integrity-inticator-title {
  font-size: 1.1rem;
  padding-right: 5px;
  text-decoration: underline;
}
.integrity-indicator-value {
  font-size: 1rem;
}
/*********************************** TOOLTIP ****************************/
#heatmap-tooltip-goto-button {
  margin-top: 5px;
}

    </style>
</head>
<body>
</body>
</html>
